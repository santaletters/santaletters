import { Hono } from "npm:hono@4";
import { cors } from "npm:hono/cors";
import { logger } from "npm:hono/logger";
import Stripe from "npm:stripe@17.4.0";
import * as kv from "./kv_store.tsx";
import { registerTrackdeskRoutes } from "./trackdesk.tsx";

const app = new Hono();
// Email configuration - Use verified domain
const EMAIL_FROM = "Santa's Letters <noreply@updates.santascertifiedletter.com>";

// Force redeploy - version 2.0.8 - TRACKDESK ADVERTISER POSTBACK

// Enable logger
app.use('*', logger(console.log));

// Enable CORS for all routes and methods
app.use(
  "/*",
  cors({
    origin: "*",
    allowHeaders: ["Content-Type", "Authorization", "stripe-signature"],
    allowMethods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
    exposeHeaders: ["Content-Length"],
    maxAge: 600,
  }),
);

// Initialize Stripe (only if secret key is available)
const stripeSecretKey = Deno.env.get("STRIPE_SECRET_KEY");
let stripe: Stripe | null = null;

if (stripeSecretKey && stripeSecretKey.startsWith("sk_")) {
  try {
    stripe = new Stripe(stripeSecretKey, {
      apiVersion: "2024-11-20.acacia",
    });
    console.log("‚úÖ Stripe initialized successfully");
  } catch (error) {
    console.error("‚ùå Failed to initialize Stripe:", error);
  }
} else {
  console.warn("‚ö†Ô∏è STRIPE_SECRET_KEY not configured. Webhook functionality will be disabled.");
}

// Helper function to get or create Stripe product for subscriptions
async function getOrCreateSubscriptionProduct(stripe: Stripe): Promise<string> {
  try {
    // Try to retrieve the product from KV store
    const cachedProductId = await kv.get("stripe:product:santa_subscription");
    if (cachedProductId) {
      console.log("‚úÖ Using cached product ID:", cachedProductId);
      return cachedProductId as string;
    }

    // Search for existing product
    const products = await stripe.products.search({
      query: "metadata['santa_subscription']:'true' AND active:'true'",
      limit: 1,
    });

    if (products.data.length > 0) {
      const productId = products.data[0].id;
      console.log("‚úÖ Found existing product:", productId);
      await kv.set("stripe:product:santa_subscription", productId);
      return productId;
    }

    // Create new product
    const product = await stripe.products.create({
      name: "Santa's Magical Adventures",
      description: "Monthly subscription - Stories from Santa throughout the year",
      metadata: {
        santa_subscription: "true",
      },
    });

    console.log("‚úÖ Created new product:", product.id);
    await kv.set("stripe:product:santa_subscription", product.id);
    return product.id;
  } catch (error) {
    console.error("‚ùå Error managing subscription product:", error);
    // Fallback: create inline without caching
    const product = await stripe.products.create({
      name: "Santa's Magical Adventures",
      description: "Monthly subscription - Stories from Santa",
    });
    return product.id;
  }
}

// Helper function to log email activity
async function logEmailActivity(
  orderId: string,
  emailType: string,
  recipient: string,
  subject: string,
  emailId?: string
) {
  try {
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      console.error(`‚ùå Order ${orderId} not found for email logging`);
      return;
    }

    if (!order.activityLog) {
      order.activityLog = [];
    }

    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: `Email Sent - ${subject}`,
      details: `${subject} sent to ${recipient}`,
      user: 'System',
      emailType: emailType,
      emailRecipient: recipient,
      emailId: emailId || 'N/A'
    });

    await kv.set(`order:${orderId}`, order);
    console.log(`‚úÖ Email activity logged for order ${orderId}: ${emailType}`);
  } catch (error) {
    console.error(`‚ùå Error logging email activity for order ${orderId}:`, error);
  }
}

// Health check endpoint
app.get("/make-server-cf244566/", (c) => {
  return c.json({ 
    message: "Santa Letters Server is running! üéÖ",
    version: "2.0.6",
    timestamp: new Date().toISOString(),
    clickTrackingEnabled: true
  });
});

// TEST: Direct click tracking route (temporary)
app.get("/make-server-cf244566/track-click-test/:affiliateId", async (c) => {
  console.log("üß™ TEST ROUTE HIT: track-click-test");
  const affiliateId = c.req.param("affiliateId");
  return c.json({ 
    success: true, 
    message: "Test route works!",
    affiliateId: affiliateId,
    timestamp: new Date().toISOString()
  });
});

// ========== CLICK TRACKING ENDPOINT ==========
app.get("/make-server-cf244566/track-click/:affiliateId", async (c) => {
  try {
    console.log("üéØ CLICK TRACKING ROUTE HIT");
    const affiliateId = c.req.param("affiliateId");
    const url = new URL(c.req.url);
    const subid = url.searchParams.get("subid") || "";
    const subid2 = url.searchParams.get("subid2") || "";
    const subid3 = url.searchParams.get("subid3") || "";
    const subid4 = url.searchParams.get("subid4") || "";
    const subid5 = url.searchParams.get("subid5") || "";
    
    // Get IP address
    const ip = c.req.header("cf-connecting-ip") || 
               c.req.header("x-forwarded-for")?.split(",")[0] || 
               "unknown";
    
    // Get user agent
    const userAgent = c.req.header("user-agent") || "unknown";
    
    // Get referrer
    const referrer = c.req.header("referer") || "direct";
    
    const timestamp = new Date().toISOString();
    const clickId = `click_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    
    // Store click data
    const clickData = {
      clickId,
      affiliateId,
      subid,
      subid2,
      subid3,
      subid4,
      subid5,
      ip,
      userAgent,
      referrer,
      timestamp,
      converted: false,
    };
    
    // Save individual click
    await kv.set(`click:${clickId}`, clickData);
    
    // Add to affiliate's click list
    const affiliateClicks: string[] = (await kv.get(`affiliate:${affiliateId}:clicks`) as string[]) || [];
    affiliateClicks.unshift(clickId);
    // Keep last 10,000 clicks
    if (affiliateClicks.length > 10000) {
      affiliateClicks.splice(10000);
    }
    await kv.set(`affiliate:${affiliateId}:clicks`, affiliateClicks);
    
    // Track daily stats
    const today = new Date().toISOString().split("T")[0];
    const dailyKey = `clicks:daily:${affiliateId}:${today}`;
    const dailyStats: any = (await kv.get(dailyKey)) || {
      date: today,
      affiliateId,
      rawClicks: 0,
      uniqueClicks: 0,
      uniqueIps: [],
      subidBreakdown: {},
    };
    
    dailyStats.rawClicks++;
    
    // Track unique clicks (by IP per day)
    if (!dailyStats.uniqueIps) dailyStats.uniqueIps = [];
    if (!Array.isArray(dailyStats.uniqueIps)) {
      dailyStats.uniqueIps = Object.values(dailyStats.uniqueIps);
    }
    
    const uniqueIpsSet = new Set(dailyStats.uniqueIps);
    uniqueIpsSet.add(ip);
    dailyStats.uniqueIps = Array.from(uniqueIpsSet);
    dailyStats.uniqueClicks = dailyStats.uniqueIps.length;
    
    // Track by subid
    if (subid) {
      if (!dailyStats.subidBreakdown) dailyStats.subidBreakdown = {};
      if (!dailyStats.subidBreakdown[subid]) {
        dailyStats.subidBreakdown[subid] = { rawClicks: 0, uniqueClicks: 0, uniqueIps: [] };
      }
      dailyStats.subidBreakdown[subid].rawClicks++;
      if (!dailyStats.subidBreakdown[subid].uniqueIps) {
        dailyStats.subidBreakdown[subid].uniqueIps = [];
      }
      if (!Array.isArray(dailyStats.subidBreakdown[subid].uniqueIps)) {
        dailyStats.subidBreakdown[subid].uniqueIps = Object.values(dailyStats.subidBreakdown[subid].uniqueIps);
      }
      
      const subUniqueIpsSet = new Set(dailyStats.subidBreakdown[subid].uniqueIps);
      subUniqueIpsSet.add(ip);
      dailyStats.subidBreakdown[subid].uniqueIps = Array.from(subUniqueIpsSet);
      dailyStats.subidBreakdown[subid].uniqueClicks = dailyStats.subidBreakdown[subid].uniqueIps.length;
    }
    
    await kv.set(dailyKey, dailyStats);
    
    // Store in session for conversion tracking
    const sessionId = `session_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    await kv.set(`session:${sessionId}`, {
      clickId,
      affiliateId,
      subid,
      subid2,
      subid3,
      subid4,
      subid5,
      timestamp,
    });
    
    console.log(`‚úÖ Click tracked: ${clickId} for affiliate ${affiliateId}${subid ? ` (subid: ${subid})` : ""}`);
    
    return c.json({ 
      success: true, 
      sessionId,
      clickId,
    });
  } catch (error: any) {
    console.error("Error tracking click:", error);
    return c.json({ error: "Failed to track click" }, 500);
  }
});

// ========== SOCIAL MEDIA META TAGS ENDPOINT ==========
// This endpoint serves HTML with proper meta tags for social media crawlers
app.get("/make-server-cf244566/meta-preview", (c) => {
  const html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Santa's Official Letter - Personalized Letters from Santa</title>
  
  <!-- Primary Meta Tags -->
  <meta name="title" content="Santa's Official Letter - Personalized Letters from Santa">
  <meta name="description" content="Get a personalized letter from Santa sent directly to your child! Choose from Silver, Gold, or Platinum packages with authentic North Pole postmark. Order now for Christmas magic!">
  
  <!-- Open Graph / Facebook / Telegram -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://www.santascertifiedletter.com/">
  <meta property="og:title" content="Santa's Official Letter - Personalized Letters from Santa">
  <meta property="og:description" content="Get a personalized letter from Santa sent directly to your child! Choose from Silver, Gold, or Platinum packages with authentic North Pole postmark. Order now for Christmas magic!">
  <meta property="og:image" content="https://images.unsplash.com/photo-1607448496717-ba99a17d3ac3?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3Nzg4Nzd8MHwxfHNlYXJjaHwxfHxzYW50YSUyMGxldHRlciUyMGNocmlzdG1hcyUyMGNoaWxkfGVufDF8fHx8MTc2MDY1NTc0OXww&ixlib=rb-4.1.0&q=80&w=1080">
  <meta property="og:image:width" content="1080">
  <meta property="og:image:height" content="720">
  <meta property="og:site_name" content="Santa's Official Letter">
  
  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://www.santascertifiedletter.com/">
  <meta property="twitter:title" content="Santa's Official Letter - Personalized Letters from Santa">
  <meta property="twitter:description" content="Get a personalized letter from Santa sent directly to your child! Choose from Silver, Gold, or Platinum packages with authentic North Pole postmark. Order now for Christmas magic!">
  <meta property="twitter:image" content="https://images.unsplash.com/photo-1607448496717-ba99a17d3ac3?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3Nzg4Nzd8MHwxfHNlYXJjaHwxfHxzYW50YSUyMGxldHRlciUyMGNocmlzdG1hcyUyMGNoaWxkfGVufDF8fHx8MTc2MDY1NTc0OXww&ixlib=rb-4.1.0&q=80&w=1080">
  
  <!-- Redirect to main site after a moment (for crawlers that execute JS) -->
  <meta http-equiv="refresh" content="0;url=https://www.santascertifiedletter.com/">
</head>
<body>
  <h1>Santa's Official Letter</h1>
  <p>Redirecting to main site...</p>
  <script>
    window.location.href = 'https://www.santascertifiedletter.com/';
  </script>
</body>
</html>`;

  return c.html(html);
});

// ========== ADMIN AUTHENTICATION ENDPOINTS ==========

// Import crypto for 2FA
import * as crypto from "node:crypto";

// Generate TOTP code
function generateTOTP(secret: string): string {
  const epoch = Math.floor(Date.now() / 1000);
  const timeCounter = Math.floor(epoch / 30);
  
  const buffer = new ArrayBuffer(8);
  const view = new DataView(buffer);
  view.setBigUint64(0, BigInt(timeCounter), false);
  
  const key = base32Decode(secret);
  const hmac = crypto.createHmac("sha1", key);
  hmac.update(new Uint8Array(buffer));
  const digest = hmac.digest();
  
  const offset = digest[19] & 0xf;
  const code = (
    ((digest[offset] & 0x7f) << 24) |
    ((digest[offset + 1] & 0xff) << 16) |
    ((digest[offset + 2] & 0xff) << 8) |
    (digest[offset + 3] & 0xff)
  );
  
  return (code % 1000000).toString().padStart(6, "0");
}

// Base32 decode for TOTP secret
function base32Decode(input: string): Uint8Array {
  const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
  const cleanInput = input.toUpperCase().replace(/=+$/, "");
  const bits: number[] = [];
  
  for (let i = 0; i < cleanInput.length; i++) {
    const val = alphabet.indexOf(cleanInput[i]);
    if (val === -1) throw new Error("Invalid base32 character");
    bits.push(...val.toString(2).padStart(5, "0").split("").map(Number));
  }
  
  const bytes: number[] = [];
  for (let i = 0; i + 8 <= bits.length; i += 8) {
    bytes.push(parseInt(bits.slice(i, i + 8).join(""), 2));
  }
  
  return new Uint8Array(bytes);
}

// Generate base32 secret
function generateBase32Secret(): string {
  const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
  const bytes = crypto.randomBytes(20);
  let result = "";
  
  for (let i = 0; i < bytes.length; i += 5) {
    const chunk = bytes.slice(i, i + 5);
    let buffer = 0n;
    for (let j = 0; j < chunk.length; j++) {
      buffer = (buffer << 8n) | BigInt(chunk[j]);
    }
    
    const numBits = chunk.length * 8;
    const numChars = Math.ceil(numBits / 5);
    
    for (let j = numChars - 1; j >= 0; j--) {
      const index = Number((buffer >> BigInt(j * 5)) & 0x1fn);
      result += alphabet[index];
    }
  }
  
  return result;
}

// Verify TOTP code
function verifyTOTP(secret: string, code: string): boolean {
  // Check current window and ¬±1 window (90 seconds total)
  const currentCode = generateTOTP(secret);
  
  if (code === currentCode) return true;
  
  // Check previous 30-second window
  const pastEpoch = Math.floor((Date.now() - 30000) / 1000);
  const pastCounter = Math.floor(pastEpoch / 30);
  const pastBuffer = new ArrayBuffer(8);
  const pastView = new DataView(pastBuffer);
  pastView.setBigUint64(0, BigInt(pastCounter), false);
  
  const key = base32Decode(secret);
  const pastHmac = crypto.createHmac("sha1", key);
  pastHmac.update(new Uint8Array(pastBuffer));
  const pastDigest = pastHmac.digest();
  const pastOffset = pastDigest[19] & 0xf;
  const pastCode = (
    ((pastDigest[pastOffset] & 0x7f) << 24) |
    ((pastDigest[pastOffset + 1] & 0xff) << 16) |
    ((pastDigest[pastOffset + 2] & 0xff) << 8) |
    (pastDigest[pastOffset + 3] & 0xff)
  );
  const pastCodeStr = (pastCode % 1000000).toString().padStart(6, "0");
  
  if (code === pastCodeStr) return true;
  
  // Check next 30-second window
  const futureEpoch = Math.floor((Date.now() + 30000) / 1000);
  const futureCounter = Math.floor(futureEpoch / 30);
  const futureBuffer = new ArrayBuffer(8);
  const futureView = new DataView(futureBuffer);
  futureView.setBigUint64(0, BigInt(futureCounter), false);
  
  const futureHmac = crypto.createHmac("sha1", key);
  futureHmac.update(new Uint8Array(futureBuffer));
  const futureDigest = futureHmac.digest();
  const futureOffset = futureDigest[19] & 0xf;
  const futureCode = (
    ((futureDigest[futureOffset] & 0x7f) << 24) |
    ((futureDigest[futureOffset + 1] & 0xff) << 16) |
    ((futureDigest[futureOffset + 2] & 0xff) << 8) |
    (futureDigest[futureOffset + 3] & 0xff)
  );
  const futureCodeStr = (futureCode % 1000000).toString().padStart(6, "0");
  
  return code === futureCodeStr;
}

// Check if 2FA is set up
app.get("/make-server-cf244566/admin/check-2fa-setup", async (c) => {
  try {
    const secret = await kv.get("admin:2fa_secret");
    return c.json({ setupRequired: !secret });
  } catch (error: any) {
    console.error("Error checking 2FA setup:", error);
    return c.json({ error: "Failed to check 2FA setup" }, 500);
  }
});

// Verify admin password
app.post("/make-server-cf244566/admin/verify-password", async (c) => {
  try {
    const body = await c.req.json();
    const { password } = body;
    
    const adminPassword = Deno.env.get("ADMIN_PASSWORD");
    
    if (!adminPassword) {
      return c.json({ error: "Admin password not configured" }, 500);
    }
    
    if (password !== adminPassword) {
      return c.json({ error: "Invalid password" }, 401);
    }
    
    // Check if 2FA is set up
    const secret2FA = await kv.get("admin:2fa_secret");
    
    if (!secret2FA) {
      // Generate new secret and QR code
      const newSecret = generateBase32Secret();
      const issuer = "Santa's Certified Letter";
      const accountName = "Admin";
      const otpauthUrl = `otpauth://totp/${encodeURIComponent(issuer)}:${encodeURIComponent(accountName)}?secret=${newSecret}&issuer=${encodeURIComponent(issuer)}`;
      
      // Generate QR code using a data URL
      const qrCode = await generateQRCode(otpauthUrl);
      
      return c.json({
        success: true,
        requires2FASetup: true,
        secret: newSecret,
        qrCode,
      });
    }
    
    return c.json({
      success: true,
      requires2FASetup: false,
    });
  } catch (error: any) {
    console.error("Error verifying password:", error);
    return c.json({ error: "Failed to verify password" }, 500);
  }
});

// Generate QR Code
async function generateQRCode(text: string): Promise<string> {
  // Use qrcode npm package
  const QRCode = (await import("npm:qrcode@1.5.3")).default;
  return await QRCode.toDataURL(text);
}

// Set up 2FA
app.post("/make-server-cf244566/admin/setup-2fa", async (c) => {
  try {
    const body = await c.req.json();
    const { password, code, secret } = body;
    
    const adminPassword = Deno.env.get("ADMIN_PASSWORD");
    
    if (!adminPassword || password !== adminPassword) {
      return c.json({ error: "Invalid password" }, 401);
    }
    
    // Verify the code
    if (!verifyTOTP(secret, code)) {
      return c.json({ error: "Invalid authentication code" }, 401);
    }
    
    // Save the secret
    await kv.set("admin:2fa_secret", secret);
    
    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error setting up 2FA:", error);
    return c.json({ error: "Failed to set up 2FA" }, 500);
  }
});

// Verify 2FA code
app.post("/make-server-cf244566/admin/verify-2fa", async (c) => {
  try {
    const body = await c.req.json();
    const { password, code } = body;
    
    const adminPassword = Deno.env.get("ADMIN_PASSWORD");
    
    if (!adminPassword || password !== adminPassword) {
      return c.json({ error: "Invalid password" }, 401);
    }
    
    const secret = await kv.get("admin:2fa_secret");
    
    if (!secret) {
      return c.json({ error: "2FA not set up" }, 400);
    }
    
    if (!verifyTOTP(secret as string, code)) {
      return c.json({ error: "Invalid authentication code" }, 401);
    }
    
    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error verifying 2FA:", error);
    return c.json({ error: "Failed to verify 2FA" }, 500);
  }
});

// Create Payment Intent (for embedded checkout)
app.post("/make-server-cf244566/create-payment-intent", async (c) => {
  if (!stripe) {
    console.log("Stripe not initialized");
    return c.json({ error: "Stripe not configured" }, 503);
  }

  try {
    const body = await c.req.json();
    const { 
      letterPackages, 
      billingData, 
      monthlySubscription,
      total
    } = body;

    console.log("Creating payment intent for", letterPackages.length, "packages");

    // Calculate total amount in cents
    const amountInCents = Math.round(total * 100);

    // Validate email
    const email = billingData.email?.trim();
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    const isValidEmail = email && emailRegex.test(email);

    if (!isValidEmail) {
      console.error("Invalid email address:", email);
      return c.json({ error: "Invalid email address" }, 400);
    }

    // ALWAYS create customer (required for upsells and future charges)
    let customerId = null;
    if (stripe) {
      try {
        console.log("üë§ Creating Stripe customer...");
        const customer = await stripe.customers.create({
          email: billingData.email,
          name: `${billingData.firstName} ${billingData.lastName}`,
          phone: billingData.phone || "",
          metadata: {
            monthlySubscription: monthlySubscription.toString(),
          },
        });
        customerId = customer.id;
        console.log("‚úÖ Created Stripe customer:", customerId);
      } catch (error) {
        console.error("‚ùå Error creating customer:", error);
        // FAIL the request if customer creation fails (needed for upsells)
        return c.json({ 
          error: "Failed to create customer. Please try again.",
          details: error instanceof Error ? error.message : String(error)
        }, 500);
      }
    }

    // Create Payment Intent
    console.log("üîß METADATA FIX VERSION 4 - Ultra minimal metadata");
    const paymentIntentData: any = {
      amount: amountInCents,
      currency: 'usd',
      automatic_payment_methods: {
        enabled: true,
      },
      description: `Letters From Santa (${letterPackages.length} ${letterPackages.length === 1 ? 'letter' : 'letters'})`,
      metadata: {
        // Ultra minimal - only tracking info (full data in database)
        count: letterPackages.length.toString(),
      },
    };

    // Attach payment intent to customer (should always exist now)
    if (customerId) {
      paymentIntentData.customer = customerId;
      paymentIntentData.setup_future_usage = 'off_session'; // Save payment method for upsells
      console.log("üîó Attaching customer to PaymentIntent:", customerId);
    } else {
      console.error("‚ö†Ô∏è No customer ID - this should not happen!");
    }

    // Only add receipt_email if we have a valid email
    if (isValidEmail) {
      paymentIntentData.receipt_email = email;
    }

    const paymentIntent = await stripe.paymentIntents.create(paymentIntentData);

    console.log("‚úÖ Payment intent created:", paymentIntent.id);
    console.log("   Customer attached:", paymentIntent.customer || "NONE");
    console.log("   Setup future usage:", paymentIntent.setup_future_usage || "NONE");

    return c.json({ clientSecret: paymentIntent.client_secret });
  } catch (error: any) {
    console.error('Payment intent creation error:', error);
    return c.json({ 
      error: error.message || 'Failed to create payment intent' 
    }, 500);
  }
});

// Confirm Payment and Save Order (for embedded checkout)
app.post("/make-server-cf244566/confirm-payment", async (c) => {
  if (!stripe) {
    console.log("Stripe not initialized");
    return c.json({ error: "Stripe not configured" }, 503);
  }

  try {
    const body = await c.req.json();
    const { 
      paymentIntentId,
      letterPackages, 
      billingData, 
      monthlySubscription,
      total,
      affiliateId,
      subIds,
      affiliateRef,
      affiliateCampaign,
      customPrice
    } = body;

    console.log("Confirming payment and saving order for payment intent:", paymentIntentId);

    // Retrieve the payment intent to verify it succeeded
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);

    if (paymentIntent.status !== 'succeeded') {
      console.error("Payment intent not successful:", paymentIntent.status);
      
      // Log declined payment for admin tracking
      try {
        const declineId = `decline_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const declineData = {
          declineId,
          timestamp: new Date().toISOString(),
          paymentIntentId,
          status: paymentIntent.status,
          declineReason: paymentIntent.last_payment_error?.message || 'Unknown reason',
          declineCode: paymentIntent.last_payment_error?.code || 'unknown',
          amount: total,
          customerInfo: {
            name: `${billingData.firstName || ''} ${billingData.lastName || ''}`,
            email: billingData.email || '',
            phone: billingData.phone || '',
          },
          letterPackages: letterPackages,
          numberOfPackages: letterPackages?.length || 0,
          affiliateId: affiliateId || null,
          subIds: subIds || null,
          affiliateRef: affiliateRef || null,
          affiliateCampaign: affiliateCampaign || null,
        };
        
        await kv.set(`decline:${declineId}`, declineData);
        console.log("üí≥‚ùå Declined payment logged:", declineId);
      } catch (logError) {
        console.error("Error logging declined payment:", logError);
      }
      
      return c.json({ 
        error: 'Payment not completed',
        reason: paymentIntent.last_payment_error?.message || 'Payment was not successful'
      }, 400);
    }

    // Create subscription in Stripe if requested
    let createdSubscriptionId = null;
    if (monthlySubscription && stripe) {
      try {
        console.log("üìÖ Creating monthly subscription in Stripe...");
        
        // Calculate trial period until January 5th, 2026
        const now = new Date();
        const januaryFifth2026 = new Date('2026-01-05T00:00:00Z');
        const trialEndTimestamp = Math.floor(januaryFifth2026.getTime() / 1000);

        // Get customer from payment intent
        const customerId = paymentIntent.customer as string;
        
        if (!customerId) {
          console.error("‚ùå No customer attached to payment intent. Subscription cannot be created.");
          console.error("‚ùå This likely means the payment intent was created before the subscription checkbox was selected.");
          console.error("‚ùå Payment Intent ID:", paymentIntent.id);
          console.error("‚ùå Payment Intent Metadata:", paymentIntent.metadata);
          throw new Error("Customer required for subscription. Please refresh the page and try again.");
        }

        // Get the payment method from the payment intent
        const paymentMethodId = paymentIntent.payment_method as string;
        
        if (!paymentMethodId) {
          console.error("‚ùå No payment method found on payment intent.");
          throw new Error("Payment method required for subscription");
        }

        console.log("‚úÖ Using customer:", customerId);
        console.log("‚úÖ Using payment method:", paymentMethodId);

        // Attach payment method to customer if not already attached
        try {
          await stripe.paymentMethods.attach(paymentMethodId, {
            customer: customerId,
          });
          console.log("‚úÖ Payment method attached to customer");
        } catch (attachError: any) {
          // If already attached, that's fine
          if (attachError.code === 'resource_already_exists' || attachError.message?.includes('already been attached')) {
            console.log("‚úÖ Payment method already attached to customer");
          } else {
            console.error("‚ùå Error attaching payment method:", attachError);
            throw attachError;
          }
        }

        // Set as default payment method
        await stripe.customers.update(customerId, {
          invoice_settings: {
            default_payment_method: paymentMethodId,
          },
        });
        console.log("‚úÖ Set as default payment method");

        // Get or create product
        const productId = await getOrCreateSubscriptionProduct(stripe);
        
        // Calculate quantity based on number of letter packages (children)
        const subscriptionQuantity = letterPackages.length;
        
        // Create subscription with trial period
        // Each child gets their own monthly letter for $12/month
        const subscription = await stripe.subscriptions.create({
          customer: customerId,
          items: [{
            price_data: {
              currency: 'usd',
              product: productId,
              unit_amount: 1200, // $12.00 per child in cents
              recurring: {
                interval: 'month',
              },
            },
            quantity: subscriptionQuantity, // Number of children
          }],
          trial_end: trialEndTimestamp,
          default_payment_method: paymentMethodId,
          metadata: {
            orderId: `order_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            affiliateId: affiliateId || "",
            numberOfChildren: subscriptionQuantity.toString(),
          },
        });

        createdSubscriptionId = subscription.id;
        console.log("‚úÖ Subscription created in Stripe:", createdSubscriptionId);
        console.log(`   Trial period until: ${januaryFifth2026.toLocaleDateString()}`);
        console.log(`   Monthly charge after trial: ${(12.00 * subscriptionQuantity).toFixed(2)} (${subscriptionQuantity} ${subscriptionQuantity === 1 ? 'child' : 'children'} √ó $12.00)`);
      } catch (error) {
        console.error("‚ùå Error creating subscription:", error);
        // Don't fail the order if subscription creation fails
        // Just log it and continue
      }
    }

    // Capture IP address and card details
    const ipAddress = c.req.header('x-forwarded-for') || c.req.header('x-real-ip') || 'unknown';
    
    // Get card details from payment method
    let lastFourCard = null;
    let trafficSource = 'direct'; // default
    
    try {
      if (stripe && paymentIntent.payment_method) {
        const paymentMethod = await stripe.paymentMethods.retrieve(paymentIntent.payment_method as string);
        lastFourCard = paymentMethod.card?.last4 || null;
      }
    } catch (error) {
      console.error('Error retrieving payment method:', error);
    }
    
    // Determine traffic source
    if (affiliateId) {
      trafficSource = 'affiliate';
    } else {
      const referer = c.req.header('referer') || '';
      if (referer.includes('google') || referer.includes('bing')) {
        trafficSource = 'organic';
      } else if (referer.includes('facebook') || referer.includes('instagram') || referer.includes('ads')) {
        trafficSource = 'paid';
      }
    }

    // Save order to database
    const orderId = `order_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const orderDate = new Date().toISOString();
    
    // Generate secure access token (64 character random string)
    const accessToken = `oat_${Array.from(crypto.getRandomValues(new Uint8Array(32)))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('')}`;

    // Create activity log
    let activityDetails = `Payment processed successfully. Amount: ${total.toFixed(2)}`;
    if (customPrice) {
      activityDetails += ` (Custom affiliate price: ${customPrice.toFixed(2)})`;
    }
    if (affiliateRef) {
      activityDetails += ` - Affiliate Ref: ${affiliateRef}`;
    }
    if (affiliateCampaign) {
      activityDetails += ` / Campaign: ${affiliateCampaign}`;
    }
    
    const activityLog = [
      {
        timestamp: orderDate,
        action: 'Order Created',
        details: activityDetails,
        user: 'Customer',
        stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntentId}`
      }
    ];

    // Set status to "unfulfilled" only when payment is fully paid (total > 0)
    // If total is $0 (trial subscription), set to "pending"
    const orderStatus = total > 0 ? 'unfulfilled' : 'pending';
    
    const orderData = {
      orderId,
      orderDate,
      accessToken, // Store token with order
      stripePaymentId: paymentIntentId,
      stripeCheckoutUrl: paymentIntentId.startsWith('pi_test') 
        ? `https://dashboard.stripe.com/test/payments/${paymentIntentId}`
        : `https://dashboard.stripe.com/payments/${paymentIntentId}`,
      status: orderStatus,
      total: total,
      customerInfo: {
        name: `${billingData.firstName} ${billingData.lastName}`,
        email: billingData.email,
        phone: billingData.phone || "",
        address: {
          line1: billingData.address,
          line2: "",
          city: billingData.city,
          state: billingData.state,
          postal_code: billingData.zip,
          country: "US"
        }
      },
      letterPackages: letterPackages,
      numberOfPackages: letterPackages.length,
      shippingDate: billingData.shippingDate || "",
      monthlySubscription: monthlySubscription,
      subscriptionId: createdSubscriptionId,
      subscriptionQuantity: createdSubscriptionId ? letterPackages.length : undefined, // Number of letters in subscription
      subscriptionPrice: createdSubscriptionId ? (letterPackages.length * 12) : undefined, // Total monthly price ($12 per letter)
      subscriptionLetters: createdSubscriptionId ? letterPackages : undefined, // Store letter details for subscription management
      stripeCustomerId: paymentIntent.customer as string || null,
      stripePaymentMethodId: paymentIntent.payment_method as string || null, // Save payment method for upsells
      subscriptionMonthsActive: createdSubscriptionId ? 0 : undefined,
      subscriptionStartDate: createdSubscriptionId ? orderDate : undefined,
      subscriptionNextBillingDate: createdSubscriptionId ? '2026-01-05' : undefined,
      billingIntervalDays: createdSubscriptionId ? 30 : undefined, // Default 30 days between charges
      affiliateId: affiliateId || null,
      affiliateName: null, // Will be populated if needed
      affiliateCommission: affiliateId ? total * 0.10 : null,
      subIds: subIds || null,
      affiliateRef: affiliateRef || null, // Save affiliate link ref parameter
      affiliateCampaign: affiliateCampaign || null, // Save affiliate campaign parameter
      customPrice: customPrice || null, // Save custom price if it was applied
      ipAddress: ipAddress,
      lastFourCard: lastFourCard,
      trafficSource: trafficSource,
      activityLog: activityLog,
      archived: false,
      createdAt: orderDate,
      updatedAt: orderDate
    };

    await kv.set(`order:${orderId}`, orderData);
    
    // Add to orders list for admin dashboard
    const allOrderIds = (await kv.get("orders:all")) || [];
    allOrderIds.push(orderId);
    await kv.set("orders:all", allOrderIds);
    
    // Store token -> orderId mapping for quick lookup
    await kv.set(`token:${accessToken}`, orderId);
    console.log("‚úÖ Order saved to database:", orderId);
    console.log("üîê Secure access token generated:", accessToken.substring(0, 20) + "...");

    // Track affiliate conversion if applicable
    if (affiliateId) {
      try {
        const conversionData = {
          affiliateId,
          orderId,
          orderDate,
          amount: total,
          commission: total * 0.10, // 10% commission
          status: 'pending',
          subIds: subIds || {}
        };
        
        await kv.set(`conversion:${orderId}`, conversionData);
        console.log("‚úÖ Affiliate conversion tracked:", affiliateId);
      } catch (error) {
        console.error("Error tracking affiliate conversion:", error);
      }
    }

    // Send notifications
    try {
      // Send customer confirmation email
      const resendApiKey = Deno.env.get("RESEND_API_KEY");
      if (resendApiKey && billingData.email) {
        const packageDetails = letterPackages.map((pkg: any, idx: number) => `
          <div style="background: #fef2f2; border: 2px solid #fecaca; border-radius: 8px; padding: 15px; margin: 15px 0;">
            <p><strong>üì¶ Package ${idx + 1}</strong></p>
            <p><strong>Child:</strong> ${pkg.childFirstName} ${pkg.childLastName}</p>
            <p><strong>Friend:</strong> ${pkg.friendName}</p>
            <p><strong>Shipping to:</strong> ${pkg.streetAddress}${pkg.unitApt ? ', ' + pkg.unitApt : ''}, ${pkg.city}, ${pkg.state} ${pkg.zipCode}</p>
          </div>
        `).join('');

        const emailHtml = `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
          </head>
          <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÖ Letter From Santa</h1>
                <p style="margin: 10px 0 0 0; font-size: 18px;">Order Confirmed!</p>
              </div>
              <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                <p>Dear ${billingData.firstName} ${billingData.lastName},</p>
                
                <p style="font-size: 18px;"><span style="font-size: 24px;">üéâ</span> Thank you for your order! We're excited to help you keep the magic of Christmas alive.</p>
                
                <p><strong>Order Number:</strong> #${orderId.slice(-8)}<br>
                <strong>Order Date:</strong> ${new Date(orderDate).toLocaleDateString()}<br>
                <strong>Total Amount:</strong> ${total.toFixed(2)}</p>
                
                <h3 style="color: #dc2626; margin-top: 30px;">üì¨ Your Letter Packages:</h3>
                ${packageDetails}
                
                <p style="margin-top: 30px;"><strong>What happens next?</strong></p>
                <ul style="line-height: 1.8;">
                  <li>‚ú® We're preparing your personalized letters from Santa</li>
                  <li>üìù Each letter will include a Good Behavior Certificate and Nice List</li>
                  <li>üìÆ Your packages will be mailed on your selected date: ${billingData.shippingDate}</li>
                  <li>üìß You'll receive a shipping notification with tracking</li>
                </ul>
                
                <p style="margin-top: 30px; text-align: center;">
                  <strong>üìã Manage Your Order Anytime:</strong><br>
                  <a href="${c.req.header('origin') || 'http://localhost:5173'}/?token=${accessToken}" 
                     style="display: inline-block; background: #dc2626; color: white; padding: 15px 40px; text-decoration: none; border-radius: 8px; font-weight: bold; margin-top: 15px;">
                    View & Edit Your Order
                  </a>
                </p>
                <p style="text-align: center; color: #6b7280; font-size: 14px; margin-top: 10px;">
                  You can update your order details, check status, and view tracking information using the link above. 
                  Bookmark this page for easy access!
                </p>
                
                <p style="margin-top: 30px; padding: 20px; background: #fef2f2; border-radius: 8px; border-left: 4px solid #dc2626;">
                  <strong>üéÑ Keep the Magic Alive!</strong><br>
                  Make sure to retrieve the mail before your little ones do! üòä
                </p>
              </div>
              <div style="text-align: center; padding: 20px; color: #6b7280; font-size: 12px; background: #f9fafb; border-radius: 0 0 10px 10px;">
                <p>Questions? Contact us - Available 7 Days a Week: 9am to 7pm EST</p>
                <p style="margin-top: 10px; color: #9ca3af;">¬© 2025 Letters From Santa. All rights reserved.</p>
              </div>
            </div>
          </body>
          </html>
        `;

        console.log("üìß Attempting to send confirmation email to:", billingData.email);
        
        const emailResponse = await fetch("https://api.resend.com/emails", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${resendApiKey}`,
          },
          body: JSON.stringify({
            from: EMAIL_FROM,
            to: billingData.email,
            subject: "üéÖ Your Letter From Santa is On The Way!",
            html: emailHtml,
          }),
        });
        
        if (emailResponse.ok) {
          const emailData = await emailResponse.json();
          console.log("‚úÖ Confirmation email sent successfully! Email ID:", emailData.id);
          
          // Log email activity
          await logEmailActivity(
            orderId,
            'order_confirmation',
            billingData.email,
            'Order Confirmation',
            emailData.id
          );
        } else {
          const errorText = await emailResponse.text();
          console.error("‚ùå Failed to send confirmation email. Status:", emailResponse.status);
          console.error("‚ùå Error details:", errorText);
        }
      }

      // Send SMS notification
      const twilioAccountSid = Deno.env.get("TWILIO_ACCOUNT_SID");
      const twilioAuthToken = Deno.env.get("TWILIO_AUTH_TOKEN");
      const twilioPhoneNumber = Deno.env.get("TWILIO_PHONE_NUMBER");
      
      if (twilioAccountSid && twilioAuthToken && twilioPhoneNumber && billingData.phone) {
        const smsBody = `üéÖ Your Letter From Santa order is confirmed! Order #${orderId.slice(-8)}. Check your email for details and your order tracking link.`;
        
        console.log("üì± Attempting to send confirmation SMS to:", billingData.phone);
        
        const smsResponse = await fetch(
          `https://api.twilio.com/2010-04-01/Accounts/${twilioAccountSid}/Messages.json`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/x-www-form-urlencoded",
              "Authorization": "Basic " + btoa(`${twilioAccountSid}:${twilioAuthToken}`),
            },
            body: new URLSearchParams({
              To: billingData.phone,
              From: twilioPhoneNumber,
              Body: smsBody,
            }).toString(),
          }
        );
        
        if (smsResponse.ok) {
          const smsData = await smsResponse.json();
          console.log("‚úÖ Confirmation SMS sent successfully! Message SID:", smsData.sid);
        } else {
          const errorText = await smsResponse.text();
          console.error("‚ùå Failed to send confirmation SMS. Status:", smsResponse.status);
          console.error("‚ùå Error details:", errorText);
        }
      } else {
        console.log("‚ö†Ô∏è SMS notification skipped. Twilio configured:", !!twilioAccountSid, "Phone provided:", !!billingData.phone);
      }
    } catch (error) {
      console.error("Error sending notifications:", error);
      // Don't fail the order if notifications fail
    }

    return c.json({ success: true, orderId, accessToken });
  } catch (error: any) {
    console.error('Payment confirmation error:', error);
    return c.json({ 
      error: error.message || 'Failed to confirm payment' 
    }, 500);
  }
});

// Get all declined payments (for admin dashboard)
app.get("/make-server-cf244566/declined-orders", async (c) => {
  try {
    console.log("üí≥‚ùå Fetching all declined payments...");
    
    // Get all declined payments from KV store
    const declines = await kv.getByPrefix("decline:");
    
    console.log(`‚úÖ Found ${declines.length} declined payments`);
    
    // Sort by timestamp, newest first
    const sortedDeclines = declines.sort((a: any, b: any) => {
      return new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime();
    });
    
    return c.json({ declines: sortedDeclines });
  } catch (error: any) {
    console.error('Error fetching declined payments:', error);
    return c.json({ 
      error: error.message || 'Failed to fetch declined payments' 
    }, 500);
  }
});

// Get a single order by access token (for customer thank you page)
app.get("/make-server-cf244566/order/:identifier", async (c) => {
  try {
    const identifier = c.req.param('identifier');
    console.log("üì¶ Fetching order with identifier:", identifier.substring(0, 20) + "...");
    
    let order: any;
    
    // Check if it's a token (starts with oat_) or legacy orderId (starts with order_)
    if (identifier.startsWith('oat_')) {
      // It's an access token - resolve to orderId first
      const orderId = await kv.get(`token:${identifier}`);
      if (!orderId) {
        return c.json({ error: 'Invalid access token' }, 404);
      }
      order = await kv.get(`order:${orderId}`);
    } else if (identifier.startsWith('order_')) {
      // Legacy support - direct order ID access (for backwards compatibility)
      order = await kv.get(`order:${identifier}`);
    } else {
      return c.json({ error: 'Invalid identifier format' }, 400);
    }
    
    if (!order) {
      return c.json({ error: 'Order not found' }, 404);
    }
    
    // Remove the access token from the response for security
    const { accessToken, ...orderWithoutToken } = order;
    
    console.log("‚úÖ Order found");
    return c.json({ order: orderWithoutToken });
  } catch (error: any) {
    console.error('Error fetching order:', error);
    return c.json({ 
      error: error.message || 'Failed to fetch order' 
    }, 500);
  }
});

// Update order (for customer edits on thank you page)
app.post("/make-server-cf244566/order/:identifier/update", async (c) => {
  try {
    const identifier = c.req.param('identifier');
    const body = await c.req.json();
    const { letterPackages } = body;
    
    console.log("‚úèÔ∏è Updating order with identifier:", identifier.substring(0, 20) + "...");
    
    // Resolve identifier to orderId
    let orderId: string;
    if (identifier.startsWith('oat_')) {
      const resolvedId = await kv.get(`token:${identifier}`);
      if (!resolvedId) {
        return c.json({ error: 'Invalid access token' }, 404);
      }
      orderId = resolvedId as string;
    } else if (identifier.startsWith('order_')) {
      orderId = identifier;
    } else {
      return c.json({ error: 'Invalid identifier format' }, 400);
    }
    
    // Get existing order
    const existingOrder: any = await kv.get(`order:${orderId}`);
    
    if (!existingOrder) {
      return c.json({ error: 'Order not found' }, 404);
    }
    
    // Check if order can be edited (not fulfilled and no tracking)
    if (existingOrder.status === 'fulfilled' || existingOrder.trackingNumber) {
      return c.json({ 
        error: 'Order cannot be edited once fulfilled or shipped' 
      }, 400);
    }
    
    // Update the order with new letter packages
    const updatedOrder = {
      ...existingOrder,
      letterPackages,
      updatedAt: new Date().toISOString(),
    };
    
    await kv.set(`order:${orderId}`, updatedOrder);
    console.log("‚úÖ Order updated:", orderId);
    
    // Create admin alert for order update
    const oldPackageCount = existingOrder.letterPackages?.length || 0;
    const newPackageCount = letterPackages.length;
    const packagesChanged = newPackageCount !== oldPackageCount;
    
    if (packagesChanged) {
      await createAdminAlert(
        "order_updated",
        orderId,
        "üìù Order Modified - Packages Changed",
        {
          totalPackages: newPackageCount,
          packagesAdded: Math.max(0, newPackageCount - oldPackageCount),
          changes: packagesChanged ? [`Packages changed from ${oldPackageCount} to ${newPackageCount}`] : []
        },
        "medium"
      );
    }
    
    // Send update notification email
    try {
      const resendApiKey = Deno.env.get("RESEND_API_KEY");
      if (resendApiKey && existingOrder.customerInfo?.email) {
        // Generate package details HTML
        const packagesHtml = letterPackages.map((pkg: any, idx: number) => `
          <div style="background: #fef2f2; border: 2px solid #fecaca; border-radius: 8px; padding: 15px; margin: 10px 0;">
            <p style="margin: 5px 0;"><strong>üì¶ Package ${idx + 1}</strong></p>
            <p style="margin: 5px 0;"><strong>Child:</strong> ${pkg.childFirstName} ${pkg.childLastName}</p>
            ${pkg.friendName ? `<p style="margin: 5px 0;"><strong>Friend:</strong> ${pkg.friendName}</p>` : ''}
            <p style="margin: 5px 0;"><strong>Shipping to:</strong> ${pkg.streetAddress}${pkg.unitApt ? ', ' + pkg.unitApt : ''}, ${pkg.city}, ${pkg.state} ${pkg.zipCode}</p>
          </div>
        `).join('');
        
        const emailHtml = `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
          </head>
          <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÖ Order Updated!</h1>
              </div>
              <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                <p>Hi ${existingOrder.customerInfo.name || 'there'},</p>
                
                <p style="font-size: 18px; color: #059669;"><strong>‚úÖ Your order has been successfully updated!</strong></p>
                
                <div style="background: #dbeafe; padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #3b82f6;">
                  <p style="margin: 0;"><strong>Order #:</strong> ${orderId.slice(-8)}</p>
                  <p style="margin: 5px 0 0 0;"><strong>Updated:</strong> ${new Date().toLocaleString()}</p>
                </div>
                
                <h3 style="color: #dc2626; margin-top: 30px;">üì¨ Updated Letter Packages:</h3>
                ${packagesHtml}
                
                <p style="margin-top: 30px;"><strong>You can view and manage your order anytime:</strong></p>
                <p style="text-align: center; margin: 20px 0;">
                  <a href="${c.req.header('origin') || 'http://localhost:5173'}/?token=${existingOrder.accessToken}" 
                     style="display: inline-block; background: #dc2626; color: white; padding: 12px 30px; text-decoration: none; border-radius: 8px; font-weight: bold;">
                    View Your Order
                  </a>
                </p>
                
                <div style="background: #fef2f2; padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #dc2626;">
                  <p style="margin: 0;"><strong>üéÑ What's Next?</strong></p>
                  <p style="margin: 5px 0 0 0; font-size: 14px;">Your updated order is being prepared. You'll receive a shipping notification with tracking details soon!</p>
                </div>
                
                <p style="margin-top: 30px;">Questions? Contact us at support@letterfromsanta.com</p>
                
                <p style="margin-top: 30px;">Merry Christmas! ‚ú®<br>The Santa Letters Team</p>
              </div>
              <div style="background: #f9fafb; padding: 20px; text-align: center; color: #6b7280; font-size: 14px; border-radius: 0 0 10px 10px;">
                <p style="margin: 0;">¬© ${new Date().getFullYear()} Letter From Santa. All rights reserved.</p>
              </div>
            </div>
          </body>
          </html>
        `;

        const emailResponse = await fetch("https://api.resend.com/emails", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${resendApiKey}`,
          },
          body: JSON.stringify({
            from: EMAIL_FROM,
            to: existingOrder.customerInfo.email,
            subject: "üéÖ Your Order Has Been Updated",
            html: emailHtml,
          }),
        });
        
        if (emailResponse.ok) {
          const emailData = await emailResponse.json();
          console.log("‚úÖ Update notification email sent. Email ID:", emailData.id);
          
          // Log email activity
          await logEmailActivity(
            orderId,
            'order_update',
            existingOrder.customerInfo.email,
            'Order Update Notification',
            emailData.id
          );
        }
      }
    } catch (emailError) {
      console.error("Error sending update email:", emailError);
      // Don't fail the update if email fails
    }
    
    // Remove access token from response for security
    const { accessToken: _, ...orderWithoutToken } = updatedOrder;
    return c.json({ success: true, order: orderWithoutToken });
  } catch (error: any) {
    console.error('Error updating order:', error);
    return c.json({ 
      error: error.message || 'Failed to update order' 
    }, 500);
  }
});

// Add tracking number and fulfill order
app.post("/make-server-cf244566/orders/:orderId/tracking", async (c) => {
  try {
    const orderId = c.req.param('orderId');
    const body = await c.req.json();
    const { trackingNumber, carrierName } = body;
    
    console.log("üì¶ Adding tracking to order:", orderId);
    
    // Get existing order
    const existingOrder: any = await kv.get(`order:${orderId}`);
    
    if (!existingOrder) {
      return c.json({ error: 'Order not found' }, 404);
    }
    
    // Generate tracking URL based on carrier
    let trackingUrl = '';
    switch (carrierName?.toUpperCase()) {
      case 'USPS':
        trackingUrl = `https://tools.usps.com/go/TrackConfirmAction?tLabels=${trackingNumber}`;
        break;
      case 'UPS':
        trackingUrl = `https://www.ups.com/track?tracknum=${trackingNumber}`;
        break;
      case 'FEDEX':
        trackingUrl = `https://www.fedex.com/fedextrack/?trknbr=${trackingNumber}`;
        break;
      default:
        trackingUrl = '';
    }
    
    // Add activity log entry
    if (!existingOrder.activityLog) existingOrder.activityLog = [];
    existingOrder.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Tracking Number Added',
      details: `Tracking: ${trackingNumber} | Carrier: ${carrierName || 'USPS'} | Order marked as fulfilled`,
      user: 'Admin'
    });
    
    // Update the order with tracking and mark as fulfilled
    const updatedOrder = {
      ...existingOrder,
      trackingNumber,
      carrierName: carrierName || 'USPS',
      trackingUrl,
      status: 'fulfilled',
      activityLog: existingOrder.activityLog,
      updatedAt: new Date().toISOString(),
    };
    
    await kv.set(`order:${orderId}`, updatedOrder);
    console.log("‚úÖ Tracking added and order fulfilled:", orderId);
    
    // Send tracking notification email
    try {
      const resendApiKey = Deno.env.get("RESEND_API_KEY");
      if (resendApiKey && existingOrder.customerInfo?.email) {
        const packageDetails = existingOrder.letterPackages?.map((pkg: any, idx: number) => `
          <div style="background: #fef2f2; border: 2px solid #fecaca; border-radius: 8px; padding: 15px; margin: 15px 0;">
            <p><strong>üì¶ Package ${idx + 1}</strong></p>
            <p><strong>Child:</strong> ${pkg.childFirstName} ${pkg.childLastName}</p>
            <p><strong>Delivering to:</strong> ${pkg.streetAddress}${pkg.unitApt ? ', ' + pkg.unitApt : ''}, ${pkg.city}, ${pkg.state} ${pkg.zipCode}</p>
          </div>
        `).join('') || '';

        const emailHtml = `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
          </head>
          <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÖ Your Package Has Shipped!</h1>
              </div>
              <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                <p>Dear ${existingOrder.customerInfo.name || 'Valued Customer'},</p>
                
                <p style="font-size: 18px; color: #059669;"><strong>üéâ Exciting news! Your Letter From Santa is on its way!</strong></p>
                
                <p><strong>Order Number:</strong> #${orderId.slice(-8)}</p>
                
                <div style="background: #dbeafe; border-left: 4px solid #3b82f6; padding: 15px; margin: 20px 0;">
                  <p style="margin: 0; font-size: 16px;"><strong>üì¶ Tracking Number:</strong></p>
                  <p style="margin: 5px 0 0 0; font-size: 20px; font-weight: bold; color: #1e40af;">${trackingNumber}</p>
                  <p style="margin: 10px 0 0 0; font-size: 14px;"><strong>Carrier:</strong> ${carrierName || 'USPS'}</p>
                </div>
                
                ${trackingUrl ? `
                  <p style="text-align: center; margin: 30px 0;">
                    <a href="${trackingUrl}" 
                       style="display: inline-block; background: #dc2626; color: white; padding: 15px 40px; text-decoration: none; border-radius: 8px; font-weight: bold; font-size: 16px;">
                      üöö Track Your Package
                    </a>
                  </p>
                ` : ''}
                
                <h3 style="color: #dc2626; margin-top: 30px;">Your Letter Packages:</h3>
                ${packageDetails}
                
                <div style="background: #fef3c7; border-left: 4px solid #f59e0b; padding: 15px; margin: 20px 0;">
                  <p style="margin: 0;"><strong>üí° Tip:</strong> Make sure someone is available to receive the package, or check if a signature is required!</p>
                </div>
                
                <p style="margin-top: 30px;"><strong>You can view your order status anytime by visiting:</strong></p>
                <p style="text-align: center; margin: 20px 0;">
                  <a href="${c.req.header('origin') || 'http://localhost:5173'}/?token=${existingOrder.accessToken}" 
                     style="display: inline-block; background: #059669; color: white; padding: 12px 30px; text-decoration: none; border-radius: 8px; font-weight: bold;">
                    View Your Order
                  </a>
                </p>
                
                <p style="margin-top: 30px;">Get ready for the magic! Your child is going to be so excited!</p>
                
                <p style="margin-top: 30px;">Merry Christmas!<br>The Santa Letters Team üéÖüéÑ</p>
              </div>
              <div style="text-align: center; padding: 20px; color: #6b7280; font-size: 12px;">
                <p>Questions? Contact our support team - Available 7 days a week, 9am-7pm EST</p>
              </div>
            </div>
          </body>
          </html>
        `;

        const emailResponse = await fetch("https://api.resend.com/emails", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${resendApiKey}`,
          },
          body: JSON.stringify({
            from: EMAIL_FROM,
            to: existingOrder.customerInfo.email,
            subject: `üéÖ Your Package Has Shipped! Tracking: ${trackingNumber}`,
            html: emailHtml,
          }),
        });
        
        if (emailResponse.ok) {
          const emailData = await emailResponse.json();
          console.log("‚úÖ Tracking notification email sent. Email ID:", emailData.id);
          
          // Add activity log entry for email sent
          updatedOrder.activityLog.push({
            timestamp: new Date().toISOString(),
            action: 'Email Sent - Tracking Notification',
            details: `Tracking notification sent to ${existingOrder.customerInfo.email}. Tracking: ${trackingNumber}`,
            user: 'System',
            emailType: 'tracking_notification',
            emailRecipient: existingOrder.customerInfo.email,
            emailId: emailData.id
          });
          await kv.set(`order:${orderId}`, updatedOrder);
        } else {
          console.error("‚ùå Failed to send tracking email");
        }
      }
    } catch (emailError) {
      console.error("Error sending tracking email:", emailError);
      // Don't fail the update if email fails
    }
    
    // Send SMS notification
    try {
      const twilioAccountSid = Deno.env.get("TWILIO_ACCOUNT_SID");
      const twilioAuthToken = Deno.env.get("TWILIO_AUTH_TOKEN");
      const twilioPhoneNumber = Deno.env.get("TWILIO_PHONE_NUMBER");
      
      if (twilioAccountSid && twilioAuthToken && twilioPhoneNumber && existingOrder.customerInfo?.phone) {
        const smsBody = `üéÖ Your Letter From Santa has shipped! Track it here: ${trackingUrl || 'Check your email for details'}. Order #${orderId.slice(-8)}`;
        
        const smsResponse = await fetch(
          `https://api.twilio.com/2010-04-01/Accounts/${twilioAccountSid}/Messages.json`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/x-www-form-urlencoded",
              "Authorization": "Basic " + btoa(`${twilioAccountSid}:${twilioAuthToken}`),
            },
            body: new URLSearchParams({
              To: existingOrder.customerInfo.phone,
              From: twilioPhoneNumber,
              Body: smsBody,
            }).toString(),
          }
        );
        
        if (smsResponse.ok) {
          console.log("‚úÖ Tracking SMS sent");
          
          // Add activity log entry for SMS sent
          const order: any = await kv.get(`order:${orderId}`);
          if (order && order.activityLog) {
            order.activityLog.push({
              timestamp: new Date().toISOString(),
              action: 'SMS Notification Sent',
              details: `Tracking SMS sent to ${existingOrder.customerInfo.phone}`,
              user: 'System'
            });
            await kv.set(`order:${orderId}`, order);
          }
        } else {
          console.error("‚ùå Failed to send tracking SMS");
        }
      }
    } catch (smsError) {
      console.error("Error sending tracking SMS:", smsError);
      // Don't fail the update if SMS fails
    }
    
    // Remove access token from response for security
    const { accessToken: _, ...orderWithoutToken } = updatedOrder;
    return c.json({ success: true, order: orderWithoutToken });
  } catch (error: any) {
    console.error('Error adding tracking:', error);
    return c.json({ 
      error: error.message || 'Failed to add tracking' 
    }, 500);
  }
});

// Stripe Webhook - Automatically save orders when payment succeeds
app.post("/make-server-cf244566/webhook", async (c) => {
  console.log("========== WEBHOOK CALLED ==========");
  console.log("Timestamp:", new Date().toISOString());
  
  if (!stripe) {
    console.error("‚ùå Stripe not initialized in webhook");
    return c.json({ error: "Stripe not configured" }, 503);
  }

  const sig = c.req.header("stripe-signature");
  const webhookSecret = Deno.env.get("STRIPE_WEBHOOK_SECRET");
  
  console.log("Webhook signature present:", !!sig);
  console.log("Webhook secret configured:", !!webhookSecret);
  console.log("Webhook secret starts with:", webhookSecret?.substring(0, 10) + "...");
  
  if (!sig || !webhookSecret) {
    console.error("‚ùå Missing webhook signature or secret");
    console.error("Signature:", sig ? "present" : "MISSING");
    console.error("Secret:", webhookSecret ? "present" : "MISSING");
    return c.json({ error: "Webhook configuration error" }, 400);
  }

  try {
    const body = await c.req.text();
    console.log("Webhook body length:", body.length);
    
    const event = stripe.webhooks.constructEvent(body, sig, webhookSecret);

    console.log("‚úÖ Webhook signature verified!");
    console.log("Event type:", event.type);
    console.log("Event ID:", event.id);

    // Handle successful payment
    if (event.type === "checkout.session.completed") {
      const session = event.data.object as any;
      
      // Get customer details
      const customerEmail = session.customer_details?.email || session.customer_email;
      const customerName = session.customer_details?.name || "";
      const customerPhone = session.customer_details?.phone || "";
      const customerAddress = session.customer_details?.address || {};

      // Parse metadata
      const metadata = session.metadata || {};
      const letterPackages = metadata.letterPackages ? JSON.parse(metadata.letterPackages) : [];
      const shippingDate = metadata.shippingDate || "";
      const monthlySubscription = metadata.monthlySubscription === "true";
      const numberOfPackages = parseInt(metadata.numberOfPackages || "0");
      const affiliateId = metadata.affiliateId || null;
      const subIds = metadata.subIds ? JSON.parse(metadata.subIds) : {};

      // Calculate affiliate commission (only for initial sales, not subscriptions or repeat customers)
      let affiliateCommission = 0;
      let affiliateName = null;
      let payoutType = null;
      let payoutAmount = 0;

      if (affiliateId && !monthlySubscription) {
        // Check if this is a repeat customer
        const allOrderIds = (await kv.get("orders:all")) || [];
        let isRepeatCustomer = false;
        
        for (const orderId of allOrderIds) {
          const existingOrder: any = await kv.get(`order:${orderId}`);
          if (existingOrder && existingOrder.customerInfo.email === customerEmail) {
            isRepeatCustomer = true;
            break;
          }
        }

        // Only pay commission if this is a new customer
        if (!isRepeatCustomer) {
          // Get affiliate link to determine payout
          const allLinkIds = (await kv.get("links:all")) || [];
          let affiliateLink = null;

          for (const linkId of allLinkIds) {
            const link: any = await kv.get(`link:${linkId}`);
            if (link && link.affiliateId === affiliateId) {
              affiliateLink = link;
              break;
            }
          }

          if (affiliateLink) {
            payoutType = affiliateLink.payoutType;
            payoutAmount = affiliateLink.payoutAmount;

            if (payoutType === "percentage") {
              affiliateCommission = (session.amount_total / 100) * (payoutAmount / 100);
            } else if (payoutType === "cpa") {
              affiliateCommission = payoutAmount;
            }
          }

          // Get affiliate name
          const affiliate: any = await kv.get(`affiliate:${affiliateId}`);
          if (affiliate) {
            affiliateName = affiliate.affiliateName;
          }
        }
      }

      // If subscription is requested, create it in Stripe
      let createdSubscriptionId = null;
      if (monthlySubscription && stripe) {
        try {
          // Calculate trial days until January 1st, 2026
          const now = new Date();
          const januaryFirst2026 = new Date('2026-01-01T00:00:00Z');
          const trialDays = Math.ceil((januaryFirst2026.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));

          // Get or create customer
          let customerId = session.customer as string;
          if (!customerId) {
            const customer = await stripe.customers.create({
              email: customerEmail,
              name: customerName,
              phone: customerPhone,
            });
            customerId = customer.id;
          }

          // Get or create product
          const productId = await getOrCreateSubscriptionProduct(stripe);
          
          // Create subscription with trial period
          const subscription = await stripe.subscriptions.create({
            customer: customerId,
            items: [{
              price_data: {
                currency: 'usd',
                product: productId,
                unit_amount: 1200, // $12.00 in cents
                recurring: {
                  interval: 'month',
                },
              },
            }],
            trial_end: Math.floor(januaryFirst2026.getTime() / 1000),
            metadata: {
              orderId: session.id,
              affiliateId: affiliateId || "",
            },
          });

          createdSubscriptionId = subscription.id;
          console.log("Subscription created:", createdSubscriptionId);
        } catch (error) {
          console.error("Error creating subscription:", error);
          // Don't fail the order if subscription creation fails
        }
      }

      // Create order object
      console.log("üì¶ Creating order object for session:", session.id);
      console.log("Customer email:", customerEmail);
      console.log("Number of packages:", numberOfPackages);
      console.log("Letter packages:", JSON.stringify(letterPackages));
      
      // Get customer ID from session
      const stripeCustomerId = session.customer as string;
      console.log("üí≥ Stripe Customer ID:", stripeCustomerId);
      
      // Generate secure access token for order tracking (64 character random string)
      const accessToken = `oat_${Array.from(crypto.getRandomValues(new Uint8Array(32)))
        .map(b => b.toString(16).padStart(2, '0'))
        .join('')}`;
      
      const order = {
        orderId: session.id,
        sessionId: session.id,
        accessToken, // Add access token for customer order lookup
        stripePaymentId: session.payment_intent,
        stripeCustomerId: stripeCustomerId, // CRITICAL: Save customer ID for future payments
        stripePaymentMethodId: null, // Will be populated from payment intent if needed
        stripeCheckoutUrl: `https://dashboard.stripe.com/test/payments/${session.payment_intent}`,
        orderDate: new Date().toISOString(),
        status: "pending", // pending, fulfilled, cancelled
        total: session.amount_total ? session.amount_total / 100 : 0, // Convert from cents
        customerInfo: {
          email: customerEmail,
          name: customerName,
          phone: customerPhone,
          address: {
            line1: customerAddress.line1 || "",
            line2: customerAddress.line2 || "",
            city: customerAddress.city || "",
            state: customerAddress.state || "",
            postal_code: customerAddress.postal_code || "",
            country: customerAddress.country || "US",
          },
        },
        letterPackages,
        numberOfPackages,
        shippingDate,
        monthlySubscription,
        subscriptionId: createdSubscriptionId || session.subscription || null,
        // Subscription fields
        subscriptionProductName: monthlySubscription ? "Santa's Magical Journey" : undefined,
        subscriptionPrice: monthlySubscription ? 12.00 : undefined,
        billingIntervalDays: monthlySubscription ? 30 : undefined,
        successfulCharges: monthlySubscription ? 0 : undefined,
        declinedCharges: monthlySubscription ? 0 : undefined,
        subscriptionMonthsActive: monthlySubscription ? 0 : undefined,
        subscriptionStartDate: monthlySubscription ? new Date().toISOString() : undefined,
        affiliateId: affiliateId || undefined,
        affiliateName: affiliateName || undefined,
        affiliateCommission,
        subIds: Object.keys(subIds).length > 0 ? subIds : undefined,
        activityLog: [{
          timestamp: new Date().toISOString(),
          action: 'Order Created',
          details: `${monthlySubscription ? 'Subscription order created. Initial payment: $0.00. Recurring billing will start in 30 days at $12/month.' : `One-time order created. Total: ${session.amount_total ? (session.amount_total / 100).toFixed(2) : '0.00'}`}`,
          user: 'Stripe Checkout',
          stripeUrl: session.payment_intent 
            ? `https://dashboard.stripe.com/${session.payment_intent.toString().startsWith('pi_test') ? 'test' : 'live'}/payments/${session.payment_intent}`
            : `https://dashboard.stripe.com/${session.id.startsWith('cs_test') ? 'test' : 'live'}/checkout/sessions/${session.id}`
        }]
      };

      console.log("üíæ Saving order to database...");
      
      // Try to get payment method from payment intent for future use
      if (stripe && session.payment_intent && stripeCustomerId) {
        try {
          const paymentIntent = await stripe.paymentIntents.retrieve(session.payment_intent as string);
          if (paymentIntent.payment_method) {
            order.stripePaymentMethodId = paymentIntent.payment_method as string;
            console.log("üí≥ Payment method ID saved:", order.stripePaymentMethodId);
          }
        } catch (pmError) {
          console.warn("‚ö†Ô∏è Could not retrieve payment method:", pmError);
          // Don't fail order if we can't get payment method
        }
      }
      
      try {
        // Save order to database
        await kv.set(`order:${session.id}`, order);
        console.log("‚úÖ Order saved to KV store with customer ID:", stripeCustomerId);
        
        // Add to orders index
        const allOrderIds = (await kv.get("orders:all")) || [];
        console.log("Current order count:", allOrderIds.length);
        allOrderIds.push(session.id);
        await kv.set("orders:all", allOrderIds);
        console.log("‚úÖ Order added to index. New count:", allOrderIds.length);
        
        // Store token -> orderId mapping for quick lookup
        await kv.set(`token:${accessToken}`, session.id);
        console.log("üîê Secure access token mapping created");

        console.log("üéâ Order saved successfully:", session.id);
        
        // Check if this is a repeat customer and create alert
        const existingOrders = allOrderIds.filter((id: string) => id !== session.id);
        let isRepeatCustomer = false;
        let previousOrderId = null;
        
        for (const existingId of existingOrders) {
          const existingOrder: any = await kv.get(`order:${existingId}`);
          if (existingOrder && existingOrder.customerInfo?.email === customerEmail) {
            isRepeatCustomer = true;
            previousOrderId = existingId;
            break;
          }
        }
        
        if (isRepeatCustomer && previousOrderId) {
          await createAdminAlert(
            "new_order_from_existing",
            session.id,
            "üÜï Repeat Customer - New Order!",
            {
              childName: letterPackages[0]?.childFirstName + ' ' + letterPackages[0]?.childLastName,
              packages: numberOfPackages,
              amount: order.total,
              customerEmail: customerEmail,
              previousOrder: `#${previousOrderId.slice(-8)}`
            },
            "medium",
            previousOrderId
          );
        }
      } catch (dbError) {
        console.error("‚ùå DATABASE ERROR saving order:", dbError);
        console.error("Error details:", JSON.stringify(dbError));
        throw dbError; // Re-throw to be caught by outer try-catch
      }

      // Send order confirmation email
      try {
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        if (resendApiKey && customerEmail) {
          // Generate email HTML
          const packagesHtml = letterPackages.map((pkg: any, idx: number) => `
            <div style="background: #fef2f2; border: 2px solid #fecaca; border-radius: 8px; padding: 15px; margin: 15px 0;">
              <p><strong>üì¶ Package ${idx + 1}</strong></p>
              <p><strong>Child:</strong> ${pkg.childFirstName} ${pkg.childLastName}</p>
              <p><strong>Friend:</strong> ${pkg.friendName}</p>
              <p><strong>Shipping to:</strong> ${pkg.streetAddress}${pkg.unitApt ? ', ' + pkg.unitApt : ''}, ${pkg.city}, ${pkg.state} ${pkg.zipCode}</p>
            </div>
          `).join('');

          const emailHtml = `
            <!DOCTYPE html>
            <html>
            <head>
              <meta charset="utf-8">
              <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
            </head>
            <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
              <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                  <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÖ Letter From Santa</h1>
                  <p style="margin: 10px 0 0 0; font-size: 18px;">Order Confirmed!</p>
                </div>
                <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                  <p>Dear ${customerName || 'Valued Customer'},</p>
                  
                  <p><span style="font-size: 24px;">üéâ</span> Thank you for your order! We're excited to help you keep the magic of Christmas alive.</p>
                  
                  <p><strong>Order Number:</strong> #${session.id.slice(-8)}<br>
                  <strong>Order Date:</strong> ${new Date().toLocaleDateString()}<br>
                  <strong>Total Amount:</strong> ${order.total.toFixed(2)}</p>
                  
                  <h3 style="color: #dc2626; margin-top: 30px;">üì¨ Your Letter Packages:</h3>
                  ${packagesHtml}
                  
                  <p style="margin-top: 30px;"><strong>What happens next?</strong></p>
                  <ul>
                    <li>‚ú® We're preparing your personalized letters from Santa</li>
                    <li>üìù Each letter will include a Good Behavior Certificate and Nice List</li>
                    <li>üìÆ Your packages will ship within 2-3 business days</li>
                    <li>üìß You'll receive a shipping notification with tracking</li>
                  </ul>
                  ${monthlySubscription ? `
                  <p style="margin-top: 30px; padding: 20px; background: #fff7ed; border-radius: 8px; border-left: 4px solid #f97316;">
                    <strong>üéÅ Welcome to Santa's Magical Adventures!</strong><br>
                    You're all set! Your subscription will start in January 2026 at $12/month. You can cancel anytime. Get ready for monthly packages filled with heartwarming stories from Santa!
                  </p>
                  ` : ''}
                  
                  <p style="margin-top: 30px; padding: 20px; background: #fef2f2; border-radius: 8px; border-left: 4px solid #dc2626;">
                    <strong>üéÑ Keep the Magic Alive!</strong><br>
                    Make sure to retrieve the mail before your little ones do! üòä
                  </p>
                </div>
                <div style="background: #f9fafb; padding: 20px; text-align: center; color: #6b7280; font-size: 14px; border-radius: 0 0 10px 10px;">
                  <p>Questions? Contact us at support@letterfromsanta.com</p>
                  <p style="margin-top: 10px; color: #9ca3af;">¬© 2025 Letters From Santa. All rights reserved.</p>
                </div>
              </div>
            </body>
            </html>
          `;

          const emailResponse = await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${resendApiKey}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
              to: [customerEmail],
              subject: `üéÖ Your Letters From Santa Order Confirmed! #${session.id.slice(-8)}`,
              html: emailHtml,
            }),
          });

          if (emailResponse.ok) {
            console.log("Order confirmation email sent to:", customerEmail);
          } else {
            console.error("Failed to send confirmation email:", await emailResponse.text());
          }

          // Send SMS if phone number provided
          const twilioSid = Deno.env.get("TWILIO_ACCOUNT_SID");
          const twilioToken = Deno.env.get("TWILIO_AUTH_TOKEN");
          const twilioPhone = Deno.env.get("TWILIO_PHONE_NUMBER");

          if (twilioSid && twilioToken && twilioPhone && customerPhone) {
            const twilioUrl = `https://api.twilio.com/2010-04-01/Accounts/${twilioSid}/Messages.json`;
            const credentials = btoa(`${twilioSid}:${twilioToken}`);

            const formData = new URLSearchParams();
            formData.append("To", customerPhone);
            formData.append("From", twilioPhone);
            formData.append("Body", `üéÖ Thank you! Your Letters From Santa order #${session.id.slice(-8)} is confirmed. We'll send tracking info when it ships! Check your email for details.`);

            const smsResponse = await fetch(twilioUrl, {
              method: "POST",
              headers: {
                Authorization: `Basic ${credentials}`,
                "Content-Type": "application/x-www-form-urlencoded",
              },
              body: formData.toString(),
            });

            if (smsResponse.ok) {
              console.log("Order confirmation SMS sent to:", customerPhone);
            } else {
              console.error("Failed to send confirmation SMS:", await smsResponse.text());
            }
          }
        }
      } catch (error) {
        console.error("Error sending order confirmation notifications:", error);
        // Don't fail the webhook if email/SMS fails
      }

      // Track sale event for affiliate
      if (affiliateId) {
        const eventId = `event_${Date.now()}_${Math.random().toString(36).substring(7)}`;
        const event = {
          eventId,
          affiliateId,
          eventType: "sale",
          orderId: session.id,
          revenue: order.total,
          commission: affiliateCommission,
          subIds: subIds || {},
          timestamp: new Date().toISOString(),
        };

        await kv.set(`event:${eventId}`, event);

        const allEventIds = (await kv.get("events:all")) || [];
        allEventIds.push(eventId);
        await kv.set("events:all", allEventIds);

        // Fire sale postback
        const postbacks = (await kv.get(`postbacks:${affiliateId}`)) || [];
        for (const postback of postbacks) {
          if (postback.enabledEvents && postback.enabledEvents.includes("sale")) {
            try {
              let url = postback.postbackUrl
                .replace('{affiliate_id}', affiliateId)
                .replace('{event_type}', 'sale')
                .replace('{amount}', order.total.toString())
                .replace('{commission}', affiliateCommission.toString())
                .replace('{orderid}', session.id)
                .replace('{timestamp}', event.timestamp);

              // Add sub IDs to URL
              Object.entries(subIds || {}).forEach(([key, value]) => {
                url = url.replace(`{${key}}`, value as string);
              });

              const response = await fetch(url, { method: 'GET' });
              
              const postbackLog = {
                postbackId: `pb_${Date.now()}`,
                affiliateId,
                eventId,
                eventType: "sale",
                orderId: session.id,
                url,
                status: response.ok ? "success" : "failed",
                statusCode: response.status,
                timestamp: new Date().toISOString(),
              };

              await kv.set(`postback_log:${postbackLog.postbackId}`, postbackLog);

              const allPostbackLogs = (await kv.get("postback_logs:all")) || [];
              allPostbackLogs.push(postbackLog.postbackId);
              await kv.set("postback_logs:all", allPostbackLogs);
            } catch (err: any) {
              console.error("Error firing sale postback:", err);
            }
          }
        }
      }
    }

    // Handle chargebacks
    if (event.type === "charge.dispute.created") {
      const dispute = event.data.object as any;
      const chargeId = dispute.charge;
      
      console.log("Chargeback created:", dispute.id);

      try {
        // Find the order associated with this charge
        const allOrderIds = (await kv.get("orders:all")) || [];
        let affectedOrder: any = null;
        
        for (const orderId of allOrderIds) {
          const order: any = await kv.get(`order:${orderId}`);
          if (order && order.sessionId && order.sessionId.includes(chargeId)) {
            affectedOrder = order;
            break;
          }
        }

        if (affectedOrder) {
          const chargebackId = `cb_${Date.now()}_${Math.random().toString(36).substring(7)}`;
          
          const chargeback = {
            chargebackId,
            orderId: affectedOrder.orderId,
            sessionId: affectedOrder.sessionId,
            affiliateId: affectedOrder.affiliateId || "direct",
            affiliateName: affectedOrder.affiliateName || "Direct Sale",
            amount: affectedOrder.total || 0,
            commission: affectedOrder.affiliateCommission || 0,
            reason: dispute.reason || "unknown",
            stripeChargeId: chargeId,
            stripeDisputeId: dispute.id,
            chargebackDate: new Date().toISOString(),
            orderDate: affectedOrder.orderDate,
            status: "pending",
            customerEmail: affectedOrder.customerInfo?.email || "",
            createdAt: new Date().toISOString(),
          };

          // Save chargeback
          await kv.set(`chargeback:${chargebackId}`, chargeback);
          
          const allChargebacks = (await kv.get("chargebacks:all")) || [];
          allChargebacks.push(chargebackId);
          await kv.set("chargebacks:all", allChargebacks);

          // Update order status
          affectedOrder.status = "chargeback";
          affectedOrder.chargebackId = chargebackId;
          affectedOrder.updatedAt = new Date().toISOString();
          await kv.set(`order:${affectedOrder.sessionId}`, affectedOrder);

          console.log("Chargeback recorded:", chargebackId);
        }
      } catch (error) {
        console.error("Error processing chargeback:", error);
      }
    }

    // Handle chargeback updates
    if (event.type === "charge.dispute.closed") {
      const dispute = event.data.object as any;
      
      // Find the chargeback
      const allChargebacks = (await kv.get("chargebacks:all")) || [];
      for (const chargebackId of allChargebacks) {
        const chargeback: any = await kv.get(`chargeback:${chargebackId}`);
        if (chargeback && chargeback.stripeDisputeId === dispute.id) {
          chargeback.status = dispute.status === "won" ? "won" : "lost";
          chargeback.updatedAt = new Date().toISOString();
          await kv.set(`chargeback:${chargebackId}`, chargeback);
          
          console.log(`Chargeback ${chargebackId} updated to: ${chargeback.status}`);
          break;
        }
      }
    }

    // Handle payment declines
    if (event.type === "payment_intent.payment_failed") {
      const paymentIntent = event.data.object as any;
      
      console.log("Payment declined:", paymentIntent.id);

      const declineId = `dec_${Date.now()}_${Math.random().toString(36).substring(7)}`;
      
      const decline = {
        declineId,
        paymentIntentId: paymentIntent.id,
        amount: paymentIntent.amount / 100,
        reason: paymentIntent.last_payment_error?.message || "unknown",
        customerEmail: paymentIntent.receipt_email || "",
        declineDate: new Date().toISOString(),
        createdAt: new Date().toISOString(),
      };

      await kv.set(`decline:${declineId}`, decline);
      
      const allDeclines = (await kv.get("declines:all")) || [];
      allDeclines.push(declineId);
      await kv.set("declines:all", allDeclines);
    }

    // Handle successful subscription payments (recurring charges)
    if (event.type === "invoice.payment_succeeded") {
      const invoice = event.data.object as any;
      
      // Skip if this is the initial $0 invoice
      if (invoice.amount_paid === 0 || invoice.billing_reason === "subscription_create") {
        console.log("Skipping $0 or initial subscription invoice");
        return c.json({ received: true });
      }

      console.log("üí≥ Subscription payment succeeded:", invoice.id, "Amount:", invoice.amount_paid / 100);

      // Find the parent order by subscription ID
      const allOrderIds = (await kv.get("orders:all")) || [];
      let parentOrder: any = null;
      
      for (const orderId of allOrderIds) {
        const order: any = await kv.get(`order:${orderId}`);
        if (order && order.subscriptionId === invoice.subscription) {
          parentOrder = order;
          break;
        }
      }

      if (parentOrder) {
        console.log("Found parent order:", parentOrder.orderId);
        
        // Increment successful charges
        parentOrder.successfulCharges = (parentOrder.successfulCharges || 0) + 1;
        parentOrder.subscriptionMonthsActive = parentOrder.successfulCharges;
        
        // Update next billing date
        const billingInterval = parentOrder.billingIntervalDays || 30;
        const nextBilling = new Date();
        nextBilling.setDate(nextBilling.getDate() + billingInterval);
        parentOrder.subscriptionNextBillingDate = nextBilling.toISOString();
        
        // Add activity log
        if (!parentOrder.activityLog) {
          parentOrder.activityLog = [];
        }
        parentOrder.activityLog.push({
          timestamp: new Date().toISOString(),
          action: 'Subscription Payment Received',
          details: `Charged ${(invoice.amount_paid / 100).toFixed(2)}. Month ${parentOrder.successfulCharges}. Next billing: ${nextBilling.toLocaleDateString()}. Invoice: ${invoice.id}`,
          user: 'Stripe Webhook',
          stripeUrl: `https://dashboard.stripe.com/invoices/${invoice.id}`
        });
        
        await kv.set(`order:${parentOrder.orderId}`, parentOrder);
        
        // Create a new order for this month's fulfillment
        console.log(`üì¶ [Webhook] Creating fulfillment order. Subscription letters count: ${(parentOrder.subscriptionLetters || []).length}`);
        console.log(`üì¶ [Webhook] Subscription letters data:`, JSON.stringify(parentOrder.subscriptionLetters));
        
        const newOrderId = `ord_${Date.now()}_${Math.random().toString(36).substring(7)}`;
        
        // Generate secure access token for this recurring order
        const recurringAccessToken = `oat_${Array.from(crypto.getRandomValues(new Uint8Array(32)))
          .map(b => b.toString(16).padStart(2, '0'))
          .join('')}`;
        
        const newOrder = {
          orderId: newOrderId,
          accessToken: recurringAccessToken, // Add access token for customer order lookup
          parentOrderId: parentOrder.orderId,
          subscriptionId: parentOrder.subscriptionId,
          sessionId: invoice.id,
          stripePaymentId: invoice.payment_intent,
          stripeCheckoutUrl: `https://dashboard.stripe.com/invoices/${invoice.id}`,
          orderDate: new Date().toISOString(),
          status: "pending",
          total: invoice.amount_paid / 100,
          customerInfo: parentOrder.customerInfo,
          letterPackages: parentOrder.letterPackages,
          numberOfPackages: parentOrder.numberOfPackages,
          letters: parentOrder.subscriptionLetters || [], // Copy subscription letter data for fulfillment
          shippingDate: "",
          monthlySubscription: false,
          subscriptionRecurringOrder: true,
          subscriptionMonth: parentOrder.successfulCharges,
          subscriptionProductName: parentOrder.subscriptionProductName || "Santa's Magical Journey",
          affiliateId: parentOrder.affiliateId,
          affiliateName: parentOrder.affiliateName,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          activityLog: [{
            timestamp: new Date().toISOString(),
            action: 'Order Created',
            details: `Recurring subscription order - Month ${parentOrder.successfulCharges}. Copied ${(parentOrder.subscriptionLetters || []).length} letter(s) from subscription.`,
            user: 'Stripe Webhook'
          }]
        };
        
        await kv.set(`order:${newOrderId}`, newOrder);
        allOrderIds.push(newOrderId);
        await kv.set("orders:all", allOrderIds);
        
        // Store token -> orderId mapping for quick lookup
        await kv.set(`token:${recurringAccessToken}`, newOrderId);
        
        console.log(`‚úÖ Created new order ${newOrderId} for subscription payment`);
        
        // Send email notification
        try {
          const resendApiKey = Deno.env.get("RESEND_API_KEY");
          if (resendApiKey && parentOrder.customerInfo?.email) {
            const emailResponse = await fetch("https://api.resend.com/emails", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${resendApiKey}`,
              },
              body: JSON.stringify({
                from: EMAIL_FROM,
                to: [parentOrder.customerInfo.email],
                subject: `üéÖ Your Month ${parentOrder.successfulCharges} Santa Letter is Coming!`,
                html: `
                  <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                    <h2 style="color: #dc2626;">üéÑ Ho Ho Ho!</h2>
                    <p>Dear ${parentOrder.customerInfo.name},</p>
                    <p>Great news! Your monthly Santa letter subscription payment has been processed successfully.</p>
                    <p><strong>Amount Charged:</strong> ${(invoice.amount_paid / 100).toFixed(2)}</p>
                    <p><strong>Subscription Month:</strong> ${parentOrder.successfulCharges}</p>
                    <p><strong>Product:</strong> ${parentOrder.subscriptionProductName || "Santa's Magical Journey"}</p>
                    <p>Your magical letter will be prepared and shipped soon!</p>
                    <p><strong>Next Billing Date:</strong> ${nextBilling.toLocaleDateString()}</p>
                    <p style="color: #059669;">Thank you for continuing this magical journey with us! üéÖ‚ú®</p>
                  </div>
                `,
              }),
            });
            
            if (emailResponse.ok) {
              const emailData = await emailResponse.json();
              console.log("‚úÖ Sent subscription payment notification email. Email ID:", emailData.id);
              
              // Log email activity
              await logEmailActivity(
                parentOrder.orderId,
                'subscription_payment',
                parentOrder.customerInfo.email,
                'Subscription Payment Confirmation',
                emailData.id
              );
            }
          }
        } catch (emailError) {
          console.error("Error sending subscription payment email:", emailError);
        }
      }
    }

    // Handle failed subscription payments
    if (event.type === "invoice.payment_failed") {
      const invoice = event.data.object as any;
      
      console.log("‚ùå Subscription payment failed:", invoice.id);

      // Find the parent order
      const allOrderIds = (await kv.get("orders:all")) || [];
      for (const orderId of allOrderIds) {
        const order: any = await kv.get(`order:${orderId}`);
        if (order && order.subscriptionId === invoice.subscription) {
          // Increment declined charges
          order.declinedCharges = (order.declinedCharges || 0) + 1;
          
          // Add activity log
          if (!order.activityLog) {
            order.activityLog = [];
          }
          order.activityLog.push({
            timestamp: new Date().toISOString(),
            action: 'Subscription Payment Failed',
            details: `Payment declined for ${(invoice.amount_due / 100).toFixed(2)}. Total declined: ${order.declinedCharges}. Invoice: ${invoice.id}`,
            user: 'Stripe Webhook',
            stripeUrl: `https://dashboard.stripe.com/invoices/${invoice.id}`
          });
          
          await kv.set(`order:${orderId}`, order);
          
          // Send email notification
          try {
            const resendApiKey = Deno.env.get("RESEND_API_KEY");
            if (resendApiKey && order.customerInfo?.email) {
              const emailResponse = await fetch("https://api.resend.com/emails", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  Authorization: `Bearer ${resendApiKey}`,
                },
                body: JSON.stringify({
                  from: EMAIL_FROM,
                  to: [order.customerInfo.email],
                  subject: "‚ö†Ô∏è Santa Letter Subscription - Payment Issue",
                  html: `
                    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                      <h2 style="color: #dc2626;">Payment Issue with Your Subscription</h2>
                      <p>Dear ${order.customerInfo.name},</p>
                      <p>We encountered an issue processing your monthly Santa letter subscription payment.</p>
                      <p><strong>Amount:</strong> ${(invoice.amount_due / 100).toFixed(2)}</p>
                      <p>Please update your payment method to continue receiving your magical letters.</p>
                      <p>If you have any questions, please contact us.</p>
                      <p style="color: #6b7280;">üéÑ Santa's Workshop</p>
                    </div>
                  `,
                }),
              });
              
              if (emailResponse.ok) {
                const emailData = await emailResponse.json();
                console.log("‚úÖ Sent payment failed email. Email ID:", emailData.id);
                
                // Log email activity
                await logEmailActivity(
                  orderId,
                  'payment_failed',
                  order.customerInfo.email,
                  'Payment Failed Notification',
                  emailData.id
                );
              }
            }
          } catch (emailError) {
            console.error("Error sending payment failed email:", emailError);
          }
          
          console.log(`‚úÖ Updated order ${orderId} with declined charge`);
          break;
        }
      }
    }

    console.log("‚úÖ Webhook processed successfully");
    console.log("========== WEBHOOK COMPLETE ==========\n");
    return c.json({ received: true });
  } catch (err: any) {
    console.error("‚ùå‚ùå‚ùå WEBHOOK ERROR ‚ùå‚ùå‚ùå");
    console.error("Error type:", err.constructor.name);
    console.error("Error message:", err.message);
    console.error("Error stack:", err.stack);
    console.error("Full error:", JSON.stringify(err, null, 2));
    console.error("========== WEBHOOK FAILED ==========\n");
    return c.json({ error: err.message }, 400);
  }
});

// TESTING: Simulate a webhook call (for debugging webhook handler)
app.post("/make-server-cf244566/test-webhook-simulation", async (c) => {
  console.log("üß™ WEBHOOK SIMULATION STARTED");
  
  try {
    const testSessionId = `cs_test_sim_${Date.now()}`;
    
    // Simulate what the webhook handler does
    const letterPackages = [{
      childFirstName: "Webhook",
      childLastName: "Test",
      friendName: "Test Friend",
      streetAddress: "123 Webhook St",
      unitApt: "",
      city: "Test City",
      state: "CA",
      zipCode: "12345",
    }];
    
    const order = {
      orderId: testSessionId,
      sessionId: testSessionId,
      stripePaymentId: `pi_webhook_test_${Date.now()}`,
      stripeCheckoutUrl: `https://dashboard.stripe.com/test/payments/pi_webhook_test_${Date.now()}`,
      orderDate: new Date().toISOString(),
      status: "pending",
      total: 17.95,
      customerInfo: {
        email: "webhook-test@test.com",
        name: "Webhook Test Customer",
        phone: "5555555555",
        address: {
          line1: "123 Webhook St",
          line2: "",
          city: "Test City",
          state: "CA",
          postal_code: "12345",
          country: "US",
        },
      },
      letterPackages,
      numberOfPackages: 1,
      shippingDate: "December 15th",
      monthlySubscription: false,
      subscriptionId: null,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    console.log("Simulating order save...");
    await kv.set(`order:${testSessionId}`, order);
    
    const allOrderIds = (await kv.get("orders:all")) || [];
    allOrderIds.push(testSessionId);
    await kv.set("orders:all", allOrderIds);
    
    console.log("‚úÖ Webhook simulation complete - order created:", testSessionId);
    
    return c.json({ 
      success: true, 
      message: "Webhook simulation successful",
      orderId: testSessionId,
      note: "This simulates what the Stripe webhook does. Check admin dashboard!"
    });
  } catch (error: any) {
    console.error("‚ùå Webhook simulation failed:", error);
    return c.json({ error: error.message }, 500);
  }
});

// TESTING: Create a test order manually (for debugging)
app.post("/make-server-cf244566/test-order", async (c) => {
  try {
    const testOrderId = `test_order_${Date.now()}`;
    
    const testOrder = {
      orderId: testOrderId,
      sessionId: testOrderId,
      stripePaymentId: `pi_test_${Date.now()}`,
      stripeCheckoutUrl: `https://dashboard.stripe.com/test/payments/pi_test_${Date.now()}`,
      orderDate: new Date().toISOString(),
      status: "pending",
      total: 17.95,
      customerInfo: {
        name: "Test Customer",
        email: "test@test.com",
        phone: "5555555555",
        address: {
          line1: "123 Test St",
          line2: "",
          city: "Test City",
          state: "CA",
          postal_code: "12345",
          country: "US",
        },
      },
      letterPackages: [{
        childFirstName: "Test",
        childLastName: "Child",
        friendName: "Best Friend",
        streetAddress: "123 Test St",
        unitApt: "",
        city: "Test City",
        state: "CA",
        zipCode: "12345",
      }],
      numberOfPackages: 1,
      shippingDate: "December 15th",
      monthlySubscription: false,
      subscriptionId: null,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    // Save the order
    await kv.set(`order:${testOrderId}`, testOrder);
    
    // Add to orders list
    const allOrderIds = (await kv.get("orders:all")) || [];
    allOrderIds.push(testOrderId);
    await kv.set("orders:all", allOrderIds);

    console.log("Test order created:", testOrderId);
    
    return c.json({ 
      success: true, 
      orderId: testOrderId,
      message: "Test order created successfully" 
    });
  } catch (error: any) {
    console.error("Error creating test order:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Get all orders (admin only)
app.get("/make-server-cf244566/orders", async (c) => {
  try {
    const allOrderIds = (await kv.get("orders:all")) || [];
    
    // Fetch all orders
    const orders = [];
    for (const orderId of allOrderIds) {
      const order = await kv.get(`order:${orderId}`);
      if (order) {
        orders.push(order);
      }
    }

    // Sort by date (newest first)
    orders.sort((a: any, b: any) => new Date(b.orderDate).getTime() - new Date(a.orderDate).getTime());

    return c.json({ orders });
  } catch (error: any) {
    console.error("Error fetching orders:", error);
    return c.json({ error: "Failed to fetch orders" }, 500);
  }
});

// Get admin alerts
app.get("/make-server-cf244566/admin/alerts", async (c) => {
  try {
    const alertIds = (await kv.getByPrefix("admin_alert:")) || [];
    
    const alerts = [];
    for (const item of alertIds) {
      if (item.value) {
        alerts.push(item.value);
      }
    }

    // Sort by date (newest first)
    alerts.sort((a: any, b: any) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());

    // Count unread
    const unreadCount = alerts.filter((a: any) => a.status === "unread").length;

    return c.json({ alerts, unreadCount });
  } catch (error: any) {
    console.error("Error fetching alerts:", error);
    return c.json({ error: "Failed to fetch alerts" }, 500);
  }
});

// Mark alert as read
app.patch("/make-server-cf244566/admin/alerts/:alertId/read", async (c) => {
  try {
    const alertId = c.req.param("alertId");
    const alert: any = await kv.get(`admin_alert:${alertId}`);
    
    if (!alert) {
      return c.json({ error: "Alert not found" }, 404);
    }

    alert.status = "read";
    alert.readAt = new Date().toISOString();
    
    await kv.set(`admin_alert:${alertId}`, alert);

    return c.json({ success: true, alert });
  } catch (error: any) {
    console.error("Error marking alert as read:", error);
    return c.json({ error: "Failed to mark alert as read" }, 500);
  }
});

// Mark all alerts as read
app.post("/make-server-cf244566/admin/alerts/read-all", async (c) => {
  try {
    const alertIds = (await kv.getByPrefix("admin_alert:")) || [];
    
    for (const item of alertIds) {
      if (item.value && item.value.status === "unread") {
        item.value.status = "read";
        item.value.readAt = new Date().toISOString();
        await kv.set(item.key, item.value);
      }
    }

    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error marking all alerts as read:", error);
    return c.json({ error: "Failed to mark alerts as read" }, 500);
  }
});

// Delete alert
app.delete("/make-server-cf244566/admin/alerts/:alertId", async (c) => {
  try {
    const alertId = c.req.param("alertId");
    await kv.del(`admin_alert:${alertId}`);

    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error deleting alert:", error);
    return c.json({ error: "Failed to delete alert" }, 500);
  }
});

// Get single order by ID
app.get("/make-server-cf244566/orders/:orderId", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const order = await kv.get(`order:${orderId}`);

    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    return c.json({ order });
  } catch (error: any) {
    console.error("Error fetching order:", error);
    return c.json({ error: "Failed to fetch order" }, 500);
  }
});

// Get order by access token (for success page)
app.get("/make-server-cf244566/order/:token", async (c) => {
  try {
    const token = c.req.param("token");
    console.log(`üîç Looking up order by token: ${token?.substring(0, 15)}...`);
    
    // Search for order by access token
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    // Legacy support: try direct order ID lookup first
    if (!token.startsWith("oat_")) {
      order = await kv.get(`order:${token}`);
      if (order) {
        console.log(`‚úÖ Found order by direct ID (legacy): ${order.orderId}`);
      }
    }
    
    // Try to find by access token
    if (!order) {
      for (const orderId of allOrderIds) {
        const orderData: any = await kv.get(`order:${orderId}`);
        if (orderData && orderData.accessToken === token) {
          order = orderData;
          console.log(`‚úÖ Found order by access token: ${order.orderId}`);
          break;
        }
      }
    }
    
    if (!order) {
      console.error("‚ùå Order not found for token");
      return c.json({ error: "Order not found" }, 404);
    }
    
    // AUTO-FIX: If customer ID is missing, try to retrieve or create it
    if (!order.stripeCustomerId && stripe) {
      console.log("üîß AUTO-FIXING: Missing customer ID for order:", order.orderId);
      try {
        let customerId = null;
        
        // Try to get customer from payment intent first
        if (order.stripePaymentId) {
          try {
            const paymentIntent = await stripe.paymentIntents.retrieve(order.stripePaymentId);
            if (paymentIntent.customer) {
              customerId = paymentIntent.customer as string;
              console.log("‚úÖ Found customer ID from payment intent:", customerId);
              
              // Also get payment method if available
              if (paymentIntent.payment_method && !order.stripePaymentMethodId) {
                order.stripePaymentMethodId = paymentIntent.payment_method as string;
              }
            }
          } catch (piError: any) {
            console.log("‚ö†Ô∏è Could not retrieve payment intent:", piError.message);
          }
        }
        
        // If still no customer, create a new one from order data
        if (!customerId && order.customerInfo?.email) {
          console.log("üÜï Creating new Stripe customer for order:", order.orderId);
          const customer = await stripe.customers.create({
            email: order.customerInfo.email,
            name: order.customerInfo.name || "Customer",
            phone: order.customerInfo.phone || undefined,
            address: order.customerInfo.address ? {
              line1: order.customerInfo.address.line1 || undefined,
              line2: order.customerInfo.address.line2 || undefined,
              city: order.customerInfo.address.city || undefined,
              state: order.customerInfo.address.state || undefined,
              postal_code: order.customerInfo.address.postal_code || undefined,
              country: order.customerInfo.address.country || "US"
            } : undefined,
            metadata: {
              orderId: order.orderId,
              source: "auto-fix-migration"
            }
          });
          customerId = customer.id;
          console.log("‚úÖ Created new Stripe customer:", customerId);
        }
        
        // Save customer ID to order
        if (customerId) {
          order.stripeCustomerId = customerId;
          await kv.set(`order:${order.orderId}`, order);
          console.log("‚úÖ AUTO-FIXED: Saved customer ID to order");
        } else {
          console.error("‚ùå Could not fix customer ID - no email address available");
        }
      } catch (error: any) {
        console.error("‚ùå Auto-fix failed:", error.message);
      }
    }
    
    return c.json({ order });
  } catch (error: any) {
    console.error("Error fetching order by token:", error);
    return c.json({ error: "Failed to fetch order" }, 500);
  }
});

// Update order status (POST /orders/:orderId/status - used by admin dashboard)
app.post("/make-server-cf244566/orders/:orderId/status", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const body = await c.req.json();
    const { status } = body;

    console.log(`üìù Updating order ${orderId} status to: ${status}`);

    const order: any = await kv.get(`order:${orderId}`);

    if (!order) {
      console.error(`‚ùå Order ${orderId} not found`);
      return c.json({ error: "Order not found" }, 404);
    }

    const oldStatus = order.status;
    
    // Add activity log entry
    if (!order.activityLog) order.activityLog = [];
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Status Changed',
      details: `Status changed from "${oldStatus}" to "${status}"`,
      user: 'Admin'
    });
    
    order.status = status;
    order.updatedAt = new Date().toISOString();

    await kv.set(`order:${orderId}`, order);
    console.log(`‚úÖ Order ${orderId} status updated successfully`);

    return c.json({ success: true, order });
  } catch (error: any) {
    console.error("Error updating order status:", error);
    return c.json({ error: error.message || "Failed to update status" }, 500);
  }
});

// Update order status (PATCH /orders/:orderId - legacy)
app.patch("/make-server-cf244566/orders/:orderId", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const body = await c.req.json();
    const { status } = body;

    const order: any = await kv.get(`order:${orderId}`);

    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    const oldStatus = order.status;
    order.status = status;
    order.updatedAt = new Date().toISOString();

    await kv.set(`order:${orderId}`, order);

    // Send canceled notification if order was canceled
    if (status === "canceled-refunded" && oldStatus !== "canceled-refunded") {
      try {
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        const customerEmail = order.customerInfo?.email;
        const customerName = order.customerInfo?.name || "Valued Customer";

        if (resendApiKey && customerEmail) {
          const emailHtml = `
            <!DOCTYPE html>
            <html>
            <body style="font-family: Arial, sans-serif;">
              <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <h1>Order Canceled</h1>
                <p>Dear ${customerName},</p>
                <p>Your order <strong>#${orderId.slice(-8)}</strong> has been canceled.</p>
                <p>If you have questions, please contact support@letterfromsanta.com</p>
              </div>
            </body>
            </html>
          `;

          const emailResponse = await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${resendApiKey}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
              to: [customerEmail],
              subject: `Order Canceled - #${orderId.slice(-8)}`,
              html: emailHtml,
            }),
          });
          
          if (emailResponse.ok) {
            const emailData = await emailResponse.json();
            console.log("‚úÖ Sent order canceled email. Email ID:", emailData.id);
            
            // Log email activity
            await logEmailActivity(
              orderId,
              'order_canceled',
              customerEmail,
              'Order Canceled Notification',
              emailData.id
            );
          }
        }
      } catch (error) {
        console.error("Error sending canceled notification:", error);
      }
    }

    return c.json({ order });
  } catch (error: any) {
    console.error("Error updating order:", error);
    return c.json({ error: "Failed to update order" }, 500);
  }
});

// Edit order letter data (admin only, unfulfilled orders)
app.patch("/make-server-cf244566/orders/:orderId/letter-data", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const body = await c.req.json();
    const { letterPackages } = body;

    const order: any = await kv.get(`order:${orderId}`);

    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    if (order.status === "fulfilled") {
      return c.json({ error: "Cannot edit fulfilled orders" }, 400);
    }

    // Track changes
    const changes: string[] = [];
    const oldPackages = order.letterPackages || [];

    letterPackages.forEach((newPkg: any, idx: number) => {
      const oldPkg = oldPackages[idx];
      if (oldPkg) {
        if (oldPkg.childFirstName !== newPkg.childFirstName || oldPkg.childLastName !== newPkg.childLastName) {
          changes.push(`Child name updated for package ${idx + 1}`);
        }
        if (oldPkg.friendName !== newPkg.friendName) {
          changes.push(`Friend name updated for package ${idx + 1}`);
        }
        if (oldPkg.streetAddress !== newPkg.streetAddress || oldPkg.city !== newPkg.city) {
          changes.push(`Address updated for package ${idx + 1}`);
        }
      }
    });

    order.letterPackages = letterPackages;
    order.numberOfPackages = letterPackages.length;
    order.updatedAt = new Date().toISOString();

    await kv.set(`order:${orderId}`, order);

    // Send change notification and create admin alert
    if (changes.length > 0) {
      // Create admin alert
      const alert = {
        id: `alert-${Date.now()}`,
        type: "order_edited",
        orderId: orderId,
        message: `Order edited by customer. Admin review required before shipping.`,
        details: {
          changes: changes,
          editedBy: "Customer",
          totalPackages: letterPackages.length,
        },
        status: "unread",
        priority: "medium",
        createdAt: new Date().toISOString(),
      };
      await kv.set(`admin_alert:${alert.id}`, alert);
      
      try {
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        const customerEmail = order.customerInfo?.email;
        const customerName = order.customerInfo?.name || "Valued Customer";

        if (resendApiKey && customerEmail) {
          const changesHtml = changes.map(c => `<li>${c}</li>`).join('');
          const emailHtml = `
            <!DOCTYPE html>
            <html>
            <body style="font-family: Arial, sans-serif;">
              <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <h1>‚úèÔ∏è Order Updated</h1>
                <p>Dear ${customerName},</p>
                <p>Your order <strong>#${orderId.slice(-8)}</strong> has been updated.</p>
                <h3>Changes Made:</h3>
                <ul>${changesHtml}</ul>
                <div style="background-color: #fef3c7; padding: 15px; border-radius: 5px; margin: 20px 0;">
                  <strong>‚ö†Ô∏è Important:</strong> Our team will review and confirm these changes before shipping your order.
                </div>
                <p>Questions? Contact support@letterfromsanta.com</p>
              </div>
            </body>
            </html>
          `;

          const emailResponse = await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${resendApiKey}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
              to: [customerEmail],
              subject: `‚úèÔ∏è Order Updated - #${orderId.slice(-8)}`,
              html: emailHtml,
            }),
          });
          
          if (emailResponse.ok) {
            const emailData = await emailResponse.json();
            console.log("‚úÖ Sent customer edit notification email. Email ID:", emailData.id);
            
            // Log email activity
            await logEmailActivity(
              orderId,
              'customer_edit',
              customerEmail,
              'Customer Edit Notification',
              emailData.id
            );
          }
        }
      } catch (error) {
        console.error("Error sending change notification:", error);
      }
    }

    return c.json({ order, changes });
  } catch (error: any) {
    console.error("Error editing order:", error);
    return c.json({ error: "Failed to edit order" }, 500);
  }
});

// Add child to existing order or create new order
app.post("/make-server-cf244566/order/add-child", async (c) => {
  try {
    const body = await c.req.json();
    const { orderToken, childrenData, numberOfPackages, addNorthPoleSnow, packagePrice, paymentMethodId, isFulfilled } = body;

    // Find the original order
    const order: any = await kv.get(`order:${orderToken}`);
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    const stripe = new Stripe(Deno.env.get("STRIPE_SECRET_KEY")!);
    const northPoleSnowPrice = 9.99;
    const packagesTotal = packagePrice * numberOfPackages;
    const snowTotal = addNorthPoleSnow ? northPoleSnowPrice : 0;
    const totalAmount = packagesTotal + snowTotal;

    // Create payment intent
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(totalAmount * 100),
      currency: "usd",
      payment_method: paymentMethodId,
      confirm: true,
      automatic_payment_methods: {
        enabled: true,
        allow_redirects: "never",
      },
      description: `Additional ${numberOfPackages} letter package(s)${addNorthPoleSnow ? ' + North Pole Snow' : ''}`,
      metadata: {
        originalOrderId: order.orderId,
        orderType: isFulfilled ? "new_order" : "order_update",
        numberOfPackages: numberOfPackages.toString(),
        includesNorthPoleSnow: addNorthPoleSnow.toString(),
      },
    });

    if (paymentIntent.status !== "succeeded") {
      return c.json({ error: "Payment failed" }, 400);
    }

    // Build child names list (used in both branches)
    const childNames = childrenData.map((c: any) => `${c.childFirstName} ${c.childLastName}`).join(', ');

    if (isFulfilled) {
      // CREATE NEW ORDER
      const newOrderId = `ORD-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      const newOrder = {
        orderId: newOrderId,
        orderDate: new Date().toISOString(),
        status: "pending",
        total: totalAmount,
        customerInfo: order.customerInfo,
        letterPackages: childrenData,
        numberOfPackages: numberOfPackages,
        shippingDate: order.shippingDate,
        monthlySubscription: false,
        includesNorthPoleSnow: addNorthPoleSnow,
        northPoleSnowPrice: addNorthPoleSnow ? northPoleSnowPrice : 0,
        stripePaymentIntentId: paymentIntent.id,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        relatedOrderId: order.orderId, // Link to original order
        orderSource: "add_child_fulfilled",
        activityLog: [{
          timestamp: new Date().toISOString(),
          action: "Order Created",
          details: `New order created from existing order ${order.orderId}. ${numberOfPackages} package(s)${addNorthPoleSnow ? ' + North Pole Snow' : ''}`,
          user: "Customer"
        }]
      };

      await kv.set(`order:${newOrderId}`, newOrder);
      
      // Add to orders list
      const allOrderIds = (await kv.get("orders:all")) || [];
      allOrderIds.push(newOrderId);
      await kv.set("orders:all", allOrderIds);

      // Create admin alert
      const alert = {
        id: `alert-${Date.now()}`,
        type: "new_order_from_existing",
        orderId: newOrderId,
        relatedOrderId: order.orderId,
        message: `New order created by customer. Original order ${order.orderId} was already fulfilled.`,
        details: {
          children: childNames,
          packages: numberOfPackages,
          includesNorthPoleSnow: addNorthPoleSnow,
          amount: totalAmount,
        },
        status: "unread",
        createdAt: new Date().toISOString(),
      };
      await kv.set(`admin_alert:${alert.id}`, alert);

      // Send confirmation email
      try {
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        if (resendApiKey && order.customerInfo?.email) {
          const emailResponse = await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              Authorization: `Bearer ${resendApiKey}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              from: "Santa's Letters <orders@santasletters.com>",
              to: order.customerInfo.email,
              subject: `New Order Confirmed! Order #${newOrderId.slice(-8)}`,
              html: `
                <h2>üéÖ New Letter Package Order Confirmed!</h2>
                <p>Dear ${order.customerInfo.name},</p>
                <p>We've created a new order for your additional letter ${numberOfPackages > 1 ? 'packages' : 'package'}!</p>
                <h3>Order Details:</h3>
                <ul>
                  <li><strong>Order Number:</strong> ${newOrderId.slice(-8)}</li>
                  <li><strong>Children:</strong> ${childNames}</li>
                  <li><strong>Packages:</strong> ${numberOfPackages}</li>
                  ${addNorthPoleSnow ? '<li><strong>North Pole Snow:</strong> Included ‚ùÑÔ∏è</li>' : ''}
                  <li><strong>Total:</strong> ${totalAmount.toFixed(2)}</li>
                </ul>
                <p>Your original order (#${order.orderId.slice(-8)}) has already been shipped, so this will be processed as a separate order.</p>
                <p>Thank you for spreading more Christmas magic! üéÑ</p>
              `,
            }),
          });
          
          if (emailResponse.ok) {
            const emailData = await emailResponse.json();
            console.log("‚úÖ Sent new order confirmation email. Email ID:", emailData.id);
            
            // Log email activity to the NEW order
            await logEmailActivity(
              newOrderId,
              'new_order_confirmation',
              order.customerInfo.email,
              'New Order Confirmation',
              emailData.id
            );
          }
        }
      } catch (emailError) {
        console.error("Error sending email:", emailError);
      }

      return c.json({ 
        success: true, 
        orderCreated: true,
        orderId: newOrderId,
        message: "New order created successfully" 
      });
    } else {
      // UPDATE EXISTING ORDER
      const updatedPackages = [...order.letterPackages, ...childrenData];

      const oldTotal = order.total || 0;
      const newTotal = oldTotal + totalAmount;
      
      // Update North Pole Snow if added
      if (addNorthPoleSnow) {
        order.includesNorthPoleSnow = true;
        order.northPoleSnowPrice = (order.northPoleSnowPrice || 0) + northPoleSnowPrice;
      }

      order.letterPackages = updatedPackages;
      order.numberOfPackages = updatedPackages.length;
      order.total = newTotal;
      order.updatedAt = new Date().toISOString();

      // Add to activity log
      if (!order.activityLog) order.activityLog = [];
      order.activityLog.push({
        timestamp: new Date().toISOString(),
        action: "Packages Added",
        details: `Customer added ${numberOfPackages} package(s) for ${childNames}${addNorthPoleSnow ? ' + North Pole Snow' : ''}. Payment: ${totalAmount.toFixed(2)}`,
        user: "Customer",
        stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntent.id}`
      });

      // Track additional payment
      if (!order.additionalPayments) order.additionalPayments = [];
      order.additionalPayments.push({
        amount: totalAmount,
        paymentIntentId: paymentIntent.id,
        timestamp: new Date().toISOString(),
        reason: "Additional letter package",
      });

      await kv.set(`order:${orderToken}`, order);

      // Create admin alert
      const alert = {
        id: `alert-${Date.now()}`,
        type: "order_updated",
        orderId: order.orderId,
        message: `Customer added ${numberOfPackages} package(s)${addNorthPoleSnow ? ' + North Pole Snow' : ''} to unfulfilled order. Please review changes before shipping.`,
        details: {
          children: childNames,
          packagesAdded: numberOfPackages,
          includesNorthPoleSnow: addNorthPoleSnow,
          additionalAmount: totalAmount,
          newTotal: newTotal,
          totalPackages: updatedPackages.length,
        },
        status: "unread",
        priority: "high",
        createdAt: new Date().toISOString(),
      };
      await kv.set(`admin_alert:${alert.id}`, alert);

      // Send confirmation email
      try {
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        if (resendApiKey && order.customerInfo?.email) {
          const emailResponse = await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              Authorization: `Bearer ${resendApiKey}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              from: "Santa's Letters <orders@santasletters.com>",
              to: order.customerInfo.email,
              subject: `Order Updated - Added Letter Package(s)`,
              html: `
                <h2>üéÖ Order Updated Successfully!</h2>
                <p>Dear ${order.customerInfo.name},</p>
                <p>We've added ${numberOfPackages} letter package(s)${addNorthPoleSnow ? ' + Certified North Pole Snow ‚ùÑÔ∏è' : ''} to your order!</p>
                <h3>Updated Order Details:</h3>
                <ul>
                  <li><strong>Order Number:</strong> ${order.orderId.slice(-8)}</li>
                  <li><strong>Children Added:</strong> ${childNames}</li>
                  <li><strong>Packages Added:</strong> ${numberOfPackages}</li>
                  ${addNorthPoleSnow ? '<li><strong>North Pole Snow:</strong> Included ‚ùÑÔ∏è</li>' : ''}
                  <li><strong>Additional Amount:</strong> ${totalAmount.toFixed(2)}</li>
                  <li><strong>New Total:</strong> ${newTotal.toFixed(2)}</li>
                  <li><strong>Total Packages:</strong> ${updatedPackages.length}</li>
                </ul>
                <div style="background-color: #fef3c7; padding: 15px; border-radius: 5px; margin: 20px 0;">
                  <strong>‚ö†Ô∏è Important:</strong> Our team will review and confirm these changes before shipping your order.
                </div>
                <p>Thank you for adding more Christmas magic! üéÑ</p>
              `,
            }),
          });
          
          if (emailResponse.ok) {
            const emailData = await emailResponse.json();
            console.log("‚úÖ Sent packages added confirmation email. Email ID:", emailData.id);
            
            // Log email activity
            await logEmailActivity(
              order.orderId,
              'packages_added',
              order.customerInfo.email,
              'Packages Added Confirmation',
              emailData.id
            );
          }
        }
      } catch (emailError) {
        console.error("Error sending email:", emailError);
      }

      return c.json({ 
        success: true, 
        orderUpdated: true,
        orderId: order.orderId,
        message: "Order updated successfully" 
      });
    }
  } catch (error: any) {
    console.error("Error adding child:", error);
    return c.json({ error: error.message || "Failed to add child" }, 500);
  }
});

// Archive order
app.post("/make-server-cf244566/orders/:orderId/archive", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const order: any = await kv.get(`order:${orderId}`);
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    order.archived = true;
    order.updatedAt = new Date().toISOString();
    
    // Add to activity log
    if (!order.activityLog) order.activityLog = [];
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: "Order Archived",
      details: "Order moved to archived section",
      user: "Admin"
    });

    await kv.set(`order:${orderId}`, order);
    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error archiving order:", error);
    return c.json({ error: "Failed to archive order" }, 500);
  }
});

// Unarchive order
app.post("/make-server-cf244566/orders/:orderId/unarchive", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const order: any = await kv.get(`order:${orderId}`);
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    order.archived = false;
    order.updatedAt = new Date().toISOString();
    
    // Add to activity log
    if (!order.activityLog) order.activityLog = [];
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: "Order Restored",
      details: "Order restored from archived section",
      user: "Admin"
    });

    await kv.set(`order:${orderId}`, order);
    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error unarchiving order:", error);
    return c.json({ error: "Failed to unarchive order" }, 500);
  }
});

// Resend email notification
app.post("/make-server-cf244566/order/:orderId/resend-email", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const { emailType } = await c.req.json();
    
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    const resendApiKey = Deno.env.get("RESEND_API_KEY");
    if (!resendApiKey) {
      return c.json({ error: "Email service not configured" }, 503);
    }

    const customerEmail = order.customerInfo?.email;
    const customerName = order.customerInfo?.name || "Valued Customer";

    if (!customerEmail) {
      return c.json({ error: "No customer email found" }, 400);
    }

    let emailHtml = "";
    let subject = "";

    // Generate email based on type
    switch (emailType) {
      case "order_confirmation":
        subject = "üéÖ Order Confirmation - Santa's Letters";
        const packageDetails = order.letterPackages?.map((pkg: any, idx: number) => `
          <div style="background: #fef2f2; border: 2px solid #fecaca; border-radius: 8px; padding: 15px; margin: 15px 0;">
            <p><strong>üì¶ Package ${idx + 1}</strong></p>
            <p><strong>Child:</strong> ${pkg.childFirstName} ${pkg.childLastName}</p>
            <p><strong>Friend:</strong> ${pkg.friendName || 'N/A'}</p>
            <p><strong>Shipping to:</strong> ${pkg.streetAddress}${pkg.unitApt ? ', ' + pkg.unitApt : ''}, ${pkg.city}, ${pkg.state} ${pkg.zipCode}</p>
          </div>
        `).join('') || '';

        emailHtml = `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
          </head>
          <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÖ Thank You!</h1>
              </div>
              <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                <p>Hi ${customerName},</p>
                <p style="font-size: 18px; color: #059669;"><strong>‚úÖ Your order has been received!</strong></p>
                <div style="background: #dbeafe; padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #3b82f6;">
                  <p style="margin: 0;"><strong>Order #:</strong> ${orderId.slice(-8)}</p>
                  <p style="margin: 5px 0 0 0;"><strong>Total:</strong> ${order.total?.toFixed(2)}</p>
                </div>
                <h3>Your Letter Packages:</h3>
                ${packageDetails}
                <p style="margin-top: 30px;">The North Pole elves are preparing your magical letters! üéÑ</p>
                <p>Questions? Reply to this email anytime.</p>
              </div>
            </div>
          </body>
          </html>
        `;
        break;

      case "tracking_notification":
        subject = "üì¶ Your Order Has Shipped - Tracking Information";
        const trackingUrl = order.trackingNumber?.startsWith('1Z') 
          ? `https://www.ups.com/track?tracknum=${order.trackingNumber}`
          : `https://tools.usps.com/go/TrackConfirmAction?tLabels=${order.trackingNumber}`;

        emailHtml = `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
          </head>
          <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center;">
                <h1 style="font-family: 'Pacifico', cursive;">üì¶ Your Order Has Shipped!</h1>
              </div>
              <div style="background: white; padding: 30px;">
                <p>Hi ${customerName},</p>
                <p>Great news! Your magical letters from Santa are on their way! üéÖ‚ú®</p>
                <div style="background: #dbeafe; padding: 20px; border-radius: 8px; margin: 20px 0;">
                  <p><strong>Tracking Number:</strong> ${order.trackingNumber}</p>
                  <p><strong>Carrier:</strong> ${order.carrier || 'USPS'}</p>
                </div>
                <div style="text-align: center; margin: 30px 0;">
                  <a href="${trackingUrl}" style="background: #dc2626; color: white; padding: 15px 30px; text-decoration: none; border-radius: 5px; display: inline-block;">
                    Track Your Package
                  </a>
                </div>
              </div>
            </div>
          </body>
          </html>
        `;
        break;

      case "order_update":
        subject = "üìù Order Updated - Changes Confirmed";
        emailHtml = `
          <!DOCTYPE html>
          <html>
          <body style="font-family: Arial, sans-serif;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <h1>Order Updated</h1>
              <p>Hi ${customerName},</p>
              <p>Your order has been successfully updated!</p>
              <p><strong>Order #:</strong> ${orderId.slice(-8)}</p>
              <p>Thank you for your updates. Our elves are working on it! üéÖ</p>
            </div>
          </body>
          </html>
        `;
        break;

      case "subscription_payment":
        subject = "üéÖ Monthly Subscription Payment Confirmed";
        emailHtml = `
          <!DOCTYPE html>
          <html>
          <body style="font-family: Arial, sans-serif;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <h2 style="color: #dc2626;">üéÑ Ho Ho Ho!</h2>
              <p>Dear ${customerName},</p>
              <p>Your monthly Santa letter subscription payment has been processed successfully.</p>
              <p>Your magical letter will be prepared and shipped soon!</p>
              <p style="color: #059669;">Thank you for continuing this magical journey with us! üéÖ‚ú®</p>
            </div>
          </body>
          </html>
        `;
        break;

      case "payment_failed":
        subject = "‚ö†Ô∏è Santa Letter Subscription - Payment Issue";
        emailHtml = `
          <!DOCTYPE html>
          <html>
          <body style="font-family: Arial, sans-serif;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <h2 style="color: #dc2626;">Payment Issue with Your Subscription</h2>
              <p>Dear ${customerName},</p>
              <p>We encountered an issue processing your monthly Santa letter subscription payment.</p>
              <p>Please update your payment method to continue receiving your magical letters.</p>
              <p>If you have any questions, please contact us.</p>
              <p style="color: #6b7280;">üéÑ Santa's Workshop</p>
            </div>
          </body>
          </html>
        `;
        break;

      case "order_canceled":
        subject = `Order Canceled - #${orderId.slice(-8)}`;
        emailHtml = `
          <!DOCTYPE html>
          <html>
          <body style="font-family: Arial, sans-serif;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <h1>Order Canceled</h1>
              <p>Dear ${customerName},</p>
              <p>Your order <strong>#${orderId.slice(-8)}</strong> has been canceled.</p>
              <p>If you have questions, please contact support@letterfromsanta.com</p>
            </div>
          </body>
          </html>
        `;
        break;

      case "customer_edit":
        subject = `‚úèÔ∏è Order Updated - #${orderId.slice(-8)}`;
        emailHtml = `
          <!DOCTYPE html>
          <html>
          <body style="font-family: Arial, sans-serif;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <h1>‚úèÔ∏è Order Updated</h1>
              <p>Dear ${customerName},</p>
              <p>Your order <strong>#${orderId.slice(-8)}</strong> has been updated.</p>
              <div style="background-color: #fef3c7; padding: 15px; border-radius: 5px; margin: 20px 0;">
                <strong>‚ö†Ô∏è Important:</strong> Our team will review and confirm these changes before shipping your order.
              </div>
              <p>Questions? Contact support@letterfromsanta.com</p>
            </div>
          </body>
          </html>
        `;
        break;

      case "new_order_confirmation":
      case "packages_added":
        subject = "üéÖ Order Confirmed - Additional Packages";
        emailHtml = `
          <!DOCTYPE html>
          <html>
          <body style="font-family: Arial, sans-serif;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <h2>üéÖ Order Updated Successfully!</h2>
              <p>Dear ${customerName},</p>
              <p>We've added letter package(s) to your order!</p>
              <p><strong>Order #:</strong> ${orderId.slice(-8)}</p>
              <div style="background-color: #fef3c7; padding: 15px; border-radius: 5px; margin: 20px 0;">
                <strong>‚ö†Ô∏è Important:</strong> Our team will review and confirm these changes before shipping your order.
              </div>
              <p>Thank you for adding more Christmas magic! üéÑ</p>
            </div>
          </body>
          </html>
        `;
        break;

      default:
        return c.json({ error: "Invalid email type" }, 400);
    }

    // Send email via Resend
    const emailResponse = await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${resendApiKey}`,
      },
      body: JSON.stringify({
        from: EMAIL_FROM,
        to: [customerEmail],
        subject: subject,
        html: emailHtml,
      }),
    });

    if (!emailResponse.ok) {
      const errorData = await emailResponse.json();
      throw new Error(errorData.message || "Failed to send email");
    }

    const emailResult = await emailResponse.json();

    // Log the resent email to activity log
    await logEmailActivity(orderId, emailType, customerEmail, subject, emailResult.id);

    return c.json({ 
      success: true, 
      recipient: customerEmail,
      emailId: emailResult.id,
      subject: subject
    });
  } catch (error: any) {
    console.error("Error resending email:", error);
    return c.json({ error: error.message || "Failed to resend email" }, 500);
  }
});

// Delete order (admin only)
app.delete("/make-server-cf244566/orders/:orderId", async (c) => {
  try {
    const orderId = c.req.param("orderId");

    // Remove from orders index
    const allOrderIds: any = (await kv.get("orders:all")) || [];
    const updatedOrderIds = allOrderIds.filter((id: string) => id !== orderId);
    await kv.set("orders:all", updatedOrderIds);

    // Delete order
    await kv.del(`order:${orderId}`);

    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error deleting order:", error);
    return c.json({ error: "Failed to delete order" }, 500);
  }
});

// Bulk import tracking numbers
app.post("/make-server-cf244566/orders/bulk-tracking", async (c) => {
  try {
    const body = await c.req.json();
    const { updates } = body; // Array of {orderId, trackingNumber}

    for (const update of updates) {
      const allOrderIds = (await kv.get("orders:all")) || [];
      const matchingOrderId = allOrderIds.find((id: string) => id.includes(update.orderId));
      
      if (matchingOrderId) {
        const order: any = await kv.get(`order:${matchingOrderId}`);
        if (order) {
          order.trackingNumber = update.trackingNumber;
          order.status = "fulfilled";
          order.updatedAt = new Date().toISOString();
          await kv.set(`order:${matchingOrderId}`, order);
        }
      }
    }

    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error bulk importing tracking:", error);
    return c.json({ error: "Failed to bulk import tracking" }, 500);
  }
});

// ========== DECLINED ORDERS ENDPOINTS ==========

// Get all declined orders (admin only)
app.get("/make-server-cf244566/declines", async (c) => {
  try {
    // Get all decline values from the key-value store (getByPrefix returns values directly)
    const declines = (await kv.getByPrefix("decline:")) || [];

    // Sort by timestamp (newest first)
    declines.sort((a: any, b: any) => {
      const dateA = new Date(a.timestamp || 0).getTime();
      const dateB = new Date(b.timestamp || 0).getTime();
      return dateB - dateA;
    });

    console.log(`üìä Fetched ${declines.length} declined orders`);
    return c.json({ declines });
  } catch (error: any) {
    console.error("Error fetching declined orders:", error);
    return c.json({ error: "Failed to fetch declined orders", details: error.message }, 500);
  }
});

// Get single declined order by ID
app.get("/make-server-cf244566/declines/:declineId", async (c) => {
  try {
    const declineId = c.req.param("declineId");
    const decline = await kv.get(`decline:${declineId}`);

    if (!decline) {
      return c.json({ error: "Declined order not found" }, 404);
    }

    return c.json({ decline });
  } catch (error: any) {
    console.error("Error fetching declined order:", error);
    return c.json({ error: "Failed to fetch declined order" }, 500);
  }
});

// ========== AFFILIATE MANAGEMENT ENDPOINTS ==========

// Helper function to fix tracking URLs (replace any domain with production domain)
function fixTrackingUrl(url: string): string {
  if (!url) return url;
  
  // Parse the URL
  const urlParts = url.split('?');
  if (urlParts.length === 0) return url;
  
  // Replace any domain with santascertifiedletter.com/offer (funnel page)
  const params = urlParts.length > 1 ? '?' + urlParts[1] : '';
  return `https://santascertifiedletter.com/offer${params}`;
}

// Get next affiliate ID
async function getNextAffiliateId(): Promise<string> {
  const counter = (await kv.get("affiliate:id_counter")) || 9003;
  const nextId = counter + 1;
  await kv.set("affiliate:id_counter", nextId);
  return nextId.toString();
}

// Create new affiliate account
app.post("/make-server-cf244566/admin/affiliates", async (c) => {
  try {
    const body = await c.req.json();
    const { name, email, payoutType, payoutAmount } = body;

    const affiliateId = await getNextAffiliateId();

    const affiliate = {
      affiliateId,
      affiliateName: name,
      email,
      status: "active",
      defaultPayoutType: payoutType,
      defaultPayoutAmount: payoutAmount,
      password: Math.random().toString(36).substring(2, 10), // Simple random password
      createdAt: new Date().toISOString(),
    };

    // Save affiliate
    await kv.set(`affiliate:${affiliateId}`, affiliate);

    // Add to affiliates index
    const allAffiliateIds = (await kv.get("affiliates:all")) || [];
    allAffiliateIds.push(affiliateId);
    await kv.set("affiliates:all", allAffiliateIds);

    // Create default tracking link
    const defaultLink = {
      linkId: `link_${affiliateId}_default`,
      affiliateId,
      linkName: "Default Link",
      payoutType,
      payoutAmount,
      isDefault: true,
      trackingUrl: `https://santascertifiedletter.com/offer?ref=${affiliateId}`,
      createdAt: new Date().toISOString(),
    };

    await kv.set(`link:${defaultLink.linkId}`, defaultLink);

    // Add to links index
    const allLinkIds = (await kv.get("links:all")) || [];
    allLinkIds.push(defaultLink.linkId);
    await kv.set("links:all", allLinkIds);

    return c.json({ affiliate, defaultLink });
  } catch (error: any) {
    console.error("Error creating affiliate:", error);
    return c.json({ error: "Failed to create affiliate" }, 500);
  }
});

// Get all affiliates
app.get("/make-server-cf244566/admin/affiliates", async (c) => {
  try {
    const allAffiliateIds = (await kv.get("affiliates:all")) || [];
    
    const affiliates = [];
    for (const affiliateId of allAffiliateIds) {
      const affiliate = await kv.get(`affiliate:${affiliateId}`);
      if (affiliate) {
        affiliates.push(affiliate);
      }
    }

    // Get all links and fix tracking URLs automatically
    const allLinkIds = (await kv.get("links:all")) || [];
    const links = [];
    for (const linkId of allLinkIds) {
      const link: any = await kv.get(`link:${linkId}`);
      if (link) {
        // Fix tracking URL to use production domain
        const fixedUrl = fixTrackingUrl(link.trackingUrl);
        
        // If URL was changed, update it in the database
        if (fixedUrl !== link.trackingUrl) {
          link.trackingUrl = fixedUrl;
          await kv.set(`link:${linkId}`, link);
          console.log(`‚úÖ Fixed tracking URL for link ${linkId}: ${fixedUrl}`);
        }
        
        links.push(link);
      }
    }

    return c.json({ affiliates, links });
  } catch (error: any) {
    console.error("Error fetching affiliates:", error);
    return c.json({ error: "Failed to fetch affiliates" }, 500);
  }
});

// Update affiliate account
app.patch("/make-server-cf244566/admin/affiliates/:affiliateId", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    const body = await c.req.json();

    const affiliate: any = await kv.get(`affiliate:${affiliateId}`);

    if (!affiliate) {
      return c.json({ error: "Affiliate not found" }, 404);
    }

    // Update fields
    if (body.status) affiliate.status = body.status;
    if (body.defaultPayoutType) affiliate.defaultPayoutType = body.defaultPayoutType;
    if (body.defaultPayoutAmount !== undefined) affiliate.defaultPayoutAmount = body.defaultPayoutAmount;

    await kv.set(`affiliate:${affiliateId}`, affiliate);

    return c.json({ affiliate });
  } catch (error: any) {
    console.error("Error updating affiliate:", error);
    return c.json({ error: "Failed to update affiliate" }, 500);
  }
});

// Create affiliate link
app.post("/make-server-cf244566/admin/affiliates/:affiliateId/links", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    const body = await c.req.json();
    const { linkName, payoutType, payoutAmount, customPrice } = body;

    const linkId = `link_${affiliateId}_${Date.now()}`;
    const campaignParam = linkName.toLowerCase().replace(/\s+/g, "-");

    let trackingUrl = `https://santascertifiedletter.com/offer?ref=${affiliateId}`;
    if (!linkName.toLowerCase().includes("default")) {
      trackingUrl += `&campaign=${campaignParam}`;
    }
    // Note: Custom price is stored in the link settings, not in the URL

    const link = {
      linkId,
      affiliateId,
      linkName,
      payoutType,
      payoutAmount,
      customPrice,
      isDefault: false,
      trackingUrl,
      createdAt: new Date().toISOString(),
    };

    await kv.set(`link:${linkId}`, link);

    // Add to links index
    const allLinkIds = (await kv.get("links:all")) || [];
    allLinkIds.push(linkId);
    await kv.set("links:all", allLinkIds);

    return c.json({ link });
  } catch (error: any) {
    console.error("Error creating link:", error);
    return c.json({ error: "Failed to create link" }, 500);
  }
});

// Update affiliate link (payout and price adjustments)
app.patch("/make-server-cf244566/admin/affiliates/links/:linkId", async (c) => {
  try {
    const linkId = c.req.param("linkId");
    const body = await c.req.json();

    const link: any = await kv.get(`link:${linkId}`);

    if (!link) {
      return c.json({ error: "Link not found" }, 404);
    }

    // Update fields
    if (body.payoutType) link.payoutType = body.payoutType;
    if (body.payoutAmount !== undefined) link.payoutAmount = body.payoutAmount;
    if (body.customPrice !== undefined) {
      link.customPrice = body.customPrice;
      
      // Update tracking URL with new price
      const baseUrl = link.trackingUrl.split('?')[0];
      const params = new URLSearchParams(link.trackingUrl.split('?')[1]);
      
      if (body.customPrice) {
        params.set('price', body.customPrice.toString());
      } else {
        params.delete('price');
      }
      
      link.trackingUrl = `${baseUrl}?${params.toString()}`;
    }

    await kv.set(`link:${linkId}`, link);

    return c.json({ link });
  } catch (error: any) {
    console.error("Error updating link:", error);
    return c.json({ error: "Failed to update link" }, 500);
  }
});

// Delete affiliate link
app.delete("/make-server-cf244566/admin/affiliates/links/:linkId", async (c) => {
  try {
    const linkId = c.req.param("linkId");

    // Remove from links index
    const allLinkIds: any = (await kv.get("links:all")) || [];
    const updatedLinkIds = allLinkIds.filter((id: string) => id !== linkId);
    await kv.set("links:all", updatedLinkIds);

    // Delete link
    await kv.del(`link:${linkId}`);

    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error deleting link:", error);
    return c.json({ error: "Failed to delete link" }, 500);
  }
});

// Get custom price for affiliate link (used by checkout page)
app.get("/make-server-cf244566/affiliate/link-price", async (c) => {
  try {
    const ref = c.req.query("ref"); // affiliate ID
    const campaign = c.req.query("campaign"); // optional campaign parameter
    
    if (!ref) {
      return c.json({ customPrice: null });
    }
    
    // Get all links for this affiliate
    const allLinkIds = (await kv.get("links:all")) || [];
    
    // Find the matching link
    for (const linkId of allLinkIds) {
      const link: any = await kv.get(`link:${linkId}`);
      
      if (link && link.affiliateId === ref) {
        // If campaign is specified, match it
        if (campaign) {
          const linkCampaign = link.linkName.toLowerCase().replace(/\s+/g, "-");
          if (linkCampaign === campaign.toLowerCase()) {
            return c.json({ 
              customPrice: link.customPrice || null,
              payoutType: link.payoutType,
              payoutAmount: link.payoutAmount
            });
          }
        } else if (link.isDefault) {
          // Return default link if no campaign specified
          return c.json({ 
            customPrice: link.customPrice || null,
            payoutType: link.payoutType,
            payoutAmount: link.payoutAmount
          });
        }
      }
    }
    
    // No matching link found, return null
    return c.json({ customPrice: null });
  } catch (error: any) {
    console.error("Error getting link price:", error);
    return c.json({ customPrice: null });
  }
});

// Affiliate login
app.post("/make-server-cf244566/affiliate/login", async (c) => {
  try {
    const body = await c.req.json();
    const { affiliateId, password } = body;

    const affiliate: any = await kv.get(`affiliate:${affiliateId}`);

    if (!affiliate || affiliate.password !== password) {
      return c.json({ error: "Invalid credentials" }, 401);
    }

    return c.json({
      affiliateId: affiliate.affiliateId,
      affiliateName: affiliate.affiliateName,
      email: affiliate.email,
    });
  } catch (error: any) {
    console.error("Error during login:", error);
    return c.json({ error: "Login failed" }, 500);
  }
});

// Get affiliate links (for affiliate dashboard)
app.get("/make-server-cf244566/affiliate/:affiliateId/links", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    const allLinkIds = (await kv.get("links:all")) || [];
    
    const links = [];
    for (const linkId of allLinkIds) {
      const link: any = await kv.get(`link:${linkId}`);
      if (link && link.affiliateId === affiliateId) {
        links.push(link);
      }
    }

    return c.json({ links });
  } catch (error: any) {
    console.error("Error fetching affiliate links:", error);
    return c.json({ error: "Failed to fetch links" }, 500);
  }
});

// Track affiliate event (page view, form fill, etc.)
app.post("/make-server-cf244566/affiliate/track-event", async (c) => {
  try {
    const body = await c.req.json();
    const { affiliateId, eventType, subIds } = body;
    // eventType: "page_view", "form_fill", "add_package", "payment_submit", "sale"

    const eventId = `event_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    const event = {
      eventId,
      affiliateId,
      eventType,
      subIds: subIds || {},
      timestamp: new Date().toISOString(),
    };

    await kv.set(`event:${eventId}`, event);

    // Add to events index
    const allEventIds = (await kv.get("events:all")) || [];
    allEventIds.push(eventId);
    await kv.set("events:all", allEventIds);

    // Fire postbacks if configured
    const postbacks = (await kv.get(`postbacks:${affiliateId}`)) || [];
    for (const postback of postbacks) {
      if (postback.enabledEvents.includes(eventType)) {
        // Fire postback
        try {
          // Skip if postback URL is empty or invalid
          if (!postback.postbackUrl || postback.postbackUrl.trim() === '') {
            console.log(`Skipping postback for ${affiliateId} - empty URL`);
            continue;
          }

          let url = postback.postbackUrl
            .replace('{affiliate_id}', affiliateId)
            .replace('{event_type}', eventType)
            .replace('{timestamp}', event.timestamp);

          // Add sub IDs to URL
          Object.entries(subIds || {}).forEach(([key, value]) => {
            url = url.replace(`{${key}}`, value as string);
          });

          const response = await fetch(url);
          
          // Log postback result
          const postbackLog = {
            postbackId: `pb_${Date.now()}`,
            affiliateId,
            eventId,
            eventType,
            url,
            status: response.ok ? "success" : "failed",
            statusCode: response.status,
            timestamp: new Date().toISOString(),
          };

          await kv.set(`postback_log:${postbackLog.postbackId}`, postbackLog);

          // Add to postback logs index
          const allPostbackLogs = (await kv.get("postback_logs:all")) || [];
          allPostbackLogs.push(postbackLog.postbackId);
          await kv.set("postback_logs:all", allPostbackLogs);
        } catch (err) {
          console.error("Error firing postback:", err);
          
          // Log failed postback
          const postbackLog = {
            postbackId: `pb_${Date.now()}`,
            affiliateId,
            eventId,
            eventType,
            url: postback.postbackUrl,
            status: "failed",
            error: err.message,
            timestamp: new Date().toISOString(),
          };

          await kv.set(`postback_log:${postbackLog.postbackId}`, postbackLog);

          const allPostbackLogs = (await kv.get("postback_logs:all")) || [];
          allPostbackLogs.push(postbackLog.postbackId);
          await kv.set("postback_logs:all", allPostbackLogs);
        }
      }
    }

    return c.json({ success: true, eventId });
  } catch (error: any) {
    console.error("Error tracking event:", error);
    return c.json({ error: "Failed to track event" }, 500);
  }
});

// Save postback settings for affiliate
app.post("/make-server-cf244566/admin/affiliates/:affiliateId/postbacks", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    const body = await c.req.json();
    const { postbackUrl, pixelCode, enabledEvents } = body;

    const postback = {
      postbackUrl,
      pixelCode,
      enabledEvents,
      updatedAt: new Date().toISOString(),
    };

    await kv.set(`postbacks:${affiliateId}`, [postback]);

    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error saving postbacks:", error);
    return c.json({ error: "Failed to save postbacks" }, 500);
  }
});

// Get postback settings for affiliate
app.get("/make-server-cf244566/admin/affiliates/:affiliateId/postbacks", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    const postbacks = (await kv.get(`postbacks:${affiliateId}`)) || [];

    return c.json({ postbacks: postbacks[0] || { postbackUrl: "", pixelCode: "", enabledEvents: [] } });
  } catch (error: any) {
    console.error("Error fetching postbacks:", error);
    return c.json({ error: "Failed to fetch postbacks" }, 500);
  }
});

// Get postback logs for affiliate
app.get("/make-server-cf244566/affiliate/:affiliateId/postback-logs", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    const allPostbackLogs = (await kv.get("postback_logs:all")) || [];
    
    const logs = [];
    for (const logId of allPostbackLogs) {
      const log: any = await kv.get(`postback_log:${logId}`);
      if (log && log.affiliateId === affiliateId) {
        logs.push(log);
      }
    }

    // Sort by timestamp (newest first)
    logs.sort((a: any, b: any) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());

    return c.json({ logs });
  } catch (error: any) {
    console.error("Error fetching postback logs:", error);
    return c.json({ error: "Failed to fetch postback logs" }, 500);
  }
});

// Get affiliate stats (orders, revenue, events)
app.get("/make-server-cf244566/affiliate/:affiliateId/stats", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    
    // Get all orders
    const allOrderIds = (await kv.get("orders:all")) || [];
    const affiliateOrders = [];
    
    for (const orderId of allOrderIds) {
      const order: any = await kv.get(`order:${orderId}`);
      if (order && order.affiliateId === affiliateId) {
        affiliateOrders.push(order);
      }
    }

    // Get all events
    const allEventIds = (await kv.get("events:all")) || [];
    const affiliateEvents = [];
    
    for (const eventId of allEventIds) {
      const event: any = await kv.get(`event:${eventId}`);
      if (event && event.affiliateId === affiliateId) {
        affiliateEvents.push(event);
      }
    }

    // Calculate stats
    const pageViews = affiliateEvents.filter((e: any) => e.eventType === "page_view").length;
    const formFills = affiliateEvents.filter((e: any) => e.eventType === "form_fill").length;
    const addPackageClicks = affiliateEvents.filter((e: any) => e.eventType === "add_package").length;
    const paymentSubmits = affiliateEvents.filter((e: any) => e.eventType === "payment_submit").length;
    
    const totalOrders = affiliateOrders.length;
    const totalRevenue = affiliateOrders.reduce((sum: number, order: any) => sum + order.total, 0);
    const totalCommission = affiliateOrders.reduce((sum: number, order: any) => sum + (order.affiliateCommission || 0), 0);

    return c.json({
      pageViews,
      formFills,
      addPackageClicks,
      paymentSubmits,
      sales: totalOrders,
      totalRevenue,
      totalCommission,
      orders: affiliateOrders,
    });
  } catch (error: any) {
    console.error("Error fetching affiliate stats:", error);
    return c.json({ error: "Failed to fetch stats" }, 500);
  }
});

// Export orders as CSV
app.get("/make-server-cf244566/orders/export/csv", async (c) => {
  try {
    const allOrderIds = (await kv.get("orders:all")) || [];
    
    // Fetch all orders
    const orders = [];
    for (const orderId of allOrderIds) {
      const order = await kv.get(`order:${orderId}`);
      if (order) {
        orders.push(order);
      }
    }

    // Sort by date (newest first)
    orders.sort((a: any, b: any) => new Date(b.orderDate).getTime() - new Date(a.orderDate).getTime());

    // Create CSV
    let csv = "Order ID,Order Date,Status,Customer Name,Customer Email,Customer Phone,Address,City,State,ZIP,Number of Packages,Letter Recipients,Shipping Date,Subscription,Total\n";

    for (const order of orders) {
      const recipients = order.letterPackages.map((pkg: any) => 
        `${pkg.childFirstName} ${pkg.childLastName}`
      ).join("; ");

      const address = `${order.customerInfo.address.line1} ${order.customerInfo.address.line2 || ""}`.trim();

      csv += `"${order.orderId}","${new Date(order.orderDate).toLocaleDateString()}","${order.status}","${order.customerInfo.name}","${order.customerInfo.email}","${order.customerInfo.phone}","${address}","${order.customerInfo.address.city}","${order.customerInfo.address.state}","${order.customerInfo.address.postal_code}","${order.numberOfPackages}","${recipients}","${order.shippingDate}","${order.monthlySubscription ? "Yes" : "No"}","${order.total.toFixed(2)}"\n`;
    }

    return new Response(csv, {
      headers: {
        "Content-Type": "text/csv",
        "Content-Disposition": "attachment; filename=santa-letters-orders.csv",
      },
    });
  } catch (error: any) {
    console.error("Error exporting orders:", error);
    return c.json({ error: "Failed to export orders" }, 500);
  }
});

// Add postback configuration for affiliate
app.post("/make-server-cf244566/affiliate/postback-configs", async (c) => {
  try {
    const body = await c.req.json();
    const { affiliateId, eventType, url } = body;

    if (!affiliateId || !eventType || !url) {
      return c.json({ error: "Missing required fields" }, 400);
    }

    const configId = `pbcfg_${Date.now()}`;
    const config = {
      id: configId,
      affiliateId,
      eventType,
      url,
      enabled: true,
      createdAt: new Date().toISOString(),
    };

    await kv.set(`postback_config:${configId}`, config);

    // Add to configs index
    const allConfigIds = (await kv.get("postback_configs:all")) || [];
    allConfigIds.push(configId);
    await kv.set("postback_configs:all", allConfigIds);

    return c.json({ config });
  } catch (error: any) {
    console.error("Error adding postback config:", error);
    return c.json({ error: "Failed to add postback config" }, 500);
  }
});

// Update postback configuration
app.patch("/make-server-cf244566/affiliate/postback-configs/:configId", async (c) => {
  try {
    const configId = c.req.param("configId");
    const body = await c.req.json();

    const config: any = await kv.get(`postback_config:${configId}`);
    if (!config) {
      return c.json({ error: "Config not found" }, 404);
    }

    // Update only the enabled field
    if (body.hasOwnProperty("enabled")) {
      config.enabled = body.enabled;
    }

    await kv.set(`postback_config:${configId}`, config);
    return c.json({ config });
  } catch (error: any) {
    console.error("Error updating postback config:", error);
    return c.json({ error: "Failed to update postback config" }, 500);
  }
});

// Delete postback configuration
app.delete("/make-server-cf244566/affiliate/postback-configs/:configId", async (c) => {
  try {
    const configId = c.req.param("configId");

    await kv.del(`postback_config:${configId}`);

    // Remove from configs index
    const allConfigIds = (await kv.get("postback_configs:all")) || [];
    const updatedConfigIds = allConfigIds.filter((id: string) => id !== configId);
    await kv.set("postback_configs:all", updatedConfigIds);

    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error deleting postback config:", error);
    return c.json({ error: "Failed to delete postback config" }, 500);
  }
});

// Get all postback configs for an affiliate
app.get("/make-server-cf244566/affiliate/postback-configs/:affiliateId", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    const allConfigIds = (await kv.get("postback_configs:all")) || [];
    
    const configs = [];
    for (const configId of allConfigIds) {
      const config: any = await kv.get(`postback_config:${configId}`);
      if (config && config.affiliateId === affiliateId) {
        configs.push(config);
      }
    }

    return c.json({ configs });
  } catch (error: any) {
    console.error("Error fetching postback configs:", error);
    return c.json({ error: "Failed to fetch postback configs" }, 500);
  }
});

// Get affiliate dashboard data
app.get("/make-server-cf244566/affiliate/dashboard", async (c) => {
  try {
    const range = c.req.query("range") || "7days";
    // For now, return empty data - in production, this would fetch real stats
    // This endpoint can be expanded later with real tracking data
    
    return c.json({
      affiliate: {
        affiliateId: "aff_unknown",
        affiliateName: "Affiliate",
        email: "affiliate@example.com",
        trackingUrl: "https://santascertifiedletter.com/?ref=aff_unknown",
        postbackUrl: "",
        pixelCode: "",
        commissionRate: 20,
        status: "active",
        createdAt: new Date().toISOString(),
      },
      stats: {
        totalClicks: 0,
        totalConversions: 0,
        totalRevenue: 0,
        conversionRate: 0,
        commission: 0,
      },
      dailyReports: [],
      hourlyReports: [],
      subIDReports: [],
      eventStats: [],
      invoices: [],
      openBalance: 0,
      prepaidCredit: 0,
      postbackConfigs: [],
    });
  } catch (error: any) {
    console.error("Error fetching dashboard data:", error);
    return c.json({ error: "Failed to fetch dashboard data" }, 500);
  }
});

// Create invoice for affiliate
app.post("/make-server-cf244566/affiliate/invoices", async (c) => {
  try {
    const body = await c.req.json();
    const { affiliateId, periodStart, periodEnd, totalCommission, status, dueDate } = body;

    if (!affiliateId || !periodStart || !periodEnd || totalCommission === undefined) {
      return c.json({ error: "Missing required fields" }, 400);
    }

    const invoiceId = `inv_${Date.now()}`;
    const invoiceNumber = `INV-${new Date().getFullYear()}-${String(Math.floor(Math.random() * 10000)).padStart(4, '0')}`;
    
    const invoice = {
      invoiceId,
      invoiceNumber,
      affiliateId,
      periodStart,
      periodEnd,
      totalCommission,
      amountPaid: 0,
      amountOwed: totalCommission,
      status: status || "pending",
      dueDate: dueDate || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),
      createdAt: new Date().toISOString(),
    };

    await kv.set(`invoice:${invoiceId}`, invoice);

    // Add to invoices index for this affiliate
    const affiliateInvoiceIds = (await kv.get(`affiliate_invoices:${affiliateId}`)) || [];
    affiliateInvoiceIds.push(invoiceId);
    await kv.set(`affiliate_invoices:${affiliateId}`, affiliateInvoiceIds);

    return c.json({ invoice });
  } catch (error: any) {
    console.error("Error creating invoice:", error);
    return c.json({ error: "Failed to create invoice" }, 500);
  }
});

// Update invoice payment status
app.patch("/make-server-cf244566/affiliate/invoices/:invoiceId", async (c) => {
  try {
    const invoiceId = c.req.param("invoiceId");
    const body = await c.req.json();

    const invoice: any = await kv.get(`invoice:${invoiceId}`);
    if (!invoice) {
      return c.json({ error: "Invoice not found" }, 404);
    }

    // Update payment fields
    if (body.amountPaid !== undefined) {
      const overpayment = Math.max(0, body.amountPaid - invoice.totalCommission);
      
      invoice.amountPaid = body.amountPaid;
      invoice.amountOwed = Math.max(0, invoice.totalCommission - body.amountPaid);
      
      // Update status based on payment
      if (invoice.amountOwed === 0) {
        invoice.status = "paid";
        invoice.paidDate = new Date().toISOString();
      } else if (invoice.amountPaid > 0) {
        invoice.status = "partial";
      }

      // Handle overpayment as prepaid credit
      if (overpayment > 0) {
        const affiliateId = invoice.affiliateId;
        const currentCredit = (await kv.get(`prepaid_credit:${affiliateId}`)) || 0;
        await kv.set(`prepaid_credit:${affiliateId}`, currentCredit + overpayment);
      }
    }

    await kv.set(`invoice:${invoiceId}`, invoice);
    return c.json({ invoice });
  } catch (error: any) {
    console.error("Error updating invoice:", error);
    return c.json({ error: "Failed to update invoice" }, 500);
  }
});

// Get invoices for affiliate
app.get("/make-server-cf244566/affiliate/invoices/:affiliateId", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    const invoiceIds = (await kv.get(`affiliate_invoices:${affiliateId}`)) || [];
    
    const invoices = [];
    for (const invoiceId of invoiceIds) {
      const invoice: any = await kv.get(`invoice:${invoiceId}`);
      if (invoice) {
        invoices.push(invoice);
      }
    }

    const openBalance = invoices.reduce((sum, inv) => sum + inv.amountOwed, 0);
    const prepaidCredit = (await kv.get(`prepaid_credit:${affiliateId}`)) || 0;

    return c.json({ invoices, openBalance, prepaidCredit });
  } catch (error: any) {
    console.error("Error fetching invoices:", error);
    return c.json({ error: "Failed to fetch invoices" }, 500);
  }
});

// Delete invoice
app.delete("/make-server-cf244566/affiliate/invoices/:invoiceId", async (c) => {
  try {
    const invoiceId = c.req.param("invoiceId");
    
    const invoice: any = await kv.get(`invoice:${invoiceId}`);
    if (!invoice) {
      return c.json({ error: "Invoice not found" }, 404);
    }

    const affiliateId = invoice.affiliateId;

    // Remove from invoice index
    const affiliateInvoiceIds = (await kv.get(`affiliate_invoices:${affiliateId}`)) || [];
    const updatedInvoiceIds = affiliateInvoiceIds.filter((id: string) => id !== invoiceId);
    await kv.set(`affiliate_invoices:${affiliateId}`, updatedInvoiceIds);

    // Delete the invoice
    await kv.del(`invoice:${invoiceId}`);

    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error deleting invoice:", error);
    return c.json({ error: "Failed to delete invoice" }, 500);
  }
});

// Send Email Notification
app.post("/make-server-cf244566/send-email", async (c) => {
  try {
    const body = await c.req.json();
    const { to, subject, html } = body;

    if (!to || !subject || !html) {
      return c.json({ error: "Missing required fields: to, subject, html" }, 400);
    }

    // Send email using Resend
    const { data, error } = await resend.emails.send({
      from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
      to: [to],
      subject: subject,
      html: html,
    });

    if (error) {
      console.error("Error sending email with Resend:", error);
      return c.json({ error: "Failed to send email", details: error }, 500);
    }

    console.log("Email sent successfully:", data);
    return c.json({ success: true, emailId: data?.id });
  } catch (error: any) {
    console.error("Error in send-email endpoint:", error);
    return c.json({ error: "Failed to send email", details: error.message }, 500);
  }
});

// Send SMS Notification
app.post("/make-server-cf244566/send-sms", async (c) => {
  try {
    const body = await c.req.json();
    const { to, message } = body;

    if (!to || !message) {
      return c.json({ error: "Missing required fields: to, message" }, 400);
    }

    // Twilio credentials
    const accountSid = Deno.env.get("TWILIO_ACCOUNT_SID");
    const authToken = Deno.env.get("TWILIO_AUTH_TOKEN");
    const fromNumber = Deno.env.get("TWILIO_PHONE_NUMBER");

    if (!accountSid || !authToken || !fromNumber) {
      console.error("Twilio credentials not configured");
      return c.json({ error: "SMS service not configured" }, 500);
    }

    // Send SMS using Twilio
    const twilioUrl = `https://api.twilio.com/2010-04-01/Accounts/${accountSid}/Messages.json`;
    const credentials = btoa(`${accountSid}:${authToken}`);

    const formData = new URLSearchParams();
    formData.append("To", to);
    formData.append("From", fromNumber);
    formData.append("Body", message);

    const response = await fetch(twilioUrl, {
      method: "POST",
      headers: {
        Authorization: `Basic ${credentials}`,
        "Content-Type": "application/x-www-form-urlencoded",
      },
      body: formData.toString(),
    });

    if (!response.ok) {
      const errorData = await response.json();
      console.error("Error sending SMS with Twilio:", errorData);
      return c.json({ error: "Failed to send SMS", details: errorData }, 500);
    }

    const data = await response.json();
    console.log("SMS sent successfully:", data);
    return c.json({ success: true, messageSid: data.sid });
  } catch (error: any) {
    console.error("Error in send-sms endpoint:", error);
    return c.json({ error: "Failed to send SMS", details: error.message }, 500);
  }
});

// Send Email Notification
app.post("/make-server-cf244566/send-email", async (c) => {
  try {
    const body = await c.req.json();
    const { to, subject, html } = body;

    if (!to || !subject || !html) {
      return c.json({ error: "Missing required fields: to, subject, html" }, 400);
    }

    const resendApiKey = Deno.env.get("RESEND_API_KEY");
    if (!resendApiKey) {
      console.error("RESEND_API_KEY not configured");
      return c.json({ error: "Email service not configured" }, 500);
    }

    // Send email using Resend API
    const response = await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${resendApiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
        to: [to],
        subject: subject,
        html: html,
      }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      console.error("Error sending email with Resend:", errorData);
      return c.json({ error: "Failed to send email", details: errorData }, 500);
    }

    const data = await response.json();
    console.log("Email sent successfully:", data);
    return c.json({ success: true, emailId: data.id });
  } catch (error: any) {
    console.error("Error in send-email endpoint:", error);
    return c.json({ error: "Failed to send email", details: error.message }, 500);
  }
});

// Send SMS Notification
app.post("/make-server-cf244566/send-sms", async (c) => {
  try {
    const body = await c.req.json();
    const { to, message } = body;

    if (!to || !message) {
      return c.json({ error: "Missing required fields: to, message" }, 400);
    }

    // Twilio credentials
    const accountSid = Deno.env.get("TWILIO_ACCOUNT_SID");
    const authToken = Deno.env.get("TWILIO_AUTH_TOKEN");
    const fromNumber = Deno.env.get("TWILIO_PHONE_NUMBER");

    if (!accountSid || !authToken || !fromNumber) {
      console.error("Twilio credentials not configured");
      return c.json({ error: "SMS service not configured" }, 500);
    }

    // Send SMS using Twilio
    const twilioUrl = `https://api.twilio.com/2010-04-01/Accounts/${accountSid}/Messages.json`;
    const credentials = btoa(`${accountSid}:${authToken}`);

    const formData = new URLSearchParams();
    formData.append("To", to);
    formData.append("From", fromNumber);
    formData.append("Body", message);

    const response = await fetch(twilioUrl, {
      method: "POST",
      headers: {
        Authorization: `Basic ${credentials}`,
        "Content-Type": "application/x-www-form-urlencoded",
      },
      body: formData.toString(),
    });

    if (!response.ok) {
      const errorData = await response.json();
      console.error("Error sending SMS with Twilio:", errorData);
      return c.json({ error: "Failed to send SMS", details: errorData }, 500);
    }

    const data = await response.json();
    console.log("SMS sent successfully:", data);
    return c.json({ success: true, messageSid: data.sid });
  } catch (error: any) {
    console.error("Error in send-sms endpoint:", error);
    return c.json({ error: "Failed to send SMS", details: error.message }, 500);
  }
});

// ========== ADMIN AFFILIATE REPORTING ENDPOINT ==========
app.get("/make-server-cf244566/admin/affiliate-reports", async (c) => {
  try {
    const dateRange = c.req.query("dateRange") || "7days";
    const affiliateId = c.req.query("affiliateId");

    // Helper function to convert UTC date to EST date string
    const toESTDateString = (date: Date): string => {
      return date.toLocaleString("en-US", {
        timeZone: "America/New_York",
        year: "numeric",
        month: "2-digit",
        day: "2-digit"
      }).split(',')[0].split('/').map((p: string) => p.padStart(2, '0')).reverse().join('-');
    };

    // Helper function to get EST hour (0-23)
    const getESTHour = (date: Date): number => {
      const estTime = date.toLocaleString("en-US", {
        timeZone: "America/New_York",
        hour: "2-digit",
        hour12: false
      });
      return parseInt(estTime.split(':')[0]);
    };

    // Get current time in EST
    const nowEST = new Date(new Date().toLocaleString("en-US", { timeZone: "America/New_York" }));
    let startDate: Date;
    
    switch (dateRange) {
      case "today":
        // Start of today in EST
        const todayEST = new Date(nowEST.getFullYear(), nowEST.getMonth(), nowEST.getDate());
        startDate = new Date(todayEST.toLocaleString("en-US", { timeZone: "UTC" }));
        break;
      case "yesterday":
        // Start of yesterday in EST
        const yesterdayEST = new Date(nowEST.getFullYear(), nowEST.getMonth(), nowEST.getDate() - 1);
        startDate = new Date(yesterdayEST.toLocaleString("en-US", { timeZone: "UTC" }));
        const endYesterday = new Date(nowEST.getFullYear(), nowEST.getMonth(), nowEST.getDate() - 1, 23, 59, 59, 999);
        nowEST.setTime(endYesterday.getTime());
        break;
      case "7days":
        startDate = new Date(nowEST.getTime() - 7 * 24 * 60 * 60 * 1000);
        break;
      case "30days":
        startDate = new Date(nowEST.getTime() - 30 * 24 * 60 * 60 * 1000);
        break;
      case "thismonth":
        // First day of current month in EST
        const thisMonthEST = new Date(nowEST.getFullYear(), nowEST.getMonth(), 1);
        startDate = new Date(thisMonthEST.toLocaleString("en-US", { timeZone: "UTC" }));
        break;
      case "lastmonth":
        // First day of last month in EST
        const lastMonthEST = new Date(nowEST.getFullYear(), nowEST.getMonth() - 1, 1);
        startDate = new Date(lastMonthEST.toLocaleString("en-US", { timeZone: "UTC" }));
        // Last day of last month
        const endLastMonth = new Date(nowEST.getFullYear(), nowEST.getMonth(), 0, 23, 59, 59, 999);
        nowEST.setTime(endLastMonth.getTime());
        break;
      default:
        startDate = new Date(nowEST.getTime() - 7 * 24 * 60 * 60 * 1000);
    }

    // Get all orders
    const allOrderIds = (await kv.get("orders:all")) || [];
    const orders = [];
    
    for (const orderId of allOrderIds) {
      const order: any = await kv.get(`order:${orderId}`);
      if (order) {
        const orderDate = new Date(order.orderDate);
        
        // Filter by date range
        if (orderDate >= startDate && orderDate <= nowEST) {
          // Filter by affiliate if specified
          if (!affiliateId || affiliateId === "all" || order.affiliateId === affiliateId) {
            orders.push(order);
          }
        }
      }
    }

    // Get chargebacks
    const allChargebacks = (await kv.get("chargebacks:all")) || [];
    const chargebacks = [];
    
    for (const chargebackId of allChargebacks) {
      const chargeback: any = await kv.get(`chargeback:${chargebackId}`);
      if (chargeback) {
        const cbDate = new Date(chargeback.chargebackDate);
        
        if (cbDate >= startDate && cbDate <= nowEST) {
          if (!affiliateId || affiliateId === "all" || chargeback.affiliateId === affiliateId) {
            chargebacks.push(chargeback);
          }
        }
      }
    }

    // Group data by date and hour (using EST)
    const dailyReportsMap: Record<string, any> = {};
    const hourlyReportsMap: Record<string, any> = {};
    
    // Get clicks from events
    const allEventIds = (await kv.get("events:all")) || [];
    
    for (const eventId of allEventIds) {
      const event: any = await kv.get(`event:${eventId}`);
      if (event) {
        const eventDate = new Date(event.timestamp);
        
        if (eventDate >= startDate && eventDate <= nowEST) {
          if (!affiliateId || affiliateId === "all" || event.affiliateId === affiliateId) {
            // Daily grouping (EST date string)
            const dateKey = toESTDateString(eventDate);
            
            if (!dailyReportsMap[dateKey]) {
              dailyReportsMap[dateKey] = {
                date: dateKey,
                clicks: 0,
                conversions: 0,
                revenue: 0,
                commission: 0,
                refunds: 0,
                chargebacks: 0,
                declines: 0,
              };
            }
            
            if (event.eventType === "page_view") {
              dailyReportsMap[dateKey].clicks++;
            }
            
            // Hourly grouping (EST - only for today)
            if (dateRange === "today") {
              const estHour = getESTHour(eventDate);
              const hourKey = `${estHour}:00`;
              
              if (!hourlyReportsMap[hourKey]) {
                hourlyReportsMap[hourKey] = {
                  hour: hourKey,
                  clicks: 0,
                  conversions: 0,
                  revenue: 0,
                  commission: 0,
                };
              }
              
              if (event.eventType === "page_view") {
                hourlyReportsMap[hourKey].clicks++;
              }
            }
          }
        }
      }
    }

    // Add order data to reports
    let totalRevenue = 0;
    let totalCommission = 0;
    let totalRefunds = 0;
    let totalChargebacks = 0;
    let totalDeclines = 0;

    const orderDetails = [];

    for (const order of orders) {
      const orderDate = new Date(order.orderDate);
      const dateKey = toESTDateString(orderDate);
      
      if (!dailyReportsMap[dateKey]) {
        dailyReportsMap[dateKey] = {
          date: dateKey,
          clicks: 0,
          conversions: 0,
          revenue: 0,
          commission: 0,
          refunds: 0,
          chargebacks: 0,
          declines: 0,
        };
      }

      const isRefunded = order.status === "refunded" || order.status === "canceled-refunded";
      const isChargeback = order.status === "chargeback";
      
      if (!isRefunded && !isChargeback) {
        dailyReportsMap[dateKey].conversions++;
        dailyReportsMap[dateKey].revenue += order.total || 0;
        dailyReportsMap[dateKey].commission += order.affiliateCommission || 0;
        
        totalRevenue += order.total || 0;
        totalCommission += order.affiliateCommission || 0;
      } else if (isRefunded) {
        dailyReportsMap[dateKey].refunds += order.total || 0;
        totalRefunds += order.total || 0;
      } else if (isChargeback) {
        dailyReportsMap[dateKey].chargebacks += order.total || 0;
        totalChargebacks += order.total || 0;
      }

      // Add to hourly if today
      if (dateRange === "today") {
        const estHour = getESTHour(orderDate);
        const hourKey = `${estHour}:00`;
        
        if (!hourlyReportsMap[hourKey]) {
          hourlyReportsMap[hourKey] = {
            hour: hourKey,
            clicks: 0,
            conversions: 0,
            revenue: 0,
            commission: 0,
          };
        }

        if (!isRefunded && !isChargeback) {
          hourlyReportsMap[hourKey].conversions++;
          hourlyReportsMap[hourKey].revenue += order.total || 0;
          hourlyReportsMap[hourKey].commission += order.affiliateCommission || 0;
        }
      }

      // Add to order details
      orderDetails.push({
        orderId: order.orderId,
        sessionId: order.orderId,
        affiliateId: order.affiliateId || "direct",
        affiliateName: order.affiliateName || "Direct Sale",
        customerEmail: order.customerInfo?.email || "",
        packageCount: order.numberOfPackages || 0,
        total: order.total || 0,
        commission: order.affiliateCommission || 0,
        status: isChargeback ? "chargeback" : isRefunded ? "refunded" : "completed",
        orderDate: order.orderDate,
        subIds: order.subIds || {},
      });
    }

    // Convert maps to arrays and sort
    const dailyReports = Object.values(dailyReportsMap).sort((a: any, b: any) => 
      new Date(b.date).getTime() - new Date(a.date).getTime()
    );
    
    const hourlyReports = Object.values(hourlyReportsMap).sort((a: any, b: any) => {
      const aHour = parseInt(a.hour.split(':')[0]);
      const bHour = parseInt(b.hour.split(':')[0]);
      return aHour - bHour;
    });

    // Calculate net revenue
    const netRevenue = totalRevenue - totalRefunds - totalChargebacks;

    return c.json({
      dailyReports,
      hourlyReports,
      orders: orderDetails,
      chargebacks: chargebacks.map((cb: any) => ({
        chargebackId: cb.chargebackId,
        orderId: cb.orderId,
        sessionId: cb.sessionId,
        affiliateId: cb.affiliateId,
        affiliateName: cb.affiliateName,
        amount: cb.amount,
        commission: cb.commission,
        reason: cb.reason,
        stripeChargeId: cb.stripeChargeId,
        chargebackDate: cb.chargebackDate,
        orderDate: cb.orderDate,
        status: cb.status,
      })),
      totalStats: {
        totalRevenue,
        totalCommission,
        totalRefunds,
        totalChargebacks,
        totalDeclines,
        netRevenue,
      },
    });
  } catch (error: any) {
    console.error("Error fetching affiliate reports:", error);
    return c.json({ error: "Failed to fetch reports" }, 500);
  }
});

// Update customer information
app.patch("/make-server-cf244566/orders/:orderId/customer-info", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const { customerInfo } = await c.req.json();

    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    // Update customer info
    order.customerInfo = customerInfo;
    order.updatedAt = new Date().toISOString();
    await kv.set(`order:${orderId}`, order);

    // Send notification email and SMS
    await sendCustomerInfoUpdateNotification(order);

    return c.json({ success: true, order });
  } catch (error: any) {
    console.error("Error updating customer info:", error);
    return c.json({ error: "Failed to update customer information" }, 500);
  }
});

// Cancel subscription
app.post("/make-server-cf244566/subscriptions/:subscriptionId/cancel", async (c) => {
  try {
    if (!stripe) {
      return c.json({ error: "Stripe not configured" }, 503);
    }

    const subscriptionId = c.req.param("subscriptionId");
    const { orderId } = await c.req.json();

    // Cancel in Stripe
    const subscription = await stripe.subscriptions.cancel(subscriptionId);

    // Update order status
    const order: any = await kv.get(`order:${orderId}`);
    if (order) {
      order.status = "canceled-refunded";
      order.updatedAt = new Date().toISOString();
      await kv.set(`order:${orderId}`, order);

      // Send cancellation notification
      await sendSubscriptionCanceledNotification(order);
    }

    return c.json({ success: true, subscription });
  } catch (error: any) {
    console.error("Error canceling subscription:", error);
    return c.json({ error: error.message || "Failed to cancel subscription" }, 500);
  }
});

// Process refund
app.post("/make-server-cf244566/orders/:orderId/refund", async (c) => {
  try {
    if (!stripe) {
      return c.json({ error: "Stripe not configured" }, 503);
    }

    const orderId = c.req.param("orderId");
    const { amount } = await c.req.json();

    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    // Check if order is already refunded
    if (order.status === "canceled-refunded" && order.refundAmount) {
      console.log(`‚ö†Ô∏è Order ${orderId} is already refunded: ${order.refundAmount}`);
      return c.json({ 
        error: "This order has already been refunded", 
        alreadyRefunded: true,
        refundAmount: order.refundAmount 
      }, 400);
    }

    // Process refund in Stripe
    let refund;
    try {
      refund = await stripe.refunds.create({
        payment_intent: order.stripePaymentId,
        amount: Math.round(amount * 100), // Convert to cents
      });
    } catch (stripeError: any) {
      // Handle already refunded error specifically
      if (stripeError.code === 'charge_already_refunded') {
        console.log(`‚ö†Ô∏è Stripe reports charge already refunded for order ${orderId}`);
        
        // Update our records to match Stripe's state
        order.status = "canceled-refunded";
        order.refundAmount = amount;
        order.updatedAt = new Date().toISOString();
        await kv.set(`order:${orderId}`, order);
        
        return c.json({ 
          error: "This charge has already been refunded in Stripe",
          alreadyRefunded: true,
          refundAmount: amount
        }, 400);
      }
      // Re-throw other Stripe errors
      throw stripeError;
    }

    // Add activity log entry
    if (!order.activityLog) order.activityLog = [];
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Refund Processed',
      details: `Refund of ${amount.toFixed(2)} issued via Stripe. Refund ID: ${refund.id}`,
      user: 'Admin',
      stripeUrl: `https://dashboard.stripe.com/payments/${order.stripePaymentId}`
    });
    
    // Update order status
    order.status = "canceled-refunded";
    order.refundAmount = amount;
    order.updatedAt = new Date().toISOString();
    await kv.set(`order:${orderId}`, order);

    // Send refund notification
    await sendRefundNotification(order, amount);

    console.log(`‚úÖ Refund processed successfully for order ${orderId}: ${amount}`);
    return c.json({ success: true, refund });
  } catch (error: any) {
    console.error("Error processing refund:", error);
    return c.json({ error: error.message || "Failed to process refund" }, 500);
  }
});

// Helper function to send customer info update notification
async function sendCustomerInfoUpdateNotification(order: any) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  const twilioAccountSid = Deno.env.get("TWILIO_ACCOUNT_SID");
  const twilioAuthToken = Deno.env.get("TWILIO_AUTH_TOKEN");
  const twilioPhoneNumber = Deno.env.get("TWILIO_PHONE_NUMBER");

  if (resendApiKey) {
    try {
      await fetch("https://api.resend.com/emails", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${resendApiKey}`,
        },
        body: JSON.stringify({
          from: "Santa's Workshop <noreply@updates.santascertifiedletter.com>",
          to: [order.customerInfo.email],
          subject: "Your Order Information Has Been Updated üìù",
          html: `<div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;"><h2 style="color: #dc2626;">üéÖ Order Information Updated</h2><p>Hello ${order.customerInfo.name},</p><p>Your order information has been updated.</p><div style="background-color: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0;"><p><strong>Order:</strong> #${order.orderId.slice(-8)}</p><p><strong>Updated:</strong> ${new Date().toLocaleDateString()}</p></div><p style="color: #dc2626;">üéÑ Keep the magic alive!</p></div>`,
        }),
      });
    } catch (error) {
      console.error("‚ùå Failed to send email:", error);
    }
  }

  if (twilioAccountSid && twilioAuthToken && twilioPhoneNumber && order.customerInfo.phone) {
    try {
      const auth = btoa(`${twilioAccountSid}:${twilioAuthToken}`);
      await fetch(`https://api.twilio.com/2010-04-01/Accounts/${twilioAccountSid}/Messages.json`, {
        method: "POST",
        headers: {
          "Authorization": `Basic ${auth}`,
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: new URLSearchParams({
          To: order.customerInfo.phone,
          From: twilioPhoneNumber,
          Body: `üéÖ Your Santa letter order info has been updated. Order #${order.orderId.slice(-8)}`,
        }),
      });
    } catch (error) {
      console.error("‚ùå Failed to send SMS:", error);
    }
  }
}

// Helper function to send subscription canceled notification
async function sendSubscriptionCanceledNotification(order: any) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  const twilioAccountSid = Deno.env.get("TWILIO_ACCOUNT_SID");
  const twilioAuthToken = Deno.env.get("TWILIO_AUTH_TOKEN");
  const twilioPhoneNumber = Deno.env.get("TWILIO_PHONE_NUMBER");

  if (resendApiKey) {
    try {
      await fetch("https://api.resend.com/emails", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${resendApiKey}`,
        },
        body: JSON.stringify({
          from: "Santa's Workshop <noreply@updates.santascertifiedletter.com>",
          to: [order.customerInfo.email],
          subject: "Your Subscription Has Been Canceled",
          html: `<div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;"><h2 style="color: #dc2626;">üéÖ Subscription Canceled</h2><p>Hello ${order.customerInfo.name},</p><p>Your Santa's Magical Adventures subscription has been canceled.</p><div style="background-color: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0;"><p><strong>Order:</strong> #${order.orderId.slice(-8)}</p><p><strong>Subscription ID:</strong> ${order.subscriptionId}</p></div><p>You will not be charged for any future months.</p><p style="color: #dc2626;">üéÑ We hope to see you again next year!</p></div>`,
        }),
      });
    } catch (error) {
      console.error("‚ùå Failed to send email:", error);
    }
  }

  if (twilioAccountSid && twilioAuthToken && twilioPhoneNumber && order.customerInfo.phone) {
    try {
      const auth = btoa(`${twilioAccountSid}:${twilioAuthToken}`);
      await fetch(`https://api.twilio.com/2010-04-01/Accounts/${twilioAccountSid}/Messages.json`, {
        method: "POST",
        headers: {
          "Authorization": `Basic ${auth}`,
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: new URLSearchParams({
          To: order.customerInfo.phone,
          From: twilioPhoneNumber,
          Body: `üéÖ Your Santa subscription has been canceled. No future charges will be made.`,
        }),
      });
    } catch (error) {
      console.error("‚ùå Failed to send SMS:", error);
    }
  }
}

// Helper function to send refund notification
async function sendRefundNotification(order: any, amount: number) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  const twilioAccountSid = Deno.env.get("TWILIO_ACCOUNT_SID");
  const twilioAuthToken = Deno.env.get("TWILIO_AUTH_TOKEN");
  const twilioPhoneNumber = Deno.env.get("TWILIO_PHONE_NUMBER");

  if (resendApiKey) {
    try {
      await fetch("https://api.resend.com/emails", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${resendApiKey}`,
        },
        body: JSON.stringify({
          from: "Santa's Workshop <noreply@updates.santascertifiedletter.com>",
          to: [order.customerInfo.email],
          subject: `Refund Processed: ${amount.toFixed(2)} üíµ`,
          html: `<div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;"><h2 style="color: #dc2626;">üíµ Refund Processed</h2><p>Hello ${order.customerInfo.name},</p><p>Your refund has been processed successfully.</p><div style="background-color: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; border: 2px solid #16a34a;"><p style="font-size: 24px; margin: 0; color: #16a34a;"><strong>${amount.toFixed(2)}</strong></p><p style="margin: 5px 0 0 0;">Refund Amount</p></div><div style="background-color: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0;"><p><strong>Order:</strong> #${order.orderId.slice(-8)}</p><p><strong>Refunded:</strong> ${new Date().toLocaleDateString()}</p></div><p>The refund will appear on your original payment method within 5-10 business days.</p><p style="color: #dc2626;">üéÑ Thank you!</p></div>`,
        }),
      });
    } catch (error) {
      console.error("‚ùå Failed to send refund email:", error);
    }
  }

  if (twilioAccountSid && twilioAuthToken && twilioPhoneNumber && order.customerInfo.phone) {
    try {
      const auth = btoa(`${twilioAccountSid}:${twilioAuthToken}`);
      await fetch(`https://api.twilio.com/2010-04-01/Accounts/${twilioAccountSid}/Messages.json`, {
        method: "POST",
        headers: {
          "Authorization": `Basic ${auth}`,
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: new URLSearchParams({
          To: order.customerInfo.phone,
          From: twilioPhoneNumber,
          Body: `üíµ Refund of ${amount.toFixed(2)} processed for order #${order.orderId.slice(-8)}. Funds will appear in 5-10 business days.`,
        }),
      });
    } catch (error) {
      console.error("‚ùå Failed to send SMS:", error);
    }
  }
}

// Update Next Billing Date (without charging)
app.post("/make-server-cf244566/admin/update-billing-date", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }

  try {
    const { orderId, nextBillingDate } = await c.req.json();
    
    console.log(`üìÖ Updating next billing date for order: ${orderId} to ${nextBillingDate}`);
    
    // Get order
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!order.subscriptionId) {
      return c.json({ error: "Order does not have a subscription" }, 400);
    }
    
    // Validate date
    if (!nextBillingDate) {
      return c.json({ error: "Next billing date is required" }, 400);
    }

    const nextBillingTimestamp = Math.floor(new Date(nextBillingDate).getTime() / 1000);
    const now = Math.floor(Date.now() / 1000);
    
    // Get subscription from Stripe
    const subscription = await stripe.subscriptions.retrieve(order.subscriptionId);
    
    if (subscription.status === "canceled") {
      return c.json({ error: "Subscription is already canceled" }, 400);
    }
    
    // If date is today or in the past, charge immediately
    if (nextBillingTimestamp <= now) {
      console.log(`üîî Billing date is today or past - charging immediately`);
      
      // Get subscription price from order (configurable per subscription)
      const subscriptionPrice = order.subscriptionPrice || 12.00;
      const subscriptionProductName = order.subscriptionProductName || "Santa's Magical Journey";
      
      // Create an invoice item for immediate billing
      await stripe.invoiceItems.create({
        customer: subscription.customer as string,
        amount: Math.round(subscriptionPrice * 100), // Convert to cents
        currency: 'usd',
        description: `${subscriptionProductName} - Monthly Letter`,
      });
      
      // Create and finalize the invoice
      const invoice = await stripe.invoices.create({
        customer: subscription.customer as string,
        auto_advance: true,
        description: `Immediate billing for subscription ${order.subscriptionId}`,
        metadata: {
          orderId: orderId,
          immediateCharge: 'true',
        },
      });
      
      // Finalize the invoice
      const finalizedInvoice = await stripe.invoices.finalizeInvoice(invoice.id);
      
      // Wait for payment to process
      await new Promise(resolve => setTimeout(resolve, 1500));
      
      // Retrieve the invoice to get final payment status
      const paidInvoice = await stripe.invoices.retrieve(finalizedInvoice.id);
      
      if (paidInvoice.status !== 'paid') {
        console.error(`‚ö†Ô∏è Invoice not paid. Status: ${paidInvoice.status}`);
        return c.json({ error: `Payment failed. Invoice status: ${paidInvoice.status}` }, 400);
      }
      
      console.log(`‚úÖ Immediate charge successful: ${(paidInvoice.amount_paid / 100).toFixed(2)}`);
      
      // Calculate next billing date based on billing interval
      const billingIntervalDays = order.billingIntervalDays || 30;
      const nextBilling = new Date();
      nextBilling.setDate(nextBilling.getDate() + billingIntervalDays);
      
      // Update subscription's next billing date
      const nextBillingTimestamp = Math.floor(nextBilling.getTime() / 1000);
      await stripe.subscriptions.update(order.subscriptionId, {
        trial_end: nextBillingTimestamp,
        proration_behavior: 'none',
      });
      
      // Update order in database
      order.subscriptionNextBillingDate = nextBilling.toISOString();
      order.successfulCharges = (order.successfulCharges || 0) + 1;
      order.subscriptionMonthsActive = order.successfulCharges;
      order.updatedAt = new Date().toISOString();
      
      // Add to activity log
      if (!order.activityLog) {
        order.activityLog = [];
      }
      order.activityLog.push({
        timestamp: new Date().toISOString(),
        action: 'Manual Charge - Immediate',
        details: `Charged ${(paidInvoice.amount_paid / 100).toFixed(2)}. Month ${order.successfulCharges}. Next billing: ${nextBilling.toLocaleDateString()}`,
        user: 'Admin',
        stripeUrl: `https://dashboard.stripe.com/invoices/${paidInvoice.id}`
      });
      
      await kv.set(`order:${orderId}`, order);
      
      // Create a new order for this month's fulfillment
      const allOrderIds = (await kv.get("orders:all")) || [];
      const newOrderId = `ord_${Date.now()}_${Math.random().toString(36).substring(7)}`;
      const newOrder = {
        orderId: newOrderId,
        parentOrderId: order.orderId,
        subscriptionId: order.subscriptionId,
        sessionId: paidInvoice.id,
        stripePaymentId: paidInvoice.payment_intent,
        stripeCheckoutUrl: `https://dashboard.stripe.com/invoices/${paidInvoice.id}`,
        orderDate: new Date().toISOString(),
        status: "pending",
        total: paidInvoice.amount_paid / 100,
        customerInfo: order.customerInfo,
        letterPackages: order.letterPackages,
        numberOfPackages: order.numberOfPackages,
        shippingDate: "",
        monthlySubscription: false,
        subscriptionRecurringOrder: true,
        subscriptionMonth: order.successfulCharges,
        subscriptionProductName: subscriptionProductName,
        affiliateId: order.affiliateId,
        affiliateName: order.affiliateName,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        activityLog: [{
          timestamp: new Date().toISOString(),
          action: 'Order Created',
          details: `Recurring subscription order - Month ${order.successfulCharges} (Manual Charge)`,
          user: 'Admin'
        }]
      };
      
      await kv.set(`order:${newOrderId}`, newOrder);
      allOrderIds.push(newOrderId);
      await kv.set("orders:all", allOrderIds);
      
      console.log(`‚úÖ Created new order ${newOrderId} for manual subscription charge`);
      
      // Send notification email
      if (order.customerInfo?.email) {
        try {
          const resendApiKey = Deno.env.get("RESEND_API_KEY");
          if (resendApiKey) {
            await fetch("https://api.resend.com/emails", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${resendApiKey}`,
              },
              body: JSON.stringify({
                from: "Santa's Workshop <noreply@updates.santascertifiedletter.com>",
                to: [order.customerInfo.email],
                subject: "üéÖ Your Monthly Santa Letter is On The Way!",
                html: `
                  <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                    <h2 style="color: #16a34a;">üéÖ Payment Received!</h2>
                    <p>Hello ${order.customerInfo.name},</p>
                    <p>Your monthly subscription payment has been processed successfully.</p>
                    <div style="background-color: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; border: 2px solid #16a34a;">
                      <p style="font-size: 24px; margin: 0; color: #16a34a;"><strong>$12.00</strong></p>
                      <p style="margin: 5px 0 0 0;">Monthly Subscription</p>
                    </div>
                    <p>Your monthly letter from Santa will be on its way soon!</p>
                    <p>Next billing date: <strong>${nextBilling.toLocaleDateString()}</strong></p>
                    <p style="color: #dc2626;">üéÑ Thank you for keeping the magic alive!</p>
                  </div>
                `,
              }),
            });
          }
        } catch (error) {
          console.error("‚ùå Failed to send notification email:", error);
        }
      }
      
      return c.json({ 
        success: true,
        invoiceId: paidInvoice.id,
        amountCharged: (paidInvoice.amount_paid / 100).toFixed(2),
        nextBillingDate: nextBilling.toISOString(),
        message: "Subscription charged successfully"
      });
    }

    // Date is in the future - just update the billing date without charging
    await stripe.subscriptions.update(order.subscriptionId, {
      trial_end: nextBillingTimestamp,
      proration_behavior: 'none',
    });

    console.log(`‚úÖ Updated Stripe subscription billing anchor to: ${nextBillingDate}`);

    // Update order in database
    order.subscriptionNextBillingDate = nextBillingDate;
    order.updatedAt = new Date().toISOString();
    
    // Add to activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Next Billing Date Updated',
      details: `Next billing date set to ${new Date(nextBillingDate).toLocaleDateString()}`,
      user: 'Admin'
    });

    await kv.set(`order:${orderId}`, order);
    
    console.log(`‚úÖ Updated order in database with new billing date: ${nextBillingDate}`);

    return c.json({ 
      success: true,
      nextBillingDate: nextBillingDate,
      amountCharged: "0.00",
      message: "Next billing date updated successfully (no charge)"
    });
  } catch (error: any) {
    console.error("Error updating billing date:", error);
    return c.json({ 
      error: error.message || "Failed to update billing date" 
    }, 500);
  }
});

// Manual Subscription Billing - Charge subscriber immediately
app.post("/make-server-cf244566/admin/charge-subscription", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }

  try {
    const { orderId, customBillingDate, skipRecentChargeCheck } = await c.req.json();
    
    console.log(`üîî Manual billing requested for order: ${orderId}`);
    
    // Get order
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!order.subscriptionId) {
      return c.json({ error: "Order does not have a subscription" }, 400);
    }
    
    // Check if charged in last 30 days (protection against double-charging)
    if (!skipRecentChargeCheck && order.lastChargeDate) {
      const daysSinceLastCharge = (Date.now() - new Date(order.lastChargeDate).getTime()) / (1000 * 60 * 60 * 24);
      if (daysSinceLastCharge < 30) {
        console.warn(`‚ö†Ô∏è Order was charged ${daysSinceLastCharge.toFixed(1)} days ago - within 30 days`);
        return c.json({ 
          error: "RECENT_CHARGE",
          recentCharge: true,
          lastChargeDate: order.lastChargeDate,
          daysSinceCharge: Math.floor(daysSinceLastCharge),
          message: `This subscription was charged ${Math.floor(daysSinceLastCharge)} days ago. Are you sure you want to charge again?`
        }, 400);
      }
    }
    
    // Get subscription from Stripe
    const subscription = await stripe.subscriptions.retrieve(order.subscriptionId);
    
    if (subscription.status === "canceled") {
      return c.json({ error: "Subscription is already canceled" }, 400);
    }
    
    // Get customer to verify default payment method
    const customer = await stripe.customers.retrieve(subscription.customer as string);
    
    // Ensure customer has a default payment method
    if (!subscription.default_payment_method && !customer.deleted && !customer.invoice_settings?.default_payment_method) {
      console.error(`‚ö†ÔøΩÔøΩ No default payment method found for customer ${subscription.customer}`);
      return c.json({ 
        error: "No payment method on file. Customer needs to update their payment information.",
        details: "Customer does not have a default payment method attached."
      }, 400);
    }
    
    // Get subscription price from order (configurable per subscription)
    const subscriptionPrice = order.subscriptionPrice || 12.00;
    const subscriptionProductName = order.subscriptionProductName || "Santa's Magical Journey";
    
    console.log(`üí≥ Charging subscription: ${subscriptionPrice.toFixed(2)}`);
    
    // Get the default payment method
    const defaultPaymentMethod = subscription.default_payment_method || 
                                  (!customer.deleted && customer.invoice_settings?.default_payment_method) || 
                                  null;
    
    if (!defaultPaymentMethod) {
      throw new Error("No default payment method found for customer");
    }
    
    console.log(`üí≥ Using payment method: ${defaultPaymentMethod}`);
    
    // APPROACH: Use PaymentIntent for immediate one-time charge
    // This ensures the exact amount is charged right away (not using invoices which can have $0 issues)
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(subscriptionPrice * 100), // Convert to cents
      currency: 'usd',
      customer: subscription.customer as string,
      payment_method: defaultPaymentMethod as string,
      off_session: true, // Allows charging without customer present
      confirm: true, // Automatically confirm and charge
      description: `${subscriptionProductName} - Manual Charge`,
      metadata: {
        orderId: orderId,
        manualCharge: 'true',
        subscriptionId: order.subscriptionId,
      },
    });
    
    console.log(`üí≥ Payment Intent created: ${paymentIntent.id}`);
    console.log(`üí∞ Payment status: ${paymentIntent.status}, Amount: ${(paymentIntent.amount / 100).toFixed(2)}`);
    
    // Check payment status
    if (paymentIntent.status !== 'succeeded') {
      console.error(`‚ö†Ô∏è Payment did not succeed. Status: ${paymentIntent.status}`);
      
      // Log the declined charge
      order.declinedCharges = (order.declinedCharges || 0) + 1;
      order.updatedAt = new Date().toISOString();
      
      if (!order.activityLog) {
        order.activityLog = [];
      }
      order.activityLog.push({
        timestamp: new Date().toISOString(),
        action: 'Subscription Charge Declined (Charge Now)',
        details: `Charge of ${subscriptionPrice.toFixed(2)} declined. Status: ${paymentIntent.status}. PaymentIntent: ${paymentIntent.id}`,
        user: 'Admin',
        stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntent.id}`
      });
      
      await kv.set(`order:${orderId}`, order);
      
      return c.json({ 
        error: `Payment failed. Status: ${paymentIntent.status}`,
        paymentIntentId: paymentIntent.id,
        stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntent.id}`
      }, 400);
    }
    
    // Create a mock invoice object for the rest of the code
    const paidInvoice = { 
      id: paymentIntent.id, 
      status: 'paid',
      amount_paid: paymentIntent.amount 
    };
    
    // Calculate next billing date
    let nextBillingDate;
    if (customBillingDate) {
      nextBillingDate = customBillingDate;
    } else {
      // Use billing interval to calculate next date
      const billingIntervalDays = order.billingIntervalDays || 30;
      const nextBilling = new Date();
      nextBilling.setDate(nextBilling.getDate() + billingIntervalDays);
      nextBillingDate = nextBilling.toISOString();
    }
    
    const billingTimestamp = Math.floor(new Date(nextBillingDate).getTime() / 1000);
    const now = Math.floor(Date.now() / 1000);
    
    if (billingTimestamp > now) {
      // Set trial_end to update next billing date
      await stripe.subscriptions.update(order.subscriptionId, {
        trial_end: billingTimestamp,
        proration_behavior: 'none',
      });
      
      console.log(`‚úÖ Updated next billing date to: ${nextBillingDate}`);
    }
    
    // Update order with new billing date and increment counters
    order.subscriptionNextBillingDate = nextBillingDate;
    order.successfulCharges = (order.successfulCharges || 0) + 1;
    order.subscriptionMonthsActive = order.successfulCharges;
    order.lastChargeDate = new Date().toISOString(); // Track when last charged for 30-day protection
    order.updatedAt = new Date().toISOString();
    
    // Add to activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Subscription Charged (Charge Now)',
      details: `Charged ${subscriptionPrice.toFixed(2)}. Month ${order.successfulCharges}. Next billing: ${new Date(nextBillingDate).toLocaleDateString()}. PaymentIntent: ${paidInvoice.id}`,
      user: 'Admin',
      stripeUrl: `https://dashboard.stripe.com/payments/${paidInvoice.id}`
    });
    
    await kv.set(`order:${orderId}`, order);
    
    // Create a new order for this month's fulfillment
    console.log(`üì¶ Creating fulfillment order. Subscription letters count: ${(order.subscriptionLetters || []).length}`);
    console.log(`üì¶ Subscription letters data:`, JSON.stringify(order.subscriptionLetters));
    
    const allOrderIds = (await kv.get("orders:all")) || [];
    const newOrderId = `ord_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    const newOrder = {
      orderId: newOrderId,
      parentOrderId: order.orderId,
      subscriptionId: order.subscriptionId,
      sessionId: paidInvoice.id,
      stripePaymentId: paidInvoice.id,
      stripeCheckoutUrl: `https://dashboard.stripe.com/payments/${paidInvoice.id}`,
      orderDate: new Date().toISOString(),
      status: "pending",
      total: paidInvoice.amount_paid / 100,
      customerInfo: order.customerInfo,
      letterPackages: order.letterPackages,
      numberOfPackages: order.numberOfPackages,
      letters: order.subscriptionLetters || [], // Copy subscription letter data for fulfillment
      shippingDate: "",
      monthlySubscription: false,
      subscriptionRecurringOrder: true,
      subscriptionMonth: order.successfulCharges,
      subscriptionProductName: subscriptionProductName,
      affiliateId: order.affiliateId,
      affiliateName: order.affiliateName,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      activityLog: [{
        timestamp: new Date().toISOString(),
        action: 'Order Created',
        details: `Recurring subscription order - Month ${order.successfulCharges} (Charge Now). Copied ${(order.subscriptionLetters || []).length} letter(s) from subscription.`,
        user: 'Admin'
      }]
    };
    
    await kv.set(`order:${newOrderId}`, newOrder);
    allOrderIds.push(newOrderId);
    await kv.set("orders:all", allOrderIds);
    
    console.log(`‚úÖ Created new order ${newOrderId} for "Charge Now"`);
    
    console.log(`‚úÖ Manual charge successful: ${paidInvoice.id}, Amount: ${(paidInvoice.amount_paid / 100).toFixed(2)}`);
    
    // Send notification email
    if (order.customerInfo?.email) {
      try {
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        if (resendApiKey) {
          await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${resendApiKey}`,
            },
            body: JSON.stringify({
              from: "Santa's Workshop <noreply@updates.santascertifiedletter.com>",
              to: [order.customerInfo.email],
              subject: "üéÖ Your Monthly Santa Letter is On The Way!",
              html: `
                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                  <h2 style="color: #16a34a;">üéÖ Payment Received!</h2>
                  <p>Hello ${order.customerInfo.name},</p>
                  <p>Your monthly subscription payment has been processed successfully.</p>
                  <div style="background-color: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; border: 2px solid #16a34a;">
                    <p style="font-size: 24px; margin: 0; color: #16a34a;"><strong>$12.00</strong></p>
                    <p style="margin: 5px 0 0 0;">Monthly Subscription</p>
                  </div>
                  <p>Your monthly letter from Santa will be on its way soon!</p>
                  ${customBillingDate ? `<p>Next billing date: <strong>${new Date(customBillingDate).toLocaleDateString()}</strong></p>` : ''}
                  <p style="color: #dc2626;">üéÑ Thank you for keeping the magic alive!</p>
                </div>
              `,
            }),
          });
        }
      } catch (error) {
        console.error("‚ùå Failed to send notification email:", error);
      }
    }
    
    return c.json({ 
      success: true, 
      paymentIntentId: paidInvoice.id,
      amountCharged: (paidInvoice.amount_paid / 100).toFixed(2),
      nextBillingDate: customBillingDate || order.subscriptionNextBillingDate,
      stripeUrl: `https://dashboard.stripe.com/payments/${paidInvoice.id}`
    });
  } catch (error: any) {
    console.error("ÔøΩÔøΩ Error charging subscription:", error);
    return c.json({ 
      error: error.message || "Failed to charge subscription",
      details: error.toString(),
    }, 500);
  }
});

// Update Billing Interval for Subscription
app.post("/make-server-cf244566/admin/update-billing-interval", async (c) => {
  try {
    const { orderId, billingIntervalDays } = await c.req.json();
    
    console.log(`üîÑ Updating billing interval for order: ${orderId} to ${billingIntervalDays} days`);
    
    // Get order
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!order.subscriptionId) {
      return c.json({ error: "Order does not have a subscription" }, 400);
    }
    
    // Validate interval
    if (!billingIntervalDays || billingIntervalDays < 1 || billingIntervalDays > 365) {
      return c.json({ error: "Billing interval must be between 1 and 365 days" }, 400);
    }
    
    // Update order
    order.billingIntervalDays = billingIntervalDays;
    order.updatedAt = new Date().toISOString();
    
    // Add to activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Billing Interval Updated',
      details: `Billing interval set to ${billingIntervalDays} days`,
      user: 'Admin'
    });
    
    await kv.set(`order:${orderId}`, order);
    
    console.log(`‚úÖ Billing interval updated to ${billingIntervalDays} days`);
    
    return c.json({ 
      success: true,
      billingIntervalDays: billingIntervalDays,
      message: "Billing interval updated successfully"
    });
  } catch (error: any) {
    console.error("Error updating billing interval:", error);
    return c.json({ 
      error: error.message || "Failed to update billing interval" 
    }, 500);
  }
});

// Update Subscription Price
app.post("/make-server-cf244566/admin/update-subscription-price", async (c) => {
  try {
    const { orderId, subscriptionPrice } = await c.req.json();
    
    console.log(`üí∞ Updating subscription price for order: ${orderId} to ${subscriptionPrice}`);
    
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!order.subscriptionId) {
      return c.json({ error: "Order does not have a subscription" }, 400);
    }
    
    if (!subscriptionPrice || subscriptionPrice < 0.50 || subscriptionPrice > 999.99) {
      return c.json({ error: "Subscription price must be between $0.50 and $999.99" }, 400);
    }
    
    const oldPrice = order.subscriptionPrice || 12.00;
    order.subscriptionPrice = parseFloat(subscriptionPrice);
    order.updatedAt = new Date().toISOString();
    
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Subscription Price Updated',
      details: `Price changed from ${oldPrice.toFixed(2)} to ${parseFloat(subscriptionPrice).toFixed(2)}`,
      user: 'Admin'
    });
    
    await kv.set(`order:${orderId}`, order);
    
    console.log(`‚úÖ Subscription price updated to ${subscriptionPrice}`);
    
    return c.json({ 
      success: true,
      subscriptionPrice: parseFloat(subscriptionPrice),
      message: "Subscription price updated successfully"
    });
  } catch (error: any) {
    console.error("Error updating subscription price:", error);
    return c.json({ 
      error: error.message || "Failed to update subscription price" 
    }, 500);
  }
});

// Update Subscription Product Name
app.post("/make-server-cf244566/admin/update-subscription-product", async (c) => {
  try {
    const { orderId, subscriptionProductName } = await c.req.json();
    
    console.log(`üì¶ Updating subscription product name for order: ${orderId}`);
    
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!order.subscriptionId) {
      return c.json({ error: "Order does not have a subscription" }, 400);
    }
    
    if (!subscriptionProductName || subscriptionProductName.trim().length === 0) {
      return c.json({ error: "Product name cannot be empty" }, 400);
    }
    
    if (subscriptionProductName.length > 100) {
      return c.json({ error: "Product name must be 100 characters or less" }, 400);
    }
    
    const oldProductName = order.subscriptionProductName || "Santa's Magical Journey";
    order.subscriptionProductName = subscriptionProductName.trim();
    order.updatedAt = new Date().toISOString();
    
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Subscription Product Updated',
      details: `Product changed from "${oldProductName}" to "${subscriptionProductName.trim()}"`,
      user: 'Admin'
    });
    
    await kv.set(`order:${orderId}`, order);
    
    console.log(`‚úÖ Subscription product name updated`);
    
    return c.json({ 
      success: true,
      subscriptionProductName: subscriptionProductName.trim(),
      message: "Subscription product name updated successfully"
    });
  } catch (error: any) {
    console.error("Error updating subscription product name:", error);
    return c.json({ 
      error: error.message || "Failed to update subscription product name" 
    }, 500);
  }
});

// Admin Affiliate Reporting Endpoint
app.get("/make-server-cf244566/admin/affiliate-reports", async (c) => {
  try {
    const dateRange = c.req.query("dateRange") || "7days";
    const affiliateId = c.req.query("affiliateId");

    // Calculate date range
    const now = new Date();
    let startDate = new Date();
    
    switch (dateRange) {
      case "today":
        startDate.setHours(0, 0, 0, 0);
        break;
      case "yesterday":
        startDate.setDate(startDate.getDate() - 1);
        startDate.setHours(0, 0, 0, 0);
        now.setDate(now.getDate() - 1);
        now.setHours(23, 59, 59, 999);
        break;
      case "7days":
        startDate.setDate(startDate.getDate() - 7);
        break;
      case "30days":
        startDate.setDate(startDate.getDate() - 30);
        break;
      case "thismonth":
        startDate.setDate(1);
        startDate.setHours(0, 0, 0, 0);
        break;
      case "lastmonth":
        const lastMonth = new Date();
        lastMonth.setMonth(lastMonth.getMonth() - 1);
        startDate = new Date(lastMonth.getFullYear(), lastMonth.getMonth(), 1);
        now.setMonth(now.getMonth() - 1);
        now.setDate(1);
        now.setMonth(now.getMonth() + 1);
        now.setDate(0);
        now.setHours(23, 59, 59, 999);
        break;
    }

    // Fetch all orders
    const allOrderIds = (await kv.get("orders:all")) || [];
    const allOrders: any[] = [];
    
    for (const orderId of allOrderIds) {
      const order: any = await kv.get(`order:${orderId}`);
      if (order) {
        allOrders.push(order);
      }
    }

    // Filter orders by date range and affiliate
    const filteredOrders = allOrders.filter((order: any) => {
      const orderDate = new Date(order.orderDate);
      const inDateRange = orderDate >= startDate && orderDate <= now;
      const matchesAffiliate = !affiliateId || affiliateId === "all" || order.affiliateId === affiliateId;
      return inDateRange && matchesAffiliate;
    });

    // Fetch all events
    const allEventIds = (await kv.get("events:all")) || [];
    const allEvents: any[] = [];
    
    for (const eventId of allEventIds) {
      const event: any = await kv.get(`event:${eventId}`);
      if (event) {
        allEvents.push(event);
      }
    }

    // Filter events by date range and affiliate
    const filteredEvents = allEvents.filter((event: any) => {
      const eventDate = new Date(event.timestamp);
      const inDateRange = eventDate >= startDate && eventDate <= now;
      const matchesAffiliate = !affiliateId || affiliateId === "all" || event.affiliateId === affiliateId;
      return inDateRange && matchesAffiliate;
    });

    // Get affiliate names
    const affiliateNames: Record<string, string> = {};
    const allAffiliateIds = (await kv.get("affiliates:all")) || [];
    for (const affId of allAffiliateIds) {
      const affiliate: any = await kv.get(`affiliate:${affId}`);
      if (affiliate) {
        affiliateNames[affId] = affiliate.affiliateName;
      }
    }

    // Fetch chargebacks
    const allChargebacks = (await kv.get("chargebacks:all")) || [];
    const chargebackDetails: any[] = [];
    
    for (const chargebackId of allChargebacks) {
      const chargeback: any = await kv.get(`chargeback:${chargebackId}`);
      if (chargeback) {
        const chargebackDate = new Date(chargeback.chargebackDate);
        const inDateRange = chargebackDate >= startDate && chargebackDate <= now;
        const matchesAffiliate = !affiliateId || affiliateId === "all" || chargeback.affiliateId === affiliateId;
        
        if (inDateRange && matchesAffiliate) {
          chargebackDetails.push(chargeback);
        }
      }
    }

    // Calculate daily reports
    const dailyMap: Record<string, any> = {};
    
    // Process clicks from events
    filteredEvents.forEach((event: any) => {
      const date = new Date(event.timestamp).toISOString().split('T')[0];
      if (!dailyMap[date]) {
        dailyMap[date] = { date, clicks: 0, conversions: 0, revenue: 0, commission: 0, refunds: 0, chargebacks: 0, declines: 0 };
      }
      
      if (event.eventType === "page_view") {
        dailyMap[date].clicks++;
      }
      if (event.eventType === "sale") {
        dailyMap[date].conversions++;
        dailyMap[date].revenue += event.revenue || 0;
        dailyMap[date].commission += event.commission || 0;
      }
    });

    // Process orders
    filteredOrders.forEach((order: any) => {
      const date = new Date(order.orderDate).toISOString().split('T')[0];
      if (!dailyMap[date]) {
        dailyMap[date] = { date, clicks: 0, conversions: 0, revenue: 0, commission: 0, refunds: 0, chargebacks: 0, declines: 0 };
      }
      
      if (order.status === "canceled-refunded") {
        dailyMap[date].refunds++;
      }
      if (order.status === "chargeback") {
        dailyMap[date].chargebacks++;
      }
    });

    const dailyReports = Object.values(dailyMap).sort((a: any, b: any) => 
      new Date(b.date).getTime() - new Date(a.date).getTime()
    );

    // Calculate hourly reports (last 24 hours only)
    const hourlyMap: Record<string, any> = {};
    const last24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);
    
    filteredEvents.forEach((event: any) => {
      const eventDate = new Date(event.timestamp);
      if (eventDate >= last24Hours) {
        const hour = eventDate.getHours().toString().padStart(2, '0') + ':00';
        if (!hourlyMap[hour]) {
          hourlyMap[hour] = { hour, clicks: 0, conversions: 0, revenue: 0, commission: 0 };
        }
        
        if (event.eventType === "page_view") {
          hourlyMap[hour].clicks++;
        }
        if (event.eventType === "sale") {
          hourlyMap[hour].conversions++;
          hourlyMap[hour].revenue += event.revenue || 0;
          hourlyMap[hour].commission += event.commission || 0;
        }
      }
    });

    // Fill in missing hours with zeros
    for (let i = 0; i < 24; i++) {
      const hour = i.toString().padStart(2, '0') + ':00';
      if (!hourlyMap[hour]) {
        hourlyMap[hour] = { hour, clicks: 0, conversions: 0, revenue: 0, commission: 0 };
      }
    }

    const hourlyReports = Object.values(hourlyMap).sort((a: any, b: any) => 
      a.hour.localeCompare(b.hour)
    );

    // Prepare order details
    const orderDetails = filteredOrders.map((order: any) => ({
      orderId: order.orderId,
      sessionId: order.sessionId,
      affiliateId: order.affiliateId || "direct",
      affiliateName: order.affiliateName || affiliateNames[order.affiliateId] || "Direct Sale",
      customerEmail: order.customerInfo?.email || "",
      packageCount: order.numberOfPackages || 0,
      total: order.total || 0,
      commission: order.affiliateCommission || 0,
      status: order.status || "completed",
      orderDate: order.orderDate,
      subIds: order.subIds || {},
    }));

    // Calculate total stats
    const totalStats = {
      totalRevenue: filteredOrders.reduce((sum: number, o: any) => 
        o.status !== "canceled-refunded" && o.status !== "chargeback" ? sum + (o.total || 0) : sum, 0),
      totalCommission: filteredOrders.reduce((sum: number, o: any) => 
        o.status !== "canceled-refunded" && o.status !== "chargeback" ? sum + (o.affiliateCommission || 0) : sum, 0),
      totalRefunds: filteredOrders.filter((o: any) => o.status === "canceled-refunded").reduce((sum: number, o: any) => 
        sum + (o.total || 0), 0),
      totalChargebacks: chargebackDetails.reduce((sum: number, cb: any) => sum + (cb.amount || 0), 0),
      totalDeclines: 0, // Would need to track payment failures
      netRevenue: 0,
    };

    totalStats.netRevenue = totalStats.totalRevenue - totalStats.totalRefunds - totalStats.totalChargebacks;

    return c.json({
      dailyReports,
      hourlyReports,
      orders: orderDetails,
      chargebacks: chargebackDetails,
      totalStats,
    });
  } catch (error: any) {
    console.error("Error generating affiliate reports:", error);
    return c.json({ error: "Failed to generate reports" }, 500);
  }
});

// ========== DECLINED ORDERS ENDPOINTS ==========

// Get all declined orders
app.get("/make-server-cf244566/declined-orders", async (c) => {
  try {
    console.log("üìã Fetching all declined orders...");
    
    // Get all decline IDs
    const allDeclines = (await kv.get("all_declines")) || [];
    
    // Fetch all decline records
    const declines = [];
    for (const declineId of allDeclines) {
      const decline = await kv.get(`decline:${declineId}`);
      if (decline) {
        declines.push(decline);
      }
    }
    
    // Sort by timestamp (newest first)
    declines.sort((a: any, b: any) => {
      return new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime();
    });
    
    console.log(`‚úÖ Found ${declines.length} declined orders`);
    
    return c.json({ declines });
  } catch (error: any) {
    console.error("‚ùå Error fetching declined orders:", error);
    return c.json({ error: "Failed to fetch declined orders" }, 500);
  }
});

// Log a declined payment attempt
app.post("/make-server-cf244566/log-decline", async (c) => {
  try {
    const body = await c.req.json();
    const {
      timestamp,
      paymentIntentId,
      status,
      declineReason,
      declineCode,
      amount,
      customerInfo,
      letterPackages,
      numberOfPackages,
      affiliateId,
      subIds
    } = body;

    console.log("üìù Logging declined payment:", paymentIntentId);

    // Generate unique decline ID
    const declineId = `decline_${Date.now()}_${Math.random().toString(36).substring(7)}`;

    // Create decline record
    const declineRecord = {
      declineId,
      timestamp: timestamp || new Date().toISOString(),
      paymentIntentId: paymentIntentId || 'unknown',
      status: status || 'declined',
      declineReason: declineReason || 'Unknown error',
      declineCode: declineCode || 'unknown',
      amount: amount || 0,
      customerInfo: customerInfo || {},
      letterPackages: letterPackages || [],
      numberOfPackages: numberOfPackages || 0,
      affiliateId: affiliateId || null,
      subIds: subIds || {},
      
      // Email sequence tracking (initialized)
      emailSequence: {
        emailsSent: 0,
        lastEmailSent: null,
        emailDates: []
      },
      
      // Status flags
      unsubscribed: false,
      unsubscribedAt: null,
      converted: false,
      convertedAt: null
    };

    // Initialize activity log
    declineRecord.activityLog = [];

    // Save to database
    await kv.set(`decline:${declineId}`, declineRecord);

    // Add to all declines index
    const allDeclines = (await kv.get("all_declines")) || [];
    allDeclines.push(declineId);
    await kv.set("all_declines", allDeclines);

    console.log("‚úÖ Decline logged successfully:", declineId);

    return c.json({
      success: true,
      declineId: declineId
    });
  } catch (error: any) {
    console.error("‚ùå Error logging decline:", error);
    return c.json({ error: "Failed to log decline" }, 500);
  }
});

// Track email open (via tracking pixel)
app.get("/make-server-cf244566/decline/track/open/:declineId/:emailNumber", async (c) => {
  try {
    const declineId = c.req.param("declineId");
    const emailNumber = parseInt(c.req.param("emailNumber"));
    
    console.log(`ÔøΩÔøΩÔøΩ Email opened: ${declineId}, email #${emailNumber}`);
    
    // Get decline record
    const decline: any = await kv.get(`decline:${declineId}`);
    if (!decline) {
      return c.text("Not found", 404);
    }
    
    // Add to activity log
    if (!decline.activityLog) {
      decline.activityLog = [];
    }
    
    // Check if already logged (prevent duplicate opens)
    const alreadyLogged = decline.activityLog.some(
      (activity: any) => activity.type === 'email_opened' && activity.emailNumber === emailNumber
    );
    
    if (!alreadyLogged) {
      decline.activityLog.push({
        timestamp: new Date().toISOString(),
        type: 'email_opened',
        emailNumber: emailNumber
      });
      
      await kv.set(`decline:${declineId}`, decline);
      console.log(`‚úÖ Logged email open for decline ${declineId}`);
    }
    
    // Return 1x1 transparent pixel
    const pixel = Buffer.from(
      'R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
      'base64'
    );
    
    return c.body(pixel, 200, {
      'Content-Type': 'image/gif',
      'Cache-Control': 'no-store, no-cache, must-revalidate, proxy-revalidate',
      'Pragma': 'no-cache',
      'Expires': '0'
    });
  } catch (error: any) {
    console.error("‚ùå Error tracking email open:", error);
    // Return pixel anyway to avoid broken images
    const pixel = Buffer.from(
      'R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
      'base64'
    );
    return c.body(pixel, 200, { 'Content-Type': 'image/gif' });
  }
});

// Track email open (fallback without email number)
app.get("/make-server-cf244566/decline/track/open/:declineId", async (c) => {
  try {
    const declineId = c.req.param("declineId");
    
    console.log(`üìß Email opened (no email number): ${declineId}`);
    
    // Get decline record
    const decline: any = await kv.get(`decline:${declineId}`);
    if (decline) {
      // Add to activity log
      if (!decline.activityLog) {
        decline.activityLog = [];
      }
      
      decline.activityLog.push({
        timestamp: new Date().toISOString(),
        type: 'email_opened',
        emailNumber: 0,
        details: 'Email opened (unknown email number)'
      });
      
      await kv.set(`decline:${declineId}`, decline);
      console.log(`‚úÖ Logged email open for decline ${declineId}`);
    }
    
    // Return 1x1 transparent pixel
    const pixel = Buffer.from(
      'R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
      'base64'
    );
    
    return c.body(pixel, 200, {
      'Content-Type': 'image/gif',
      'Cache-Control': 'no-store, no-cache, must-revalidate, proxy-revalidate',
      'Pragma': 'no-cache',
      'Expires': '0'
    });
  } catch (error: any) {
    console.error("‚ùå Error tracking email open:", error);
    // Return pixel anyway to avoid broken images
    const pixel = Buffer.from(
      'R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
      'base64'
    );
    return c.body(pixel, 200, { 'Content-Type': 'image/gif' });
  }
});

// Track email click (with email number)
app.get("/make-server-cf244566/decline/track/click/:declineId/:emailNumber", async (c) => {
  try {
    const declineId = c.req.param("declineId");
    const emailNumber = parseInt(c.req.param("emailNumber"));
    
    console.log(`üñ±Ô∏è Email clicked: ${declineId}, email #${emailNumber}`);
    
    // Get decline record
    const decline: any = await kv.get(`decline:${declineId}`);
    if (decline) {
      // Add to activity log
      if (!decline.activityLog) {
        decline.activityLog = [];
      }
      
      decline.activityLog.push({
        timestamp: new Date().toISOString(),
        type: 'email_clicked',
        emailNumber: emailNumber,
        details: 'Recovery link clicked'
      });
      
      await kv.set(`decline:${declineId}`, decline);
      console.log(`‚úÖ Logged email click for decline ${declineId}`);
    }
    
    // Redirect to checkout with special recovery parameter
    // This allows us to track conversions
    const recoveryUrl = `https://santascertifiedletter.com/?recovery=${declineId}`;
    
    return c.redirect(recoveryUrl);
  } catch (error: any) {
    console.error("‚ùå Error tracking email click:", error);
    // Redirect anyway
    return c.redirect('https://santascertifiedletter.com/?recovery=error');
  }
});

// Track email click (fallback without email number for robustness)
app.get("/make-server-cf244566/decline/track/click/:declineId", async (c) => {
  try {
    const declineId = c.req.param("declineId");
    
    console.log(`üñ±Ô∏è Email clicked (no email number): ${declineId}`);
    
    // Get decline record
    const decline: any = await kv.get(`decline:${declineId}`);
    if (decline) {
      // Add to activity log
      if (!decline.activityLog) {
        decline.activityLog = [];
      }
      
      decline.activityLog.push({
        timestamp: new Date().toISOString(),
        type: 'email_clicked',
        emailNumber: 0,
        details: 'Recovery link clicked (unknown email number)'
      });
      
      await kv.set(`decline:${declineId}`, decline);
      console.log(`ÔøΩÔøΩÔøΩ Logged email click for decline ${declineId}`);
    }
    
    // Redirect to checkout with special recovery parameter
    const recoveryUrl = `https://santascertifiedletter.com/?recovery=${declineId}`;
    
    return c.redirect(recoveryUrl);
  } catch (error: any) {
    console.error("‚ùå Error tracking email click:", error);
    // Redirect anyway
    return c.redirect('https://santascertifiedletter.com/?recovery=error');
  }
});

// Unsubscribe from decline emails
app.get("/make-server-cf244566/decline/unsubscribe/:declineId", async (c) => {
  try {
    const declineId = c.req.param("declineId");
    
    console.log(`üö´ Unsubscribe request for: ${declineId}`);
    
    // Get decline record
    const decline: any = await kv.get(`decline:${declineId}`);
    if (!decline) {
      return c.html(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>Unsubscribe</title>
          <style>
            body { font-family: Arial, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; text-align: center; }
            h1 { color: #dc2626; }
          </style>
        </head>
        <body>
          <h1>‚ùå Not Found</h1>
          <p>We couldn't find this unsubscribe link.</p>
        </body>
        </html>
      `);
    }
    
    // Mark as unsubscribed
    decline.unsubscribed = true;
    decline.unsubscribedAt = new Date().toISOString();
    
    // Add to activity log
    if (!decline.activityLog) {
      decline.activityLog = [];
    }
    decline.activityLog.push({
      timestamp: new Date().toISOString(),
      type: 'unsubscribed',
      details: 'Customer unsubscribed from recovery emails'
    });
    
    await kv.set(`decline:${declineId}`, decline);
    
    console.log(`‚úÖ Unsubscribed: ${declineId}`);
    
    // Return confirmation page
    return c.html(`
      <!DOCTYPE html>
      <html>
      <head>
        <title>Unsubscribed</title>
        <style>
          body { font-family: Arial, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; text-align: center; }
          h1 { color: #10b981; }
          p { font-size: 16px; line-height: 1.6; color: #666; }
          .button { display: inline-block; background: #dc2626; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; margin-top: 20px; }
        </style>
      </head>
      <body>
        <h1>‚úÖ You've been unsubscribed</h1>
        <p>You will no longer receive recovery emails for this order.</p>
        <p>If you change your mind and want to complete your order, you can still do so:</p>
        <a href="https://santascertifiedletter.com/?recovery=${declineId}" class="button">Complete My Order</a>
      </body>
      </html>
    `);
  } catch (error: any) {
    console.error("‚ùå Error unsubscribing:", error);
    return c.html(`
      <!DOCTYPE html>
      <html>
      <head>
        <title>Error</title>
        <style>
          body { font-family: Arial, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; text-align: center; }
          h1 { color: #dc2626; }
        </style>
      </head>
      <body>
        <h1>‚ùå Error</h1>
        <p>There was an error processing your request. Please try again later.</p>
      </body>
      </html>
    `);
  }
});

// Mark decline as converted
app.post("/make-server-cf244566/decline/mark-converted", async (c) => {
  try {
    const { declineId, orderId } = await c.req.json();
    
    console.log(`ÔøΩÔøΩÔøΩ Marking decline as converted: ${declineId} -> ${orderId}`);
    
    // Get decline record
    const decline: any = await kv.get(`decline:${declineId}`);
    if (!decline) {
      return c.json({ error: "Decline not found" }, 404);
    }
    
    // Update decline record
    decline.converted = true;
    decline.convertedAt = new Date().toISOString();
    decline.convertedOrderId = orderId;
    
    // Add to activity log
    if (!decline.activityLog) {
      decline.activityLog = [];
    }
    decline.activityLog.push({
      timestamp: new Date().toISOString(),
      type: 'converted',
      details: orderId
    });
    
    await kv.set(`decline:${declineId}`, decline);
    
    console.log(`‚úÖ Decline marked as converted: ${declineId}`);
    
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error marking decline as converted:", error);
    return c.json({ error: "Failed to mark as converted" }, 500);
  }
});

// Send manual recovery email
app.post("/make-server-cf244566/decline/send-recovery", async (c) => {
  try {
    const { declineId } = await c.req.json();
    
    console.log(`üìß Sending manual recovery email for: ${declineId}`);
    
    // Get decline record
    const decline: any = await kv.get(`decline:${declineId}`);
    if (!decline) {
      return c.json({ error: "Decline not found" }, 404);
    }
    
    if (decline.unsubscribed) {
      return c.json({ error: "Customer has unsubscribed" }, 400);
    }
    
    if (decline.converted) {
      return c.json({ error: "Customer has already converted" }, 400);
    }
    
    // Send recovery email
    const emailNumber = Math.max(1, (decline.emailSequence?.emailsSent || 0) + 1);
    const baseUrl = 'https://santascertifiedletter.com';
    
    // Create tracking URLs with validated email number
    const supabaseUrl = Deno.env.get('SUPABASE_URL');
    const trackingPixelUrl = `${supabaseUrl}/functions/v1/make-server-cf244566/decline/track/open/${declineId}/${emailNumber}`;
    const trackingClickUrl = `${supabaseUrl}/functions/v1/make-server-cf244566/decline/track/click/${declineId}/${emailNumber}`;
    const unsubscribeUrl = `${supabaseUrl}/functions/v1/make-server-cf244566/decline/unsubscribe/${declineId}`;
    
    console.log(`üìß Tracking URLs - Pixel: ${trackingPixelUrl}, Click: ${trackingClickUrl}`);
    
    // Send email via Resend
    const resendApiKey = Deno.env.get('RESEND_API_KEY');
    if (!resendApiKey) {
      return c.json({ error: "Resend API key not configured" }, 500);
    }
    
    // Direct link to update payment page (using query parameter)
    const updatePaymentUrl = `${baseUrl}/?page=updatepayment&token=${declineId}`;
    
    const emailHtml = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
        <style>
          body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0; }
          .container { max-width: 600px; margin: 0 auto; padding: 20px; }
          .header { background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
          .header h1 { margin: 0; font-family: 'Pacifico', cursive; font-size: 32px; }
          .content { background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none; }
          .button { display: inline-block; background: #dc2626; color: white !important; padding: 15px 30px; text-decoration: none; border-radius: 8px; font-weight: bold; margin: 20px 0; font-size: 18px; }
          .button:hover { background: #b91c1c; }
          .footer { background: #f9fafb; padding: 20px; text-align: center; color: #6b7280; font-size: 12px; border-radius: 0 0 10px 10px; }
          ul { background: #f3f4f6; padding: 20px; border-radius: 8px; }
          li { margin: 10px 0; }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="header">
            <h1>üéÖ Your Letter From Santa is Waiting!</h1>
          </div>
          <div class="content">
            <p>Hi ${decline.customerInfo.name},</p>
            
            <p>We noticed there was a small issue with your recent order for ${decline.numberOfPackages} Santa Letter${decline.numberOfPackages > 1 ? 's' : ''}.</p>
            
            <p style="font-size: 18px; color: #059669;"><strong>Don't worry - we've reserved your spot!</strong> üéÑ</p>
            
            <p>Simply click the button below to complete your order and give ${decline.letterPackages.map((pkg: any) => pkg.childFirstName).join(' and ')} the magical Christmas experience they deserve!</p>
            
            <div style="text-align: center;">
              <a href="${updatePaymentUrl}" class="button">
                ‚ú® Complete Your Order Now
              </a>
            </div>
            
            <p><strong>Your reserved order includes:</strong></p>
            <ul>
              <li>${decline.numberOfPackages} Personalized Letter${decline.numberOfPackages > 1 ? 's' : ''} from Santa</li>
              <li>North Pole postmark</li>
              <li>Official Nice List Certificate</li>
              <li>Activity sheet and stickers</li>
            </ul>
            
            <p>This is a limited-time offer - complete your order today!</p>
            
            <p>Ho Ho Ho! üéÖ</p>
            <p>Santa's Workshop Team</p>
          </div>
          <div class="footer">
            <p><a href="${unsubscribeUrl}" style="color: #6b7280; text-decoration: underline;">Unsubscribe</a> from these emails</p>
            <p style="margin-top: 10px; color: #9ca3af;">¬© 2025 Letters From Santa. All rights reserved.</p>
          </div>
        </div>
        <img src="${trackingPixelUrl}" width="1" height="1" alt="" style="display:none;" />
      </body>
      </html>
    `;
    
    const emailResponse = await fetch('https://api.resend.com/emails', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${resendApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        from: 'Santa\'s Workshop <noreply@updates.santascertifiedletter.com>',
        to: [decline.customerInfo.email],
        subject: `üéÖ ${decline.customerInfo.name}, Your Santa Letters Are Reserved!`,
        html: emailHtml
      }),
    });
    
    if (!emailResponse.ok) {
      const errorData = await emailResponse.json();
      console.error("‚ùå Resend error:", errorData);
      return c.json({ error: "Failed to send email" }, 500);
    }
    
    // Update decline record
    if (!decline.emailSequence) {
      decline.emailSequence = { emailsSent: 0, lastEmailSent: null, emailDates: [] };
    }
    decline.emailSequence.emailsSent++;
    decline.emailSequence.lastEmailSent = new Date().toISOString();
    decline.emailSequence.emailDates.push(new Date().toISOString());
    
    // Add to activity log
    if (!decline.activityLog) {
      decline.activityLog = [];
    }
    decline.activityLog.push({
      timestamp: new Date().toISOString(),
      type: 'email_sent',
      emailNumber: emailNumber
    });
    
    await kv.set(`decline:${declineId}`, decline);
    
    console.log(`‚úÖ Recovery email sent for decline ${declineId}`);
    
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error sending recovery email:", error);
    return c.json({ error: "Failed to send recovery email" }, 500);
  }
});

// ========== DECLINED ORDERS EMAIL SEQUENCE SYSTEM ==========

// Unsubscribe from decline emails
app.get("/make-server-cf244566/decline/unsubscribe/:declineId", async (c) => {
  try {
    const declineId = c.req.param("declineId");
    
    // Get the decline record
    const decline: any = await kv.get(`decline:${declineId}`);
    
    if (!decline) {
      return c.text("Decline record not found", 404);
    }
    
    // Mark as unsubscribed
    decline.unsubscribed = true;
    decline.unsubscribedAt = new Date().toISOString();
    
    // Add to activity log
    if (!decline.activityLog) {
      decline.activityLog = [];
    }
    decline.activityLog.push({
      timestamp: new Date().toISOString(),
      type: 'unsubscribed'
    });
    
    await kv.set(`decline:${declineId}`, decline);
    
    console.log(`‚úÖ Unsubscribed from decline emails: ${declineId}`);
    
    // Return HTML page
    return c.html(`
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Unsubscribed</title>
        <style>
          body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 50px auto;
            padding: 20px;
            text-align: center;
          }
          .success {
            background: #ecfdf5;
            border: 2px solid #6ee7b7;
            border-radius: 8px;
            padding: 30px;
            margin: 20px 0;
          }
          h1 {
            color: #059669;
            margin: 0 0 15px 0;
          }
          p {
            color: #374151;
            line-height: 1.6;
          }
        </style>
      </head>
      <body>
        <div class="success">
          <h1>‚úÖ Successfully Unsubscribed</h1>
          <p>You will no longer receive follow-up emails about your declined payment.</p>
          <p>If you change your mind and would like to complete your order, you can always visit our website directly.</p>
        </div>
        <p style="color: #6b7280; font-size: 14px; margin-top: 30px;">
          Thank you for your interest in Letters From Santa! üéÖ
        </p>
      </body>
      </html>
    `);
  } catch (error: any) {
    console.error("Error unsubscribing:", error);
    return c.text("Error processing unsubscribe request", 500);
  }
});

// Process declined orders email sequence (to be called daily via cron or manual trigger)
app.post("/make-server-cf244566/decline/process-sequence", async (c) => {
  try {
    console.log("üîÑ Processing declined orders email sequence...");
    
    const resendApiKey = Deno.env.get("RESEND_API_KEY");
    if (!resendApiKey) {
      console.error("RESEND_API_KEY not configured");
      return c.json({ error: "Email service not configured" }, 500);
    }
    
    // Get all declined orders
    const declines = await kv.getByPrefix("decline:");
    const today = new Date();
    
    let emailsSent = 0;
    let emailsSkipped = 0;
    
    for (const decline of declines) {
      // Skip if unsubscribed
      if (decline.unsubscribed) {
        emailsSkipped++;
        continue;
      }
      
      // Skip if converted (check if order with same email exists)
      const orders = await kv.getByPrefix("order:");
      const hasConverted = orders.some((order: any) => 
        order.customerInfo?.email?.toLowerCase() === decline.customerInfo?.email?.toLowerCase()
      );
      
      if (hasConverted) {
        // Mark as converted so we don't check again
        decline.converted = true;
        decline.convertedAt = new Date().toISOString();
        await kv.set(`decline:${decline.declineId}`, decline);
        emailsSkipped++;
        continue;
      }
      
      // Calculate days since decline
      const declineDate = new Date(decline.timestamp);
      const daysSinceDecline = Math.floor((today.getTime() - declineDate.getTime()) / (1000 * 60 * 60 * 24));
      
      // Initialize email tracking if not exists
      if (!decline.emailSequence) {
        decline.emailSequence = {
          emailsSent: 0,
          lastEmailSent: null,
          emailDates: []
        };
      }
      
      // Check if we should send email today
      const lastEmailDate = decline.emailSequence.lastEmailSent ? new Date(decline.emailSequence.lastEmailSent) : null;
      const hoursSinceLastEmail = lastEmailDate ? (today.getTime() - lastEmailDate.getTime()) / (1000 * 60 * 60) : 999;
      
      // Send one email per day (24 hours between emails)
      if (hoursSinceLastEmail < 23) {
        emailsSkipped++;
        continue;
      }
      
      // Limit to 7 emails total
      if (decline.emailSequence.emailsSent >= 7) {
        emailsSkipped++;
        continue;
      }
      
      // Prepare email content based on day number
      const dayNumber = decline.emailSequence.emailsSent + 1;
      const baseUrl = 'https://santascertifiedletter.com';
      const supabaseUrl = Deno.env.get('SUPABASE_URL');
      const trackingPixelUrl = `${supabaseUrl}/functions/v1/make-server-cf244566/decline/track/open/${decline.declineId}/${dayNumber}`;
      const trackingClickUrl = `${supabaseUrl}/functions/v1/make-server-cf244566/decline/track/click/${decline.declineId}/${dayNumber}`;
      const unsubscribeUrl = `${supabaseUrl}/functions/v1/make-server-cf244566/decline/unsubscribe/${decline.declineId}`;
      
      let subject = "";
      let message = "";
      
      switch (dayNumber) {
        case 1:
          subject = "üéÖ Complete Your Santa Letter Order";
          message = `We noticed there was an issue processing your payment for your Santa Letter order. We'd love to help you complete it!`;
          break;
        case 2:
          subject = "Still interested in your Santa Letter? üéÑ";
          message = `Your Santa Letter order is still waiting for you! Let's get those magical letters on their way to the North Pole.`;
          break;
        case 3:
          subject = "Don't miss out on the Christmas magic! ‚ú®";
          message = `Time is running out to get your personalized Letters From Santa delivered before Christmas!`;
          break;
        case 4:
          subject = "Your kids are going to love this! üéÅ";
          message = `Imagine the look on their faces when they receive a personalized letter from Santa himself!`;
          break;
        case 5:
          subject = "Last chance for Christmas delivery üöö";
          message = `We want to make sure your Santa Letters arrive in time for Christmas magic!`;
          break;
        case 6:
          subject = "We're here to help! ü§ù";
          message = `If you had any issues with payment, we're here to assist. Let's make this Christmas special!`;
          break;
        case 7:
          subject = "Final reminder: Santa Letters are waiting üéÖ";
          message = `This is our last reminder about your Santa Letter order. We'd hate for you to miss out!`;
          break;
      }
      
      const emailHtml = `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
        </head>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
          <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
            <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
              <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÖ Letters From Santa</h1>
              <p style="margin: 10px 0 0 0; font-size: 18px;">${subject}</p>
            </div>
            <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
              <p>Hi ${decline.customerInfo.name || 'there'},</p>
              
              <p style="font-size: 18px; color: #059669;"><strong>${message}</strong></p>
              
              <div style="background: #fef2f2; border-left: 4px solid #dc2626; padding: 15px; margin: 20px 0;">
                <p style="margin: 0; font-size: 16px;"><strong>üí≥ What happened:</strong></p>
                <p style="margin: 5px 0 0 0; color: #dc2626;">${decline.declineReason}</p>
              </div>
              
              <p><strong>Your order details:</strong></p>
              <ul style="background: #f3f4f6; padding: 20px; border-radius: 8px;">
                ${decline.letterPackages.map((pkg: any) => `
                  <li style="margin: 10px 0;">
                    Letter for <strong>${pkg.childFirstName} ${pkg.childLastName}</strong><br>
                    <span style="font-size: 14px; color: #6b7280;">to ${pkg.city}, ${pkg.state}</span>
                  </li>
                `).join('')}
              </ul>
              
              <p style="margin-top: 30px; font-size: 16px;"><strong>Total: ${decline.amount.toFixed(2)}</strong></p>
              
              <div style="text-align: center; margin: 30px 0;">
                <a href="${baseUrl}/?page=updatepayment&token=${decline.declineId}" 
                   style="display: inline-block; background: #dc2626; color: white; padding: 15px 40px; text-decoration: none; border-radius: 8px; font-weight: bold; font-size: 18px;">
                  üí≥ Update Payment Method
                </a>
              </div>
              
              <p style="margin-top: 30px; padding: 15px; background: #fef3c7; border-radius: 8px; border-left: 4px solid #f59e0b;">
                <strong>üí° Tip:</strong> Click "Update Payment Method" above to securely add a new card. Your order will be processed automatically once updated.
              </p>
              
              <p style="margin-top: 30px; color: #6b7280; font-size: 14px;">
                Need help? Reply to this email or contact our support team.
              </p>
            </div>
            <div style="background: #f9fafb; padding: 20px; text-align: center; color: #6b7280; font-size: 12px; border-radius: 0 0 10px 10px;">
              <p>Questions? Contact us at support@letterfromsanta.com</p>
              <p style="margin-top: 10px;">
                <a href="${unsubscribeUrl}" style="color: #6b7280; text-decoration: underline;">
                  Unsubscribe from these emails
                </a>
              </p>
              <p style="margin-top: 10px; color: #9ca3af;">¬© 2025 Letters From Santa. All rights reserved.</p>
            </div>
          </div>
        </body>
        </html>
      `;
      
      // Send email
      try {
        const emailResponse = await fetch("https://api.resend.com/emails", {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${resendApiKey}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
            to: decline.customerInfo.email,
            subject: subject,
            html: emailHtml,
          }),
        });
        
        if (emailResponse.ok) {
          // Update email sequence tracking
          decline.emailSequence.emailsSent++;
          decline.emailSequence.lastEmailSent = today.toISOString();
          decline.emailSequence.emailDates.push(today.toISOString());
          
          // Add to activity log
          if (!decline.activityLog) {
            decline.activityLog = [];
          }
          decline.activityLog.push({
            timestamp: today.toISOString(),
            type: 'email_sent',
            emailNumber: dayNumber
          });
          
          await kv.set(`decline:${decline.declineId}`, decline);
          
          emailsSent++;
          console.log(`‚úÖ Sent decline follow-up email #${dayNumber} to ${decline.customerInfo.email}`);
        } else {
          console.error(`‚ùå Failed to send decline email to ${decline.customerInfo.email}`);
        }
      } catch (emailError) {
        console.error(`Error sending decline email:`, emailError);
      }
    }
    
    console.log(`üìß Email sequence complete: ${emailsSent} sent, ${emailsSkipped} skipped`);
    
    return c.json({
      success: true,
      emailsSent,
      emailsSkipped,
      totalDeclines: declines.length
    });
  } catch (error: any) {
    console.error("Error processing decline email sequence:", error);
    return c.json({ error: "Failed to process email sequence" }, 500);
  }
});

// Manual trigger endpoint (for testing)
app.get("/make-server-cf244566/decline/send-test-sequence", async (c) => {
  console.log("üß™ Manually triggering decline email sequence...");
  
  // Call the main sequence endpoint
  const response = await app.request("/make-server-cf244566/decline/process-sequence", {
    method: "POST",
  });
  
  const data = await response.json();
  return c.json(data);
});

// ========== SUBSCRIPTION MANAGEMENT ENDPOINTS ==========

// Cancel a subscription
app.post("/make-server-cf244566/subscriptions/:subscriptionId/cancel", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }

  try {
    const subscriptionId = c.req.param("subscriptionId");
    
    console.log(`üö´ Canceling subscription: ${subscriptionId}`);
    
    // Cancel the subscription in Stripe
    const canceledSubscription = await stripe.subscriptions.cancel(subscriptionId);
    
    console.log(`‚úÖ Subscription canceled: ${subscriptionId}`);
    
    // Find and update the order
    const allOrderIds = (await kv.get("orders:all")) || [];
    for (const orderId of allOrderIds) {
      const order: any = await kv.get(`order:${orderId}`);
      if (order && order.subscriptionId === subscriptionId) {
        order.status = "canceled-refunded";
        order.subscriptionId = null;
        order.updatedAt = new Date().toISOString();
        await kv.set(`order:${orderId}`, order);
        
        // Send notification email
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        if (resendApiKey && order.customerInfo?.email) {
          try {
            await fetch("https://api.resend.com/emails", {
              method: "POST",
              headers: {
                "Authorization": `Bearer ${resendApiKey}`,
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                from: "Santa's Workshop <noreply@updates.santascertifiedletter.com>",
                to: [order.customerInfo.email],
                subject: "Subscription Canceled",
                html: `<div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;"><h2 style="color: #dc2626;">Subscription Canceled</h2><p>Hello ${order.customerInfo.name},</p><p>Your monthly Santa letter subscription has been canceled as requested.</p><p>You will not be charged again.</p><p>If this was done in error, please contact us.</p><p style="color: #dc2626;">üéÑ Thank you!</p></div>`,
              }),
            });
          } catch (error) {
            console.error("Failed to send cancellation email:", error);
          }
        }
        
        // Send SMS notification
        const twilioAccountSid = Deno.env.get("TWILIO_ACCOUNT_SID");
        const twilioAuthToken = Deno.env.get("TWILIO_AUTH_TOKEN");
        const twilioPhoneNumber = Deno.env.get("TWILIO_PHONE_NUMBER");
        
        if (twilioAccountSid && twilioAuthToken && twilioPhoneNumber && order.customerInfo?.phone) {
          try {
            const auth = btoa(`${twilioAccountSid}:${twilioAuthToken}`);
            await fetch(`https://api.twilio.com/2010-04-01/Accounts/${twilioAccountSid}/Messages.json`, {
              method: "POST",
              headers: {
                "Authorization": `Basic ${auth}`,
                "Content-Type": "application/x-www-form-urlencoded",
              },
              body: new URLSearchParams({
                To: order.customerInfo.phone,
                From: twilioPhoneNumber,
                Body: `Your Santa letter subscription has been canceled. You will not be charged again.`,
              }),
            });
          } catch (error) {
            console.error("Failed to send SMS:", error);
          }
        }
        
        break;
      }
    }
    
    return c.json({ 
      success: true,
      subscriptionId: canceledSubscription.id,
      status: canceledSubscription.status
    });
  } catch (error: any) {
    console.error("‚ùå Error canceling subscription:", error);
    return c.json({ error: "Failed to cancel subscription", details: error.message }, 500);
  }
});

// Create a new monthly order for a subscription (for testing/manual creation)
app.post("/make-server-cf244566/subscriptions/:subscriptionId/create-order", async (c) => {
  try {
    const subscriptionId = c.req.param("subscriptionId");
    
    console.log(`üì¶ Creating manual monthly order for subscription: ${subscriptionId}`);
    
    // Find the parent order with this subscription ID
    const allOrderIds = (await kv.get("orders:all")) || [];
    let parentOrder: any = null;
    
    for (const orderId of allOrderIds) {
      const order: any = await kv.get(`order:${orderId}`);
      if (order && order.subscriptionId === subscriptionId && order.monthlySubscription) {
        parentOrder = order;
        break;
      }
    }
    
    if (!parentOrder) {
      return c.json({ error: "Parent subscription order not found" }, 404);
    }
    
    // Increment successful charges on parent order
    parentOrder.successfulCharges = (parentOrder.successfulCharges || 0) + 1;
    parentOrder.subscriptionMonthsActive = parentOrder.successfulCharges;
    parentOrder.updatedAt = new Date().toISOString();
    
    // Add activity log
    if (!parentOrder.activityLog) {
      parentOrder.activityLog = [];
    }
    parentOrder.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Manual Order Created',
      details: `Created manual fulfillment order for month ${parentOrder.successfulCharges}`,
      user: 'Admin'
    });
    
    await kv.set(`order:${parentOrder.orderId}`, parentOrder);
    
    // Create new order ID
    const newOrderId = `ord_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    
    // Get subscription price from parent order
    const subscriptionPrice = parentOrder.subscriptionPrice || 12.00;
    const subscriptionProductName = parentOrder.subscriptionProductName || "Santa's Magical Journey";
    
    // Create new order for fulfillment
    const newOrder = {
      orderId: newOrderId,
      parentOrderId: parentOrder.orderId,
      subscriptionId: parentOrder.subscriptionId,
      sessionId: `manual_${newOrderId}`,
      stripePaymentId: null,
      stripeCheckoutUrl: null,
      orderDate: new Date().toISOString(),
      status: "pending",
      total: subscriptionPrice,
      customerInfo: parentOrder.customerInfo,
      letterPackages: parentOrder.letterPackages,
      numberOfPackages: parentOrder.numberOfPackages,
      shippingDate: "",
      monthlySubscription: false,
      subscriptionRecurringOrder: true,
      subscriptionMonth: parentOrder.successfulCharges,
      subscriptionProductName: subscriptionProductName,
      affiliateId: parentOrder.affiliateId,
      affiliateName: parentOrder.affiliateName,
      trackingNumber: null,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      activityLog: [{
        timestamp: new Date().toISOString(),
        action: 'Order Created',
        details: `Recurring subscription order - Month ${parentOrder.successfulCharges} (Manual)`,
        user: 'Admin'
      }]
    };
    
    // Save new order
    await kv.set(`order:${newOrderId}`, newOrder);
    
    // Add to orders index
    allOrderIds.push(newOrderId);
    await kv.set("orders:all", allOrderIds);
    
    console.log(`‚úÖ Created manual monthly order: ${newOrderId} for ${subscriptionProductName} at ${subscriptionPrice}`);
    
    return c.json({ 
      success: true,
      newOrderId,
      monthsActive: parentOrder.successfulCharges,
      productName: subscriptionProductName,
      price: subscriptionPrice
    });
  } catch (error: any) {
    console.error("‚ùå Error creating monthly order:", error);
    return c.json({ error: "Failed to create monthly order", details: error.message }, 500);
  }
});

// Alias endpoint for admin declined orders (matches frontend expectation)
app.get("/make-server-cf244566/admin/declined-orders", async (c) => {
  try {
    console.log("üìã Fetching declined orders (admin alias)...");
    
    const allDeclines = (await kv.get("all_declines")) || [];
    const declinedOrders = [];
    
    for (const declineId of allDeclines) {
      const decline = await kv.get(`decline:${declineId}`);
      if (decline) {
        declinedOrders.push(decline);
      }
    }
    
    declinedOrders.sort((a: any, b: any) => {
      return new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime();
    });
    
    console.log(`‚úÖ Found ${declinedOrders.length} declined orders`);
    
    return c.json({ declinedOrders });
  } catch (error: any) {
    console.error("‚ùå Error fetching declined orders:", error);
    return c.json({ error: "Failed to fetch declined orders", details: error.message }, 500);
  }
});

// ========== SUBSCRIPTION MANAGEMENT ENDPOINTS ==========

// Cancel subscription
app.post("/make-server-cf244566/subscriptions/:subscriptionId/cancel", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 500);
  }

  try {
    const subscriptionId = c.req.param("subscriptionId");
    const { orderId } = await c.req.json();
    
    console.log(`üö´ Canceling subscription: ${subscriptionId}`);
    
    // Get the order
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!order.subscriptionId) {
      return c.json({ error: "Order does not have a subscription" }, 400);
    }
    
    // Cancel subscription in Stripe
    const canceledSubscription = await stripe.subscriptions.cancel(subscriptionId);
    
    console.log(`‚úÖ Subscription canceled in Stripe: ${canceledSubscription.id}`);
    
    // Update order status but don't mark as canceled-refunded (only cancel future billing)
    order.subscriptionId = null; // Remove subscription ID
    order.subscriptionNextBillingDate = null;
    order.updatedAt = new Date().toISOString();
    
    // Add to activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Subscription Canceled',
      details: `Monthly subscription canceled by admin. Subscription ID: ${subscriptionId}`,
      user: 'Admin'
    });
    
    await kv.set(`order:${orderId}`, order);
    
    // Send notification
    await sendCancelSubscriptionNotification(order);
    
    return c.json({ 
      success: true,
      message: "Subscription canceled successfully",
      subscriptionId: canceledSubscription.id,
      status: canceledSubscription.status
    });
  } catch (error: any) {
    console.error("‚ùå Error canceling subscription:", error);
    return c.json({ 
      error: error.message || "Failed to cancel subscription",
      details: error.toString(),
    }, 500);
  }
});

// ========== DECLINED CHARGE RETRY AND DOWNSELL SYSTEM ==========

// Process declined charge retries (to be called daily via cron)
app.post("/make-server-cf244566/admin/process-retries", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 500);
  }

  try {
    console.log("üîÑ Processing declined charge retries...");
    
    const now = new Date();
    const allOrderIds = (await kv.get("orders:all")) || [];
    let retriesAttempted = 0;
    let retriesSucceeded = 0;
    let retriesFailed = 0;
    let downsellOffersSent = 0;
    
    for (const orderId of allOrderIds) {
      const order: any = await kv.get(`order:${orderId}`);
      
      // Skip if no subscription or no retry needed
      if (!order || !order.subscriptionId || !order.nextRetryDate) continue;
      
      // Skip if already offered downsell
      if (order.downsellOffered) continue;
      
      // Check if it's time to retry
      const nextRetry = new Date(order.nextRetryDate);
      if (nextRetry > now) continue;
      
      retriesAttempted++;
      
      console.log(`üîÅ Retrying charge for order ${orderId} (Attempt ${order.retryAttempts + 1})`);
      
      try {
        // Get subscription from Stripe
        const subscription = await stripe.subscriptions.retrieve(order.subscriptionId);
        
        if (subscription.status === "canceled") {
          console.log(`‚è≠Ô∏è Subscription canceled, skipping retry`);
          continue;
        }
        
        // Get payment method
        const defaultPaymentMethod = subscription.default_payment_method || 
                                      subscription.default_source;
        
        if (!defaultPaymentMethod) {
          console.log(`‚ö†Ô∏è No payment method on file`);
          retriesFailed++;
          continue;
        }
        
        const subscriptionPrice = order.subscriptionPrice || 12.00;
        
        // Attempt to charge
        const paymentIntent = await stripe.paymentIntents.create({
          amount: Math.round(subscriptionPrice * 100),
          currency: 'usd',
          customer: subscription.customer as string,
          payment_method: defaultPaymentMethod as string,
          off_session: true,
          confirm: true,
          description: `${order.subscriptionProductName || "Santa's Magical Journey"} - Retry Attempt ${order.retryAttempts + 1}`,
          metadata: {
            orderId: orderId,
            retryAttempt: String(order.retryAttempts + 1),
            subscriptionId: order.subscriptionId,
          },
        });
        
        if (paymentIntent.status === 'succeeded') {
          // Success! Reset retry counters
          retriesSucceeded++;
          order.retryAttempts = 0;
          order.firstFailureDate = null;
          order.lastFailureDate = null;
          order.nextRetryDate = null;
          order.lastChargeDate = new Date().toISOString();
          order.successfulCharges = (order.successfulCharges || 0) + 1;
          
          // Calculate next billing date
          const billingIntervalDays = order.billingIntervalDays || 30;
          const nextBilling = new Date();
          nextBilling.setDate(nextBilling.getDate() + billingIntervalDays);
          order.subscriptionNextBillingDate = nextBilling.toISOString();
          
          if (!order.activityLog) order.activityLog = [];
          order.activityLog.push({
            timestamp: new Date().toISOString(),
            action: 'Retry Charge Successful',
            details: `Retry attempt ${order.retryAttempts + 1} succeeded. Charged ${subscriptionPrice.toFixed(2)}`,
            user: 'System - Auto Retry'
          });
          
          await kv.set(`order:${orderId}`, order);
          
          // Send success email
          if (order.customerInfo?.email) {
            const childNames = order.letterPackages?.map((pkg: any) => pkg.childFirstName).join(' and ') || 'your child';
            await sendRetrySuccessEmail(order, childNames);
          }
          
          console.log(`‚úÖ Retry successful for order ${orderId}`);
        } else {
          // Failed again
          retriesFailed++;
          order.retryAttempts++;
          order.lastFailureDate = new Date().toISOString();
          
          // Check if we've hit 3 failures - send downsell offer
          if (order.retryAttempts >= 3 && !order.downsellOffered) {
            order.downsellOffered = true;
            order.downsellOfferedDate = new Date().toISOString();
            
            if (!order.activityLog) order.activityLog = [];
            order.activityLog.push({
              timestamp: new Date().toISOString(),
              action: 'Downsell Offer Sent',
              details: `After 3 failed attempts, sent downsell offer email`,
              user: 'System - Auto Retry'
            });
            
            await kv.set(`order:${orderId}`, order);
            
            // Send downsell offer email
            if (order.customerInfo?.email) {
              const childNames = order.letterPackages?.map((pkg: any) => pkg.childFirstName).join(' and ') || 'your child';
              await sendDownsellOfferEmail(order, childNames);
              downsellOffersSent++;
            }
            
            console.log(`üìß Downsell offer sent for order ${orderId}`);
          } else {
            // Schedule next retry in 2 days
            order.nextRetryDate = new Date(Date.now() + (48 * 60 * 60 * 1000)).toISOString();
            
            if (!order.activityLog) order.activityLog = [];
            order.activityLog.push({
              timestamp: new Date().toISOString(),
              action: 'Retry Charge Failed',
              details: `Retry attempt ${order.retryAttempts} failed. Next retry: ${new Date(order.nextRetryDate).toLocaleDateString()}`,
              user: 'System - Auto Retry'
            });
            
            await kv.set(`order:${orderId}`, order);
            
            // Send retry email
            if (order.customerInfo?.email) {
              const childNames = order.letterPackages?.map((pkg: any) => pkg.childFirstName).join(' and ') || 'your child';
              await sendRetryEmail(order, childNames, order.retryAttempts);
            }
            
            console.log(`‚ùå Retry failed for order ${orderId}, will retry again in 2 days`);
          }
        }
      } catch (error: any) {
        console.error(`‚ùå Error retrying charge for order ${orderId}:`, error);
        retriesFailed++;
        
        // Don't give up - schedule another retry
        order.nextRetryDate = new Date(Date.now() + (48 * 60 * 60 * 1000)).toISOString();
        await kv.set(`order:${orderId}`, order);
      }
    }
    
    console.log(`‚úÖ Retry processing complete: ${retriesAttempted} attempted, ${retriesSucceeded} succeeded, ${retriesFailed} failed, ${downsellOffersSent} downsell offers sent`);
    
    return c.json({
      success: true,
      retriesAttempted,
      retriesSucceeded,
      retriesFailed,
      downsellOffersSent
    });
  } catch (error: any) {
    console.error("‚ùå Error processing retries:", error);
    return c.json({ error: "Failed to process retries" }, 500);
  }
});

// Accept downsell offer
app.post("/make-server-cf244566/accept-downsell/:orderId", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 500);
  }

  try {
    const orderId = c.req.param("orderId");
    const { newPrice } = await c.req.json();
    
    console.log(`üí∞ Processing downsell acceptance for order ${orderId}: ${newPrice}`);
    
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!order.subscriptionId) {
      return c.json({ error: "No active subscription" }, 400);
    }
    
    // Validate price (must be between $8 and $12)
    const price = parseFloat(newPrice);
    if (isNaN(price) || price < 8 || price > 12) {
      return c.json({ error: "Invalid price. Must be between $8 and $12" }, 400);
    }
    
    // Update the order's subscription price
    const oldPrice = order.subscriptionPrice || 12.00;
    order.subscriptionPrice = price;
    order.downsellAccepted = true;
    order.downsellAcceptedDate = new Date().toISOString();
    order.downsellAcceptedPrice = price;
    order.retryAttempts = 0; // Reset retry counter
    order.nextRetryDate = null;
    
    if (!order.activityLog) order.activityLog = [];
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Downsell Accepted',
      details: `Customer accepted downsell from ${oldPrice.toFixed(2)} to ${price.toFixed(2)}/month`,
      user: 'Customer'
    });
    
    await kv.set(`order:${orderId}`, order);
    
    // Now try to charge the new lower price
    try {
      const subscription = await stripe.subscriptions.retrieve(order.subscriptionId);
      const defaultPaymentMethod = subscription.default_payment_method || subscription.default_source;
      
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(price * 100),
        currency: 'usd',
        customer: subscription.customer as string,
        payment_method: defaultPaymentMethod as string,
        off_session: true,
        confirm: true,
        description: `${order.subscriptionProductName || "Santa's Magical Journey"} - Downsell Accepted at ${price}`,
        metadata: {
          orderId: orderId,
          downsellPrice: String(price),
          subscriptionId: order.subscriptionId,
        },
      });
      
      if (paymentIntent.status === 'succeeded') {
        order.lastChargeDate = new Date().toISOString();
        order.successfulCharges = (order.successfulCharges || 0) + 1;
        
        // Calculate next billing
        const billingIntervalDays = order.billingIntervalDays || 30;
        const nextBilling = new Date();
        nextBilling.setDate(nextBilling.getDate() + billingIntervalDays);
        order.subscriptionNextBillingDate = nextBilling.toISOString();
        
        order.activityLog.push({
          timestamp: new Date().toISOString(),
          action: 'Downsell Payment Successful',
          details: `Charged ${price.toFixed(2)} after downsell acceptance`,
          user: 'System'
        });
        
        await kv.set(`order:${orderId}`, order);
        
        console.log(`‚úÖ Downsell payment successful for order ${orderId}`);
        
        return c.json({
          success: true,
          message: `Subscription updated to ${price.toFixed(2)}/month`,
          nextBillingDate: nextBilling.toISOString()
        });
      } else {
        return c.json({
          error: "Payment failed. Please update your payment method and try again.",
          paymentStatus: paymentIntent.status
        }, 400);
      }
    } catch (error: any) {
      console.error("‚ùå Error charging downsell price:", error);
      return c.json({
        error: "Failed to process payment. Please try again or contact support.",
        details: error.message
      }, 500);
    }
  } catch (error: any) {
    console.error("‚ùå Error accepting downsell:", error);
    return c.json({ error: "Failed to accept downsell offer" }, 500);
  }
});

// Helper function to send retry email
async function sendRetryEmail(order: any, childNames: string, attemptNumber: number) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  if (!resendApiKey) return;
  
  const emailHtml = `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
      <div style="background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
        <h1 style="margin: 0;">üéÖ Payment Issue - Action Needed</h1>
      </div>
      <div style="background: #ffffff; padding: 30px; border-radius: 0 0 10px 10px;">
        <p>Hi ${order.customerInfo.name},</p>
        
        <p>We tried to process your monthly subscription for <strong>${childNames}'s</strong> Letters from Santa, but we encountered a payment issue.</p>
        
        <div style="background: #fef3c7; padding: 20px; border-radius: 8px; border-left: 4px solid #f59e0b; margin: 20px 0;">
          <p style="margin: 0;"><strong>‚ö†Ô∏è We want to ship ${childNames}'s package!</strong></p>
          <p style="margin: 10px 0 0 0;">Please update your payment method so we can send this month's magical letter.</p>
        </div>
        
        <p>What to do:</p>
        <ul>
          <li>Check that your card hasn't expired</li>
          <li>Verify there are sufficient funds available</li>
          <li>Try a different payment method if needed</li>
        </ul>
        
        <div style="text-align: center; margin: 30px 0;">
          <a href="https://billing.stripe.com/p/login/${order.stripeCustomerId || ''}" 
             style="display: inline-block; background: #16a34a; color: white; padding: 15px 40px; text-decoration: none; border-radius: 8px; font-weight: bold; font-size: 18px;">
            üéÑ Update Payment Method
          </a>
        </div>
        
        <p style="color: #dc2626;"><strong>Don't let ${childNames} miss out on the magic!</strong></p>
        
        <p style="margin-top: 30px; color: #6b7280; font-size: 14px;">
          Need help? Reply to this email or contact our support team.
        </p>
      </div>
    </div>
  `;
  
  try {
    await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${resendApiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
        to: [order.customerInfo.email],
        subject: `üéÖ Payment Issue - ${childNames}'s Letter is Waiting!`,
        html: emailHtml,
      }),
    });
    console.log(`üìß Retry email sent to ${order.customerInfo.email}`);
  } catch (error) {
    console.error("‚ùå Failed to send retry email:", error);
  }
}

// Helper function to send retry success email
async function sendRetrySuccessEmail(order: any, childNames: string) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  if (!resendApiKey) return;
  
  const emailHtml = `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
      <div style="background: linear-gradient(135deg, #16a34a 0%, #15803d 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
        <h1 style="margin: 0;">‚úÖ Payment Successful!</h1>
      </div>
      <div style="background: #ffffff; padding: 30px; border-radius: 0 0 10px 10px;">
        <p>Hi ${order.customerInfo.name},</p>
        
        <p>Great news! Your payment has been processed successfully and <strong>${childNames}'s</strong> monthly letter from Santa is being prepared! üéÖ</p>
        
        <div style="background: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: center;">
          <p style="font-size: 24px; margin: 0; color: #16a34a;"><strong>${(order.subscriptionPrice || 12).toFixed(2)}</strong></p>
          <p style="margin: 5px 0 0 0;">Monthly Subscription</p>
        </div>
        
        <p>The magic continues! Your letter will be shipped soon.</p>
        
        <p style="color: #16a34a;"><strong>üéÑ Thank you for keeping the Christmas spirit alive!</strong></p>
      </div>
    </div>
  `;
  
  try {
    await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${resendApiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
        to: [order.customerInfo.email],
        subject: `üéÖ Payment Received - ${childNames}'s Letter is On The Way!`,
        html: emailHtml,
      }),
    });
    console.log(`üìß Success email sent to ${order.customerInfo.email}`);
  } catch (error) {
    console.error("‚ùå Failed to send success email:", error);
  }
}

// Helper function to send downsell offer email
async function sendDownsellOfferEmail(order: any, childNames: string) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  if (!resendApiKey) return;
  
  const currentPrice = order.subscriptionPrice || 12;
  const option1Price = 10;
  const option2Price = 8;
  
  const emailHtml = `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
      <div style="background: linear-gradient(135deg, #7c3aed 0%, #5b21b6 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
        <h1 style="margin: 0;">üéÅ Special Offer Just For You!</h1>
      </div>
      <div style="background: #ffffff; padding: 30px; border-radius: 0 0 10px 10px;">
        <p>Hi ${order.customerInfo.name},</p>
        
        <p>We really want ${childNames} to continue receiving magical letters from Santa! üéÖ</p>
        
        <p>We've noticed you've had some payment issues. We understand that sometimes budgets are tight, especially during the holidays.</p>
        
        <div style="background: #ede9fe; padding: 20px; border-radius: 8px; border-left: 4px solid #7c3aed; margin: 20px 0;">
          <p style="margin: 0;"><strong>üíú We'd like to offer you a special discount!</strong></p>
        </div>
        
        <p><strong>Choose the price that works best for you:</strong></p>
        
        <div style="background: #f9fafb; border: 2px solid #e5e7eb; border-radius: 8px; padding: 20px; margin: 15px 0;">
          <div style="text-align: center; margin-bottom: 15px;">
            <p style="font-size: 28px; color: #16a34a; margin: 0;"><strong>${option1Price}/month</strong></p>
            <p style="margin: 5px 0; color: #6b7280;">Save ${currentPrice - option1Price}/month</p>
          </div>
          <div style="text-align: center;">
            <a href="https://santascertifiedletter.com/accept-downsell/${order.orderId}?price=${option1Price}" 
               style="display: inline-block; background: #16a34a; color: white; padding: 12px 30px; text-decoration: none; border-radius: 8px; font-weight: bold;">
              Choose ${option1Price}/month
            </a>
          </div>
        </div>
        
        <div style="background: #f9fafb; border: 2px solid #e5e7eb; border-radius: 8px; padding: 20px; margin: 15px 0;">
          <div style="text-align: center; margin-bottom: 15px;">
            <p style="font-size: 28px; color: #dc2626; margin: 0;"><strong>${option2Price}/month</strong></p>
            <p style="margin: 5px 0; color: #6b7280;">Save ${currentPrice - option2Price}/month (Best Deal!)</p>
          </div>
          <div style="text-align: center;">
            <a href="https://santascertifiedletter.com/accept-downsell/${order.orderId}?price=${option2Price}" 
               style="display: inline-block; background: #dc2626; color: white; padding: 12px 30px; text-decoration: none; border-radius: 8px; font-weight: bold;">
              Choose ${option2Price}/month
            </a>
          </div>
        </div>
        
        <p style="text-align: center; margin-top: 30px; color: #6b7280; font-size: 14px;">
          <em>This special offer is only available for a limited time.</em>
        </p>
        
        <p style="color: #7c3aed;"><strong>üéÑ Keep the magic alive for ${childNames}!</strong></p>
        
        <p style="margin-top: 30px; color: #6b7280; font-size: 14px;">
          Questions? Reply to this email - we're here to help!
        </p>
      </div>
    </div>
  `;
  
  try {
    await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${resendApiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
        to: [order.customerInfo.email],
        subject: `üéÅ Special Offer: Discounted Letters from Santa for ${childNames}!`,
        html: emailHtml,
      }),
    });
    console.log(`üìß Downsell offer email sent to ${order.customerInfo.email}`);
  } catch (error) {
    console.error("‚ùå Failed to send downsell offer email:", error);
  }
}

// ========== STRIPE WEBHOOK FOR AUTO-BILLING ==========

// Webhook endpoint for Stripe events (handles automatic monthly billing)
app.post("/make-server-cf244566/stripe-webhook", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 500);
  }

  try {
    const body = await c.req.text();
    const signature = c.req.header("stripe-signature");
    const webhookSecret = Deno.env.get("STRIPE_WEBHOOK_SECRET");

    if (!webhookSecret) {
      console.error("‚ùå STRIPE_WEBHOOK_SECRET not configured");
      return c.json({ error: "Webhook secret not configured" }, 400);
    }

    // Verify webhook signature
    let event;
    try {
      event = stripe.webhooks.constructEvent(body, signature!, webhookSecret);
    } catch (err) {
      console.error("‚ùå Webhook signature verification failed:", err);
      return c.json({ error: "Invalid signature" }, 400);
    }

    console.log(`üîî Stripe webhook received: ${event.type}`);

    // Handle successful subscription invoice payment (monthly billing)
    if (event.type === "invoice.payment_succeeded") {
      const invoice = event.data.object as any;
      
      // Only process subscription invoices (not one-time payments)
      if (invoice.subscription) {
        console.log(`üí≥ Processing subscription payment: ${invoice.subscription}`);
        
        // Find the order with this subscription
        const allOrderIds = (await kv.get("orders:all")) || [];
        let subscriptionOrder = null;
        
        for (const orderId of allOrderIds) {
          const order: any = await kv.get(`order:${orderId}`);
          if (order && order.subscriptionId === invoice.subscription) {
            subscriptionOrder = order;
            break;
          }
        }
        
        if (subscriptionOrder) {
          // Create a new monthly order (copy of original but for this month)
          console.log(`üì¶ [Auto-Billing Webhook] Creating fulfillment order. Subscription letters count: ${(subscriptionOrder.subscriptionLetters || []).length}`);
          console.log(`üì¶ [Auto-Billing Webhook] Subscription letters data:`, JSON.stringify(subscriptionOrder.subscriptionLetters));
          
          const newOrderId = `order_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          const currentDate = new Date().toISOString();
          
          // Generate new secure access token
          const accessToken = `oat_${Array.from(crypto.getRandomValues(new Uint8Array(32)))
            .map(b => b.toString(16).padStart(2, '0'))
            .join('')}`;
          
          const monthlyOrder = {
            ...subscriptionOrder,
            orderId: newOrderId,
            orderDate: currentDate,
            accessToken: accessToken,
            status: 'pending',
            total: 12.00, // Monthly subscription amount
            letters: subscriptionOrder.subscriptionLetters || [], // Copy subscription letter data for fulfillment
            stripePaymentId: invoice.payment_intent,
            stripeCheckoutUrl: `https://dashboard.stripe.com/${invoice.payment_intent?.startsWith('pi_test') ? 'test' : 'live'}/payments/${invoice.payment_intent}`,
            subscriptionMonthsActive: (subscriptionOrder.subscriptionMonthsActive || 0) + 1,
            activityLog: [{
              timestamp: currentDate,
              action: 'Monthly Order Created',
              details: `Automatic monthly billing processed. Amount: $12.00. Copied ${(subscriptionOrder.subscriptionLetters || []).length} letter(s) from subscription.`,
              user: 'System'
            }],
            createdAt: currentDate,
            updatedAt: currentDate
          };
          
          // Save new monthly order
          await kv.set(`order:${newOrderId}`, monthlyOrder);
          await kv.set(`token:${accessToken}`, newOrderId);
          
          // Add to orders index
          const allOrderIds = (await kv.get("orders:all")) || [];
          allOrderIds.push(newOrderId);
          await kv.set("orders:all", allOrderIds);
          
          // Update original subscription order
          subscriptionOrder.subscriptionMonthsActive = (subscriptionOrder.subscriptionMonthsActive || 0) + 1;
          subscriptionOrder.updatedAt = currentDate;
          await kv.set(`order:${subscriptionOrder.orderId}`, subscriptionOrder);
          
          console.log(`‚úÖ Created automatic monthly order: ${newOrderId}`);
          
          // Send customer notification about their monthly letter
          await sendMonthlyLetterNotification(monthlyOrder);
        }
      }
    }
    
    // Handle failed subscription invoice payment (declined charges)
    if (event.type === "invoice.payment_failed") {
      const invoice = event.data.object as any;
      
      // Only process subscription invoices
      if (invoice.subscription) {
        console.log(`‚ùå Subscription payment failed: ${invoice.subscription}`);
        
        // Find the order with this subscription
        const allOrderIds = (await kv.get("orders:all")) || [];
        let subscriptionOrder = null;
        
        for (const orderId of allOrderIds) {
          const order: any = await kv.get(`order:${orderId}`);
          if (order && order.subscriptionId === invoice.subscription) {
            subscriptionOrder = order;
            break;
          }
        }
        
        if (subscriptionOrder) {
          // Initialize retry tracking if not exists
          if (!subscriptionOrder.retryAttempts) {
            subscriptionOrder.retryAttempts = 0;
            subscriptionOrder.firstFailureDate = new Date().toISOString();
          }
          
          subscriptionOrder.retryAttempts++;
          subscriptionOrder.lastFailureDate = new Date().toISOString();
          subscriptionOrder.nextRetryDate = new Date(Date.now() + (48 * 60 * 60 * 1000)).toISOString(); // Retry in 2 days
          
          // Add to activity log
          if (!subscriptionOrder.activityLog) {
            subscriptionOrder.activityLog = [];
          }
          subscriptionOrder.activityLog.push({
            timestamp: new Date().toISOString(),
            action: 'Payment Failed',
            details: `Subscription payment declined. Attempt ${subscriptionOrder.retryAttempts}. Next retry: ${new Date(subscriptionOrder.nextRetryDate).toLocaleDateString()}`,
            user: 'System - Webhook'
          });
          
          await kv.set(`order:${subscriptionOrder.orderId}`, subscriptionOrder);
          
          console.log(`üìù Tracked failed payment for order ${subscriptionOrder.orderId} - Attempt ${subscriptionOrder.retryAttempts}`);
          
          // Schedule retry email (will be sent by cron job)
        }
      }
    }

    return c.json({ received: true });
  } catch (error: any) {
    console.error("‚ùå Error processing webhook:", error);
    return c.json({ error: "Webhook processing failed" }, 500);
  }
});

// Helper function to send monthly letter notification
async function sendMonthlyLetterNotification(order: any) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  const twilioAccountSid = Deno.env.get("TWILIO_ACCOUNT_SID");
  const twilioAuthToken = Deno.env.get("TWILIO_AUTH_TOKEN");
  const twilioPhoneNumber = Deno.env.get("TWILIO_PHONE_NUMBER");

  if (resendApiKey) {
    try {
      await fetch("https://api.resend.com/emails", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${resendApiKey}`,
        },
        body: JSON.stringify({
          from: "Santa's Workshop <noreply@updates.santascertifiedletter.com>",
          to: [order.customerInfo.email],
          subject: "üéÖ Your Monthly Letter from Santa is Coming!",
          html: `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
              <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÖ Santa's Magical Adventures</h1>
                <p style="margin: 10px 0 0 0; font-size: 18px;">Your Monthly Letter is On Its Way!</p>
              </div>
              <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                <p>Ho ho ho! ${order.customerInfo.name},</p>
                
                <p style="font-size: 18px;"><span style="font-size: 24px;">üéâ</span> Your monthly subscription has been renewed and your Santa letter is being prepared!</p>
                
                <div style="background-color: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0;">
                  <p><strong>Order:</strong> #${order.orderId.slice(-8)}</p>
                  <p><strong>Date:</strong> ${new Date(order.orderDate).toLocaleDateString()}</p>
                  <p><strong>Amount:</strong> ${order.total.toFixed(2)}</p>
                  <p><strong>Month:</strong> ${order.subscriptionMonthsActive}</p>
                </div>
                
                <p><strong>What's happening next?</strong></p>
                <ul style="line-height: 1.8;">
                  <li>‚ú® Santa is writing your personalized letter</li>
                  <li>üìù It will include updates on your good behavior and special activities</li>
                  <li>üìÆ Your letter will be mailed within the next few days</li>
                  <li>üìß You'll get tracking information once it ships</li>
                </ul>
                
                <p style="margin-top: 30px; text-align: center;">
                  <span style="font-size: 24px;">üéÑ</span> <strong>Keep up the great work!</strong> <span style="font-size: 24px;">üéÑ</span>
                </p>
              </div>
            </div>
          `,
        }),
      });
    } catch (error) {
      console.error("‚ùå Failed to send monthly notification email:", error);
    }
  }

  if (twilioAccountSid && twilioAuthToken && twilioPhoneNumber && order.customerInfo.phone) {
    try {
      const auth = btoa(`${twilioAccountSid}:${twilioAuthToken}`);
      await fetch(`https://api.twilio.com/2010-04-01/Accounts/${twilioAccountSid}/Messages.json`, {
        method: "POST",
        headers: {
          "Authorization": `Basic ${auth}`,
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: new URLSearchParams({
          To: order.customerInfo.phone,
          From: twilioPhoneNumber,
          Body: `üéÖ Ho ho ho! Your monthly Santa letter has been renewed and is being prepared. Order #${order.orderId.slice(-8)} - Month ${order.subscriptionMonthsActive}`,
        }),
      });
    } catch (error) {
      console.error("‚ùå Failed to send monthly notification SMS:", error);
    }
  }
}

// ========== PAYMENT METHOD UPDATE ENDPOINTS ==========

// Get order/subscription details for payment update (by encrypted token)
app.get("/make-server-cf244566/get-order-for-update/:token", async (c) => {
  try {
    const token = c.req.param("token");
    console.log(`üîç Looking up order for payment update with token: ${token}`);
    
    // Token could be either:
    // 1. A decline ID (starts with "decline_")
    // 2. An order access token (starts with "oat_")
    // 3. A special update token (starts with "upt_")
    
    let orderData: any = null;
    let declineData: any = null;
    
    // Try to find by decline ID
    if (token.startsWith("decline_")) {
      declineData = await kv.get(`decline:${token}`);
      if (declineData) {
        console.log(`‚úÖ Found decline record: ${token}`);
        
        // Return order details from decline data
        const packageCount = declineData.letterPackages?.length || 1;
        const totalAmount = declineData.amount || 0;
        const pricePerPackage = packageCount > 0 ? (totalAmount / packageCount) : 17.95;
        
        return c.json({
          success: true,
          order: {
            orderId: token,
            customerInfo: {
              name: declineData.customerInfo?.name || "",
              email: declineData.customerInfo?.email || "",
              phone: declineData.customerInfo?.phone || "",
              address: declineData.customerInfo?.address || "",
              city: declineData.customerInfo?.city || "",
              state: declineData.customerInfo?.state || "",
              zip: declineData.customerInfo?.zip || "",
            },
            letterPackages: declineData.letterPackages || [],
            total: totalAmount,
            packagePrice: pricePerPackage,
            monthlySubscription: declineData.monthlySubscription || false,
            subscriptionId: declineData.subscriptionId || null,
            stripeCustomerId: declineData.stripeCustomerId || null,
            lastFourCard: declineData.lastFourCard || null,
            declineReason: declineData.declineReason || "Payment failed",
          }
        });
      }
    }
    
    // Try to find by order access token
    if (token.startsWith("oat_")) {
      const allOrderIds = (await kv.get("orders:all")) || [];
      for (const orderId of allOrderIds) {
        const order: any = await kv.get(`order:${orderId}`);
        if (order && order.accessToken === token) {
          orderData = order;
          break;
        }
      }
    }
    
    // Try to find by custom update token
    if (token.startsWith("upt_")) {
      const updateTokenData = await kv.get(`update_token:${token}`);
      if (updateTokenData) {
        const orderId = (updateTokenData as any).orderId;
        orderData = await kv.get(`order:${orderId}`);
      }
    }
    
    if (!orderData) {
      console.log(`‚ùå Order not found for token: ${token}`);
      return c.json({ error: "Order not found or link expired" }, 404);
    }
    
    console.log(`‚úÖ Found order: ${orderData.orderId}`);
    
    // Return sanitized order details
    const packageCount = orderData.letterPackages?.length || 1;
    const totalAmount = orderData.subscriptionPrice || orderData.total || 0;
    const pricePerPackage = packageCount > 0 ? (totalAmount / packageCount) : 17.95;
    
    return c.json({
      success: true,
      order: {
        orderId: orderData.orderId,
        customerInfo: {
          name: orderData.customerInfo?.name || "",
          email: orderData.customerInfo?.email || "",
          phone: orderData.customerInfo?.phone || "",
          address: orderData.customerInfo?.address || "",
          city: orderData.customerInfo?.city || "",
          state: orderData.customerInfo?.state || "",
          zip: orderData.customerInfo?.zip || "",
        },
        letterPackages: orderData.letterPackages || [],
        total: totalAmount,
        packagePrice: pricePerPackage,
        monthlySubscription: orderData.monthlySubscription || false,
        subscriptionId: orderData.subscriptionId || null,
        stripeCustomerId: orderData.stripeCustomerId || null,
        lastFourCard: orderData.lastFourCard || null,
        nextBillingDate: orderData.subscriptionNextBillingDate || null,
      }
    });
  } catch (error: any) {
    console.error("‚ùå Error fetching order for update:", error);
    return c.json({ error: "Failed to load order details" }, 500);
  }
});

// Update payment method and charge
app.post("/make-server-cf244566/update-payment-method", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }
  
  try {
    const { token, paymentMethodId, updatedOrderData } = await c.req.json();
    
    console.log(`üí≥ Updating payment method for token: ${token}`);
    console.log(`üìù Updated order data received:`, updatedOrderData ? 'Yes' : 'No');
    
    // Get order/decline details
    let orderData: any = null;
    let declineData: any = null;
    let isDecline = false;
    
    // Check if it's a decline
    if (token.startsWith("decline_")) {
      declineData = await kv.get(`decline:${token}`);
      isDecline = true;
      
      if (!declineData) {
        return c.json({ error: "Decline record not found" }, 404);
      }
      
      // Find associated order if exists
      const allOrderIds = (await kv.get("orders:all")) || [];
      for (const orderId of allOrderIds) {
        const order: any = await kv.get(`order:${orderId}`);
        if (order && order.customerInfo?.email === declineData.customerInfo?.email && 
            order.subscriptionId === declineData.subscriptionId) {
          orderData = order;
          break;
        }
      }
    } else {
      // Get order by token
      if (token.startsWith("oat_")) {
        const allOrderIds = (await kv.get("orders:all")) || [];
        for (const orderId of allOrderIds) {
          const order: any = await kv.get(`order:${orderId}`);
          if (order && order.accessToken === token) {
            orderData = order;
            break;
          }
        }
      } else if (token.startsWith("upt_")) {
        const updateTokenData = await kv.get(`update_token:${token}`);
        if (updateTokenData) {
          const orderId = (updateTokenData as any).orderId;
          orderData = await kv.get(`order:${orderId}`);
        }
      }
      
      if (!orderData) {
        return c.json({ error: "Order not found" }, 404);
      }
    }
    
    // Apply updates to order/decline data if provided
    if (updatedOrderData) {
      console.log(`üìù Applying order updates...`);
      
      if (updatedOrderData.letterPackages) {
        if (orderData) {
          orderData.letterPackages = updatedOrderData.letterPackages;
          // Use provided total or keep existing price per package calculation
          if (updatedOrderData.total) {
            orderData.total = updatedOrderData.total;
            orderData.subscriptionPrice = updatedOrderData.total;
          }
        }
        if (declineData) {
          declineData.letterPackages = updatedOrderData.letterPackages;
          if (updatedOrderData.total) {
            declineData.amount = updatedOrderData.total;
          }
        }
      }
      
      if (updatedOrderData.customerInfo) {
        if (orderData) {
          orderData.customerInfo = { ...orderData.customerInfo, ...updatedOrderData.customerInfo };
        }
        if (declineData) {
          declineData.customerInfo = { ...declineData.customerInfo, ...updatedOrderData.customerInfo };
        }
      }
      
      // Save updated data
      if (orderData) {
        await kv.set(`order:${orderData.orderId}`, orderData);
        console.log(`‚úÖ Updated order data saved with total: ${orderData.total}`);
      }
      if (declineData && isDecline) {
        await kv.set(`decline:${token}`, declineData);
        console.log(`‚úÖ Updated decline data saved with amount: ${declineData.amount}`);
      }
    }
    
    // Get customer ID
    let customerId = orderData?.stripeCustomerId || declineData?.stripeCustomerId;
    const customerEmail = orderData?.customerInfo?.email || declineData?.customerInfo?.email;
    const customerName = orderData?.customerInfo?.name || declineData?.customerInfo?.name;
    
    // If no customer exists, create one
    if (!customerId) {
      console.log(`üÜï Creating new Stripe customer for: ${customerEmail}`);
      const customer = await stripe.customers.create({
        email: customerEmail,
        name: customerName,
        payment_method: paymentMethodId,
        invoice_settings: {
          default_payment_method: paymentMethodId,
        },
      });
      customerId = customer.id;
      
      // Update order with customer ID
      if (orderData) {
        orderData.stripeCustomerId = customerId;
        await kv.set(`order:${orderData.orderId}`, orderData);
      }
    } else {
      // Attach payment method to existing customer
      console.log(`üîó Attaching payment method to customer: ${customerId}`);
      await stripe.paymentMethods.attach(paymentMethodId, {
        customer: customerId,
      });
      
      // Set as default payment method
      await stripe.customers.update(customerId, {
        invoice_settings: {
          default_payment_method: paymentMethodId,
        },
      });
    }
    
    // Get payment method details for last 4
    const paymentMethod = await stripe.paymentMethods.retrieve(paymentMethodId);
    const lastFourCard = paymentMethod.card?.last4 || null;
    
    // Determine amount to charge
    const amount = isDecline ? (declineData.amount || 12) : (orderData.subscriptionPrice || orderData.total || 12);
    
    console.log(`üí∞ Creating payment intent for ${amount}`);
    
    // Create payment intent
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(amount * 100),
      currency: "usd",
      customer: customerId,
      payment_method: paymentMethodId,
      off_session: false,
      confirm: true,
      description: isDecline ? 
        `Recovery payment for declined order` : 
        `Subscription payment - Payment method update`,
      metadata: {
        orderId: orderData?.orderId || token,
        paymentUpdate: "true",
        declineId: isDecline ? token : undefined,
      },
      return_url: `https://santascertifiedletter.com/?page=updatepayment&token=${token}`,
    });
    
    // Check if requires additional action
    if (paymentIntent.status === "requires_action" && paymentIntent.client_secret) {
      console.log(`‚ö†Ô∏è Payment requires additional authentication`);
      return c.json({
        success: false,
        requiresAction: true,
        clientSecret: paymentIntent.client_secret,
        paymentIntentId: paymentIntent.id,
      });
    }
    
    // If payment succeeded immediately
    if (paymentIntent.status === "succeeded") {
      console.log(`‚úÖ Payment succeeded immediately`);
      
      // Create new order or update existing
      const newOrderId = await createOrderFromPaymentUpdate(
        orderData,
        declineData,
        paymentIntent,
        customerId,
        lastFourCard,
        amount
      );
      
      // Update decline record if applicable
      if (isDecline && declineData) {
        declineData.status = "converted";
        declineData.convertedDate = new Date().toISOString();
        declineData.convertedOrderId = newOrderId;
        await kv.set(`decline:${token}`, declineData);
      }
      
      // Update order if applicable
      if (orderData) {
        orderData.lastFourCard = lastFourCard;
        orderData.updatedAt = new Date().toISOString();
        
        // Reset retry counters
        orderData.retryAttempts = 0;
        orderData.firstFailureDate = null;
        orderData.lastFailureDate = null;
        orderData.nextRetryDate = null;
        
        if (!orderData.activityLog) orderData.activityLog = [];
        orderData.activityLog.push({
          timestamp: new Date().toISOString(),
          action: "Payment Method Updated",
          details: `Customer updated payment method. New card: ****${lastFourCard}. Charged ${amount.toFixed(2)}`,
          user: "Customer"
        });
        
        await kv.set(`order:${orderData.orderId}`, orderData);
      }
      
      // Send payment method update confirmation email
      try {
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        const emailTo = customerEmail || orderData?.customerInfo?.email;
        
        if (resendApiKey && emailTo) {
          const emailHtml = `
            <!DOCTYPE html>
            <html>
            <head>
              <meta charset="utf-8">
              <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
            </head>
            <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
              <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                  <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">‚úÖ Payment Method Updated!</h1>
                </div>
                <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                  <p>Hi ${customerName || 'there'},</p>
                  
                  <p style="font-size: 18px; color: #059669;"><strong>‚úÖ Your payment method has been successfully updated!</strong></p>
                  
                  <div style="background: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #16a34a;">
                    <p style="margin: 0 0 10px 0;"><strong>üí≥ New Payment Method:</strong></p>
                    <p style="font-size: 18px; margin: 0; color: #16a34a;">Card ending in ****${lastFourCard}</p>
                    <p style="margin: 10px 0 0 0; font-size: 14px; color: #166534;">
                      Amount charged: ${amount.toFixed(2)}
                    </p>
                  </div>
                  
                  ${orderData?.monthlySubscription || declineData?.subscriptionId ? `
                    <div style="background: #dbeafe; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #3b82f6;">
                      <p style="margin: 0 0 10px 0;"><strong>üéÖ Subscription Active</strong></p>
                      <p style="margin: 5px 0; font-size: 14px;">Your monthly subscription is now active and will be charged to your new payment method.</p>
                      ${orderData?.subscriptionNextBillingDate ? `
                        <p style="margin: 10px 0 0 0; font-size: 13px; color: #1e40af;">
                          Next billing date: ${new Date(orderData.subscriptionNextBillingDate).toLocaleDateString()}
                        </p>
                      ` : ''}
                    </div>
                  ` : ''}
                  
                  <div style="background: #f9fafb; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <p style="margin: 0 0 10px 0;"><strong>üìã What This Means:</strong></p>
                    <ul style="margin: 10px 0; padding-left: 20px; font-size: 14px;">
                      <li>Your new card is now saved and set as default</li>
                      <li>All future charges will use this payment method</li>
                      <li>You're all set - no further action needed!</li>
                    </ul>
                  </div>
                  
                  <div style="background: #fef2f2; padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #dc2626;">
                    <p style="margin: 0; font-size: 13px;">
                      <strong>üîí Security:</strong> For your protection, we never store your full card number. Only the last 4 digits are kept for reference.
                    </p>
                  </div>
                  
                  <p style="margin-top: 30px;">Thank you for keeping your payment information up to date!</p>
                  
                  <p style="margin-top: 20px;">Questions? Contact us at support@letterfromsanta.com</p>
                  
                  <p style="margin-top: 30px;">Merry Christmas! ‚ú®<br>The Santa Letters Team</p>
                </div>
                <div style="background: #f9fafb; padding: 20px; text-align: center; color: #6b7280; font-size: 14px; border-radius: 0 0 10px 10px;">
                  <p style="margin: 0;">¬© ${new Date().getFullYear()} Letter From Santa. All rights reserved.</p>
                </div>
              </div>
            </body>
            </html>
          `;

          const response = await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${resendApiKey}`,
            },
            body: JSON.stringify({
              from: "Santa's Workshop <noreply@letterfromsanta.com>",
              to: [emailTo],
              subject: "‚úÖ Payment Method Updated Successfully",
              html: emailHtml,
            }),
          });

          if (response.ok) {
            console.log("‚úÖ Payment method update email sent to:", emailTo);
          } else {
            const errorText = await response.text();
            console.error("‚ùå Failed to send payment update email:", errorText);
          }
        }
      } catch (emailError) {
        console.error("‚ùå Error sending payment method update email:", emailError);
      }
      
      return c.json({
        success: true,
        orderId: newOrderId,
        message: "Payment method updated and charged successfully"
      });
    }
    
    // If payment failed
    if (paymentIntent.status === "requires_payment_method" || paymentIntent.status === "canceled") {
      console.log(`‚ùå Payment failed: ${paymentIntent.status}`);
      
      // Get detailed error message
      const errorMessage = paymentIntent.last_payment_error?.message || 
                          paymentIntent.last_payment_error?.decline_code || 
                          "Your payment was declined. Please try a different card.";
      
      const declineCode = paymentIntent.last_payment_error?.decline_code;
      
      console.log(`‚ùå Decline reason: ${errorMessage}`);
      console.log(`‚ùå Decline code: ${declineCode}`);
      
      return c.json({
        success: false,
        error: errorMessage,
        declineCode: declineCode,
        paymentIntentId: paymentIntent.id
      }, 402);
    }
    
    // If payment is still processing
    return c.json({
      success: false,
      error: "Payment is processing. Please wait...",
      paymentIntentId: paymentIntent.id
    }, 202);
    
  } catch (error: any) {
    console.error("‚ùå Error updating payment method:", error);
    return c.json({ 
      error: error.message || "Failed to update payment method",
      details: error.raw?.message 
    }, 500);
  }
});

// Confirm payment after 3D Secure
app.post("/make-server-cf244566/confirm-payment-update", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }
  
  try {
    const { token, paymentIntentId } = await c.req.json();
    
    console.log(`‚úÖ Confirming payment update: ${paymentIntentId}`);
    
    // Retrieve payment intent
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
    
    if (paymentIntent.status !== "succeeded") {
      return c.json({ error: "Payment not completed" }, 400);
    }
    
    // Get order/decline details
    let orderData: any = null;
    let declineData: any = null;
    let isDecline = false;
    
    if (token.startsWith("decline_")) {
      declineData = await kv.get(`decline:${token}`);
      isDecline = true;
    } else {
      const allOrderIds = (await kv.get("orders:all")) || [];
      for (const orderId of allOrderIds) {
        const order: any = await kv.get(`order:${orderId}`);
        if (order && order.accessToken === token) {
          orderData = order;
          break;
        }
      }
    }
    
    // Get payment method details
    const paymentMethod = await stripe.paymentMethods.retrieve(paymentIntent.payment_method as string);
    const lastFourCard = paymentMethod.card?.last4 || null;
    const customerId = paymentIntent.customer as string;
    const amount = paymentIntent.amount / 100;
    
    // Create order
    const newOrderId = await createOrderFromPaymentUpdate(
      orderData,
      declineData,
      paymentIntent,
      customerId,
      lastFourCard,
      amount
    );
    
    // Update records
    if (isDecline && declineData) {
      declineData.status = "converted";
      declineData.convertedDate = new Date().toISOString();
      declineData.convertedOrderId = newOrderId;
      await kv.set(`decline:${token}`, declineData);
    }
    
    if (orderData) {
      orderData.lastFourCard = lastFourCard;
      orderData.updatedAt = new Date().toISOString();
      orderData.retryAttempts = 0;
      orderData.firstFailureDate = null;
      orderData.lastFailureDate = null;
      orderData.nextRetryDate = null;
      
      if (!orderData.activityLog) orderData.activityLog = [];
      orderData.activityLog.push({
        timestamp: new Date().toISOString(),
        action: "Payment Method Updated",
        details: `Customer updated payment method after 3DS. New card: ****${lastFourCard}. Charged ${amount.toFixed(2)}`,
        user: "Customer"
      });
      
      await kv.set(`order:${orderData.orderId}`, orderData);
    }
    
    return c.json({
      success: true,
      orderId: newOrderId,
      message: "Payment confirmed and order created"
    });
    
  } catch (error: any) {
    console.error("‚ùå Error confirming payment update:", error);
    return c.json({ error: error.message || "Failed to confirm payment" }, 500);
  }
});

// Helper function to create order from payment update
async function createOrderFromPaymentUpdate(
  existingOrder: any,
  declineData: any,
  paymentIntent: any,
  customerId: string,
  lastFourCard: string | null,
  amount: number
): Promise<string> {
  const orderId = `order_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const orderDate = new Date().toISOString();
  
  // Generate access token
  const accessToken = `oat_${Array.from(crypto.getRandomValues(new Uint8Array(32)))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('')}`;
  
  // Use existing order data or decline data
  const sourceData = existingOrder || declineData;
  
  const orderData = {
    orderId,
    orderDate,
    accessToken,
    stripePaymentId: paymentIntent.id,
    stripeCheckoutUrl: `https://dashboard.stripe.com/${paymentIntent.id.startsWith('pi_test') ? 'test' : 'live'}/payments/${paymentIntent.id}`,
    status: "unfulfilled",
    total: amount,
    customerInfo: sourceData.customerInfo,
    letterPackages: sourceData.letterPackages || [],
    numberOfPackages: sourceData.letterPackages?.length || 0,
    shippingDate: sourceData.shippingDate || "",
    monthlySubscription: sourceData.monthlySubscription || false,
    subscriptionId: sourceData.subscriptionId || null,
    stripeCustomerId: customerId,
    subscriptionMonthsActive: existingOrder ? (existingOrder.subscriptionMonthsActive || 0) + 1 : 0,
    subscriptionStartDate: existingOrder?.subscriptionStartDate || orderDate,
    subscriptionNextBillingDate: existingOrder ? calculateNextBillingDate(existingOrder.billingIntervalDays || 30) : undefined,
    billingIntervalDays: existingOrder?.billingIntervalDays || 30,
    affiliateId: existingOrder?.affiliateId || null,
    affiliateName: existingOrder?.affiliateName || null,
    affiliateCommission: existingOrder?.affiliateId ? amount * 0.10 : null,
    lastFourCard: lastFourCard,
    trafficSource: existingOrder?.trafficSource || "direct",
    parentOrderId: existingOrder?.orderId || null,
    activityLog: [{
      timestamp: orderDate,
      action: "Order Created",
      details: `Payment method updated and charged ${amount.toFixed(2)}`,
      user: "Customer"
    }],
    archived: false,
    createdAt: orderDate,
    updatedAt: orderDate
  };
  
  await kv.set(`order:${orderId}`, orderData);
  
  // Add to orders list
  const allOrderIds = (await kv.get("orders:all")) || [];
  allOrderIds.push(orderId);
  await kv.set("orders:all", allOrderIds);
  
  // Send confirmation email
  await sendPaymentUpdateConfirmationEmail(orderData);
  
  console.log(`‚úÖ Created order from payment update: ${orderId}`);
  
  return orderId;
}

// Helper to calculate next billing date
function calculateNextBillingDate(intervalDays: number): string {
  const nextDate = new Date();
  nextDate.setDate(nextDate.getDate() + intervalDays);
  return nextDate.toISOString();
}

// Helper to send payment update confirmation email
async function sendPaymentUpdateConfirmationEmail(order: any) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  if (!resendApiKey) return;
  
  const emailHtml = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
    </head>
    <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
      <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
          <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÖ Payment Updated Successfully!</h1>
        </div>
        <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
          <p>Hi ${order.customerInfo.name},</p>
          
          <p style="font-size: 18px; color: #059669;"><strong>‚úÖ Your payment method has been updated and your order is being processed!</strong></p>
          
          <div style="background: #f0fdf4; border-left: 4px solid #059669; padding: 15px; margin: 20px 0;">
            <p style="margin: 0; font-size: 16px;"><strong>Order Details:</strong></p>
            <p style="margin: 5px 0 0 0;">Order #${order.orderId.slice(-8)}</p>
            <p style="margin: 5px 0 0 0;">Amount: ${order.total.toFixed(2)}</p>
          </div>
          
          <p><strong>Your letter packages:</strong></p>
          <ul style="background: #f3f4f6; padding: 20px; border-radius: 8px;">
            ${order.letterPackages.map((pkg: any) => `
              <li style="margin: 10px 0;">
                Letter for <strong>${pkg.childFirstName} ${pkg.childLastName}</strong>
              </li>
            `).join('')}
          </ul>
          
          ${order.monthlySubscription ? `
            <div style="background: #dbeafe; border-left: 4px solid #3b82f6; padding: 15px; margin: 20px 0;">
              <p style="margin: 0; font-size: 16px;"><strong>üìÖ Monthly Subscription Active</strong></p>
              <p style="margin: 5px 0 0 0;">You'll continue receiving magical letters monthly.</p>
            </div>
          ` : ''}
          
          <p style="margin-top: 30px; color: #6b7280; font-size: 14px;">
            Your letters are being prepared and will ship soon. We'll send you tracking information shortly!
          </p>
        </div>
        <div style="background: #f9fafb; padding: 20px; text-align: center; color: #6b7280; font-size: 12px; border-radius: 0 0 10px 10px;">
          <p>Questions? Contact us at support@santascertifiedletter.com</p>
          <p style="margin-top: 10px; color: #9ca3af;">¬© 2025 Letters From Santa. All rights reserved.</p>
        </div>
      </div>
    </body>
    </html>
  `;
  
  try {
    await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${resendApiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        from: EMAIL_FROM,
        to: [order.customerInfo.email],
        subject: "üéÖ Payment Updated - Your Santa Letters Are On The Way!",
        html: emailHtml,
      }),
    });
    console.log(`üìß Payment update confirmation email sent to ${order.customerInfo.email}`);
  } catch (error) {
    console.error("‚ùå Failed to send payment update email:", error);
  }
}

// ============================================
// UPSELL FUNNEL ROUTES
// ============================================

// Get active upsells for admin
app.get("/make-server-cf244566/admin/upsells", async (c) => {
  try {
    const allUpsellIds = (await kv.get("upsells:all")) || [];
    const upsells = [];
    
    // If no upsells exist, create the default products
    if (allUpsellIds.length === 0) {
      const defaultSnowUpsell = {
        id: "upsell_north_pole_snow",
        name: "Certified North Pole Snow",
        description: "Authentic snow from the North Pole! Our premium certified snow powder expands up to 100x its size when water is added. Direct from Santa's workshop - perfect for Christmas decorations, crafts, and creating memorable Santa experiences!",
        price: 9.99,
        imageUrl: "figma:asset/17a13766bc697fc8dd73632f6223611df59e7213.png",
        active: true,
        promoText: "üéÑ SPECIAL OFFER: Add authentic North Pole snow to your Santa experience!",
        features: [
          "Certified authentic from the North Pole",
          "Expands up to 100x its original size",
          "Looks and feels like real snow",
          "Safe, non-toxic, and reusable",
          "Perfect for Christmas decorations and photos",
          "Makes approximately 2 gallons of snow"
        ],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
      
      const subscriptionUpsell = {
        id: "upsell_magical_journey",
        name: "Santa's Magical Journey",
        description: "Join Santa's Magical Journey and receive a personalized letter every month! Watch your child's excitement grow as Santa shares his adventures from around the world.",
        price: 12.00,
        imageUrl: "",
        active: true,
        isSubscription: true,
        promoText: "üéÖ SPECIAL OFFER: Continue the magic all year long!",
        features: [
          "FREE: Welcome package with your first letter",
          "Monthly personalized letters from Santa",
          "Santa shares his travels from around the world",
          "Unique stories and adventures each month",
          "Customized for each child by name",
          "Cancel anytime - no commitments!"
        ],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
      
      await kv.set(`upsell:${defaultSnowUpsell.id}`, defaultSnowUpsell);
      await kv.set(`upsell:${subscriptionUpsell.id}`, subscriptionUpsell);
      await kv.set("upsells:all", [defaultSnowUpsell.id, subscriptionUpsell.id]);
      
      console.log("‚úÖ Created default upsells: North Pole Snow + Santa's Magical Journey");
      
      return c.json({ success: true, upsells: [defaultSnowUpsell, subscriptionUpsell] });
    }
    
    for (const id of allUpsellIds) {
      const upsell = await kv.get(`upsell:${id}`);
      if (upsell) {
        upsells.push(upsell);
      }
    }
    
    return c.json({ success: true, upsells });
  } catch (error: any) {
    console.error("‚ùå Error fetching upsells:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Create or update upsell product
app.post("/make-server-cf244566/admin/upsell/save", async (c) => {
  try {
    const upsellData = await c.req.json();
    
    const allUpsellIds = (await kv.get("upsells:all")) || [];
    
    if (!upsellData.id) {
      // Create new upsell with generated ID
      upsellData.id = `upsell_${Date.now()}`;
      upsellData.createdAt = new Date().toISOString();
      allUpsellIds.push(upsellData.id);
      await kv.set("upsells:all", allUpsellIds);
    } else {
      // Check if this ID already exists in the list
      if (!allUpsellIds.includes(upsellData.id)) {
        // Add to the list if it's a new ID
        allUpsellIds.push(upsellData.id);
        await kv.set("upsells:all", allUpsellIds);
      }
      // Preserve createdAt if updating existing upsell
      const existingUpsell = await kv.get(`upsell:${upsellData.id}`);
      if (existingUpsell && (existingUpsell as any).createdAt) {
        upsellData.createdAt = (existingUpsell as any).createdAt;
      } else {
        upsellData.createdAt = new Date().toISOString();
      }
    }
    
    upsellData.updatedAt = new Date().toISOString();
    
    await kv.set(`upsell:${upsellData.id}`, upsellData);
    
    console.log(`‚úÖ Upsell saved: ${upsellData.id}`, upsellData);
    
    return c.json({ success: true, upsell: upsellData });
  } catch (error: any) {
    console.error("‚ùå Error saving upsell:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Delete upsell
app.delete("/make-server-cf244566/admin/upsell/:id", async (c) => {
  try {
    const id = c.req.param("id");
    
    await kv.del(`upsell:${id}`);
    
    const allUpsellIds = (await kv.get("upsells:all")) || [];
    const updatedIds = allUpsellIds.filter((uid: string) => uid !== id);
    await kv.set("upsells:all", updatedIds);
    
    console.log(`‚úÖ Upsell deleted: ${id}`);
    
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error deleting upsell:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Get next upsell offer for customer
app.get("/make-server-cf244566/upsell/get-offer/:token", async (c) => {
  try {
    const token = c.req.param("token");
    
    // Get order by access token
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === token) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    // Get all active upsells
    const allUpsellIds = (await kv.get("upsells:all")) || [];
    const activeUpsells = [];
    
    for (const id of allUpsellIds) {
      const upsell: any = await kv.get(`upsell:${id}`);
      if (upsell && upsell.active) {
        activeUpsells.push(upsell);
      }
    }
    
    // Sort upsells: non-subscriptions first, subscriptions last
    activeUpsells.sort((a, b) => {
      if (a.isSubscription && !b.isSubscription) return 1;
      if (!a.isSubscription && b.isSubscription) return -1;
      return 0;
    });
    
    if (activeUpsells.length === 0) {
      return c.json({ noMoreUpsells: true });
    }
    
    // Initialize upsell tracking if not exists
    if (!order.upsellsOffered) {
      order.upsellsOffered = [];
      order.upsellsAccepted = [];
      order.upsellDeclineAttempts = {}; // Track decline attempts per upsell
    }
    if (!order.upsellDeclineAttempts) {
      order.upsellDeclineAttempts = {};
    }
    
    // Find next upsell that hasn't been fully declined (max 2 attempts)
    let nextUpsell = null;
    let currentPrice = null;
    let attemptNumber = 1;
    
    for (const upsell of activeUpsells) {
      const attempts = order.upsellDeclineAttempts[upsell.id] || 0;
      
      // If already accepted or declined 2 times, skip
      if (order.upsellsAccepted?.some((a: any) => a.upsellId === upsell.id)) {
        continue;
      }
      if (attempts >= 2) {
        continue;
      }
      
      // Special handling for subscription upsell
      if (upsell.isSubscription) {
        // Skip if customer already has an active subscription (they checked the box on checkout)
        if (order.monthlySubscription && order.subscriptionId) {
          console.log(`‚è≠Ô∏è Skipping subscription upsell - customer already subscribed on checkout`);
          continue;
        }
      }
      
      nextUpsell = upsell;
      attemptNumber = attempts + 1;
      
      // Calculate downsell pricing based on product type
      if (upsell.isSubscription) {
        // Santa's Magical Journey: $12 -> $10 (ONLY 2 attempts)
        if (attemptNumber === 1) {
          currentPrice = upsell.price; // $12
        } else {
          currentPrice = 10.00; // Final downsell
        }
      } else {
        // Regular products (North Pole Snow): $9.99 -> $7.99 (ONLY 2 attempts)
        if (attemptNumber === 1) {
          currentPrice = upsell.price; // Original price
        } else {
          currentPrice = 7.99; // Final downsell
        }
      }
      
      break;
    }
    
    if (!nextUpsell) {
      return c.json({ noMoreUpsells: true });
    }
    
    // Mark as offered if first attempt
    if (attemptNumber === 1 && !order.upsellsOffered.includes(nextUpsell.id)) {
      order.upsellsOffered.push(nextUpsell.id);
    }
    
    await kv.set(`order:${order.orderId}`, order);
    
    // Suggested quantity: for subscriptions default to 1, for products match letter packages
    const suggestedQuantity = nextUpsell.isSubscription ? 1 : (order.letterPackages?.length || 1);
    
    console.log(`üì¶ Offering upsell ${nextUpsell.id} to order ${order.orderId} (Attempt ${attemptNumber}, Price: ${currentPrice})`);
    
    return c.json({
      success: true,
      upsell: {
        ...nextUpsell,
        price: currentPrice // Override with downsell price
      },
      suggestedQuantity,
      attemptNumber,
      isDownsell: attemptNumber > 1
    });
  } catch (error: any) {
    console.error("‚ùå Error getting upsell offer:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Accept upsell and charge customer
app.post("/make-server-cf244566/upsell/accept", async (c) => {
  try {
    const { orderToken, upsellId, quantity, source = "upsell_funnel" } = await c.req.json();
    
    if (!orderToken || !upsellId || !quantity || quantity < 1) {
      return c.json({ error: "Invalid request" }, 400);
    }
    
    // Get order
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === orderToken) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    // Get upsell product
    const upsell: any = await kv.get(`upsell:${upsellId}`);
    if (!upsell) {
      return c.json({ error: "Upsell product not found" }, 404);
    }
    
    // Get the actual price (may be downsell price)
    const attempts = order.upsellDeclineAttempts?.[upsellId] || 0;
    let actualPrice = upsell.price;
    
    if (upsell.isSubscription) {
      if (attempts === 1) actualPrice = 10.00;
    } else {
      if (attempts === 1) actualPrice = 7.99;
    }
    
    const totalAmount = actualPrice * quantity;
    
    console.log(`üí≥ Processing upsell: ${totalAmount.toFixed(2)} for ${quantity}x ${upsell.name} (${upsell.isSubscription ? 'Subscription' : 'One-time'})`);
    
    // Initialize Stripe
    const stripe = Stripe(Deno.env.get("STRIPE_SECRET_KEY") || "", {
      apiVersion: "2023-10-16",
    });
    
    if (!order.stripeCustomerId) {
      return c.json({ error: "No customer on file" }, 400);
    }
    
    // If no payment method stored, try to get it from Stripe customer
    if (!order.stripePaymentMethodId) {
      console.log("‚ö†Ô∏è No payment method stored, retrieving from Stripe customer...");
      try {
        const customer: any = await stripe.customers.retrieve(order.stripeCustomerId);
        const defaultPaymentMethod = customer.invoice_settings?.default_payment_method || customer.default_source;
        
        if (!defaultPaymentMethod) {
          // Try to get the first attached payment method
          const paymentMethods = await stripe.paymentMethods.list({
            customer: order.stripeCustomerId,
            type: 'card',
            limit: 1
          });
          
          if (paymentMethods.data.length > 0) {
            order.stripePaymentMethodId = paymentMethods.data[0].id;
            console.log("‚úÖ Found payment method from customer:", order.stripePaymentMethodId);
            // Save it back to order for future use
            await kv.set(`order:${order.orderId}`, order);
          } else {
            return c.json({ error: "No payment method on file" }, 400);
          }
        } else {
          order.stripePaymentMethodId = defaultPaymentMethod as string;
          console.log("‚úÖ Retrieved default payment method:", order.stripePaymentMethodId);
          // Save it back to order for future use
          await kv.set(`order:${order.orderId}`, order);
        }
      } catch (error: any) {
        console.error("‚ùå Error retrieving payment method:", error);
        return c.json({ error: "Unable to retrieve payment method" }, 400);
      }
    }
    
    let paymentIntent: any = null;
    let subscriptionId = null;
    
    if (upsell.isSubscription) {
      // Create subscription for Santa's Magical Journey
      console.log(`üìÖ Creating subscription at ${actualPrice}/month for ${quantity} kid(s)`);
      
      // First, create or get the product
      let product;
      try {
        // Try to retrieve existing product by metadata
        const products = await stripe.products.search({
          query: `metadata['upsell_id']:'${upsell.id}'`,
          limit: 1
        });
        
        if (products.data.length > 0) {
          product = products.data[0];
          console.log(`‚úÖ Using existing product: ${product.id}`);
        } else {
          // Create new product
          product = await stripe.products.create({
            name: `${upsell.name} - Monthly Letters`,
            description: `Personalized monthly letters from Santa`,
            metadata: {
              upsell_id: upsell.id,
              type: 'subscription'
            }
          });
          console.log(`‚úÖ Created new product: ${product.id}`);
        }
      } catch (productError: any) {
        console.error('Error with product:', productError);
        // Fallback: create product without search
        product = await stripe.products.create({
          name: `${upsell.name} - Monthly Letters`,
          description: `Personalized monthly letters from Santa`,
          metadata: {
            upsell_id: upsell.id,
            type: 'subscription'
          }
        });
      }
      
      // Create a price for this product
      const price = await stripe.prices.create({
        product: product.id,
        unit_amount: Math.round(actualPrice * 100),
        currency: 'usd',
        recurring: {
          interval: 'month',
        },
      });
      
      const subscription = await stripe.subscriptions.create({
        customer: order.stripeCustomerId,
        items: [{
          price: price.id,
          quantity: quantity,
        }],
        payment_behavior: 'default_incomplete',
        payment_settings: { 
          save_default_payment_method: 'on_subscription',
          payment_method_types: ['card']
        },
        expand: ['latest_invoice.payment_intent'],
        metadata: {
          orderId: order.orderId,
          packageType: 'magical_journey',
          numberOfKids: quantity.toString(),
          pricePerKid: actualPrice.toString()
        }
      });
      
      subscriptionId = subscription.id;
      
      // Confirm the payment
      const invoice: any = subscription.latest_invoice;
      paymentIntent = invoice.payment_intent;
      
      if (paymentIntent.status === 'requires_payment_method' || paymentIntent.status === 'requires_confirmation') {
        const confirmed = await stripe.paymentIntents.confirm(paymentIntent.id, {
          payment_method: order.stripePaymentMethodId
        });
        paymentIntent = confirmed;
      }
      
      if (paymentIntent.status !== 'succeeded') {
        console.error(`‚ùå Subscription payment failed: ${paymentIntent.status}`);
        // Cancel the subscription
        await stripe.subscriptions.cancel(subscriptionId);
        return c.json({ 
          error: "Payment was declined. Please contact support.",
          declineCode: paymentIntent.last_payment_error?.code
        }, 402);
      }
      
      // Update order with subscription info
      order.subscription = {
        subscriptionId: subscription.id,
        status: subscription.status,
        currentPeriodEnd: new Date(subscription.current_period_end * 1000).toISOString(),
        pricePerMonth: actualPrice,
        numberOfKids: quantity,
        createdAt: new Date().toISOString()
      };
      
      console.log(`‚úÖ Subscription created: ${subscriptionId}`);
    } else {
      // One-time charge for regular products
      paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(totalAmount * 100),
        currency: 'usd',
        customer: order.stripeCustomerId,
        payment_method: order.stripePaymentMethodId,
        off_session: true,
        confirm: true,
        description: `Upsell: ${quantity}x ${upsell.name} - Order ${order.orderId}`,
        metadata: {
          orderId: order.orderId,
          upsellId: upsell.id,
          quantity: quantity.toString(),
          type: 'upsell'
        }
      });
      
      if (paymentIntent.status !== 'succeeded') {
        console.error(`‚ùå Upsell payment failed: ${paymentIntent.status}`);
        return c.json({ 
          error: "Payment was declined. Please contact support.",
          declineCode: paymentIntent.last_payment_error?.code
        }, 402);
      }
    }
    
    // Add upsell to order
    if (!order.upsellsAccepted) {
      order.upsellsAccepted = [];
    }
    
    order.upsellsAccepted.push({
      upsellId: upsell.id,
      name: upsell.name,
      quantity,
      price: actualPrice,
      total: totalAmount,
      chargedAt: new Date().toISOString(),
      stripePaymentIntentId: paymentIntent.id,
      isSubscription: upsell.isSubscription || false,
      subscriptionId: subscriptionId,
      source: source // Track where the upsell was accepted: "checkout", "upsell_funnel", or "success_page"
    });
    
    // Update order total
    order.total = (order.total || 0) + totalAmount;
    order.updatedAt = new Date().toISOString();
    
    // Add activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: upsell.isSubscription ? 'Subscription Upsell Accepted' : 'Upsell Accepted',
      details: upsell.isSubscription 
        ? `${quantity}x ${upsell.name} - ${actualPrice}/month subscription started - First payment: ${totalAmount.toFixed(2)}`
        : `${quantity}x ${upsell.name} - ${totalAmount.toFixed(2)} charged`,
      user: 'Customer',
      stripeUrl: subscriptionId 
        ? `https://dashboard.stripe.com/subscriptions/${subscriptionId}`
        : `https://dashboard.stripe.com/payments/${paymentIntent.id}`
    });
    
    await kv.set(`order:${order.orderId}`, order);
    
    console.log(`‚úÖ Upsell accepted and charged: ${upsellId}`);
    
    // Send upsell confirmation email
    try {
      const resendApiKey = Deno.env.get("RESEND_API_KEY");
      if (resendApiKey && order.customerInfo?.email) {
        const emailHtml = `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
          </head>
          <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÅ ${upsell.isSubscription ? 'Subscription Started!' : 'Item Added to Your Order!'}</h1>
              </div>
              <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                <p>Hi ${order.customerInfo.name || 'there'},</p>
                
                <p style="font-size: 18px; color: #059669;"><strong>‚úÖ Great choice! Your order has been updated.</strong></p>
                
                <div style="background: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #16a34a;">
                  <p style="margin: 0 0 10px 0;"><strong>Item Added:</strong></p>
                  <p style="font-size: 20px; margin: 0; color: #16a34a;"><strong>${quantity}x ${upsell.name}</strong></p>
                  ${upsell.isSubscription ? `
                    <p style="margin: 10px 0 0 0; font-size: 14px; color: #166534;">
                      üí≥ Monthly subscription at ${actualPrice.toFixed(2)}/month per child<br>
                      üìÖ First payment charged today: ${totalAmount.toFixed(2)}<br>
                      üîÑ Next billing: ${new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toLocaleDateString()}
                    </p>
                  ` : `
                    <p style="margin: 10px 0 0 0; font-size: 14px; color: #166534;">
                      üí≥ Amount charged: ${totalAmount.toFixed(2)}
                    </p>
                  `}
                </div>
                
                ${upsell.isSubscription ? `
                  <div style="background: #dbeafe; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #3b82f6;">
                    <p style="margin: 0 0 10px 0;"><strong>üéÖ Welcome to Santa's Magical Journey!</strong></p>
                    <p style="margin: 5px 0; font-size: 14px;">You're now subscribed to receive monthly personalized letters from Santa. Each month includes:</p>
                    <ul style="margin: 10px 0; padding-left: 20px; font-size: 14px;">
                      <li>A personalized letter from Santa</li>
                      <li>A postcard from his latest destination</li>
                      <li>Enchanting stories and cultural insights</li>
                      <li>Fun activities and illustrations</li>
                    </ul>
                    <p style="margin: 10px 0 0 0; font-size: 13px; color: #1e40af;">
                      You can manage or cancel your subscription anytime from your order confirmation email.
                    </p>
                  </div>
                ` : ''}
                
                <div style="background: #f9fafb; padding: 20px; border-radius: 8px; margin: 20px 0;">
                  <p style="margin: 0 0 10px 0;"><strong>üìã Order Summary:</strong></p>
                  <p style="margin: 5px 0;"><strong>Order #:</strong> ${order.orderId.slice(-8)}</p>
                  <p style="margin: 5px 0;"><strong>Updated Total:</strong> ${order.total.toFixed(2)}</p>
                </div>
                
                <p style="margin-top: 30px;">Thank you for your purchase! The magic continues... ‚ú®</p>
              </div>
              <div style="background: #f9fafb; padding: 20px; text-align: center; color: #6b7280; font-size: 14px; border-radius: 0 0 10px 10px;">
                <p>Questions? Contact us at support@letterfromsanta.com</p>
                <p style="margin: 5px 0 0 0;">¬© ${new Date().getFullYear()} Letter From Santa. All rights reserved.</p>
              </div>
            </div>
          </body>
          </html>
        `;

        const response = await fetch("https://api.resend.com/emails", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${resendApiKey}`,
          },
          body: JSON.stringify({
            from: EMAIL_FROM,
            to: [order.customerInfo.email],
            subject: upsell.isSubscription 
              ? `üéÖ Subscription Started - Santa's Magical Journey!`
              : `üéÅ Item Added to Your Order - ${upsell.name}`,
            html: emailHtml,
          }),
        });

        if (response.ok) {
          console.log("‚úÖ Upsell confirmation email sent to:", order.customerInfo.email);
        } else {
          const errorText = await response.text();
          console.error("ÔøΩÔøΩ Failed to send upsell email:", errorText);
        }
      }
    } catch (emailError) {
      console.error("‚ùå Error sending upsell confirmation email:", emailError);
    }
    
    return c.json({ 
      success: true,
      chargedAmount: totalAmount,
      paymentIntentId: paymentIntent.id,
      subscriptionId: subscriptionId,
      isSubscription: upsell.isSubscription || false
    });
  } catch (error: any) {
    console.error("‚ùå Error accepting upsell:", error);
    
    // Check if it's a Stripe error
    if (error.type === 'StripeCardError' || error.code) {
      return c.json({ 
        error: error.message || "Payment was declined",
        declineCode: error.code
      }, 402);
    }
    
    return c.json({ error: error.message }, 500);
  }
});

// Accept snow upsell (funnel - $9.99)
app.post("/make-server-cf244566/upsell/accept-snow", async (c) => {
  try {
    const { orderToken, quantity } = await c.req.json();
    
    if (!orderToken || !quantity || quantity < 1) {
      return c.json({ error: "Invalid request" }, 400);
    }
    
    // Get order
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === orderToken) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!stripe) {
      return c.json({ error: "Payment system not configured" }, 503);
    }
    
    const pricePerUnit = 9.99;
    const totalAmount = pricePerUnit * quantity;
    
    try {
      // Charge using saved payment method
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(totalAmount * 100),
        currency: 'usd',
        customer: order.stripeCustomerId,
        payment_method: order.stripePaymentMethodId,
        off_session: true,
        confirm: true,
        description: `Certified North Pole Snow (${quantity}x) - Order ${order.orderId}`,
        metadata: {
          orderId: order.orderId,
          upsellType: 'snow',
          quantity: quantity.toString(),
          price: pricePerUnit.toString(),
          source: 'funnel_upsell'
        }
      });
      
      // Add to order
      if (!order.acceptedUpsells) {
        order.acceptedUpsells = [];
      }
      
      order.acceptedUpsells.push({
        id: 'snow_upsell',
        name: 'Certified North Pole Snow',
        price: pricePerUnit,
        quantity,
        total: totalAmount,
        acceptedAt: new Date().toISOString(),
        paymentIntentId: paymentIntent.id,
        source: 'funnel_upsell'
      });
      
      order.total += totalAmount;
      order.updatedAt = new Date().toISOString();
      
      // Add activity log entry
      if (!order.activityLog) {
        order.activityLog = [];
      }
      order.activityLog.push({
        timestamp: new Date().toISOString(),
        action: 'Upsell Accepted - Certified North Pole Snow',
        details: `Certified North Pole Snow - Quantity: ${quantity}, Amount: ${totalAmount.toFixed(2)}`,
        user: 'Customer',
        stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntent.id}`
      });
      
      await kv.set(`order:${order.orderId}`, order);
      
      console.log(`‚úÖ Snow upsell accepted: Order ${order.orderId}, Quantity: ${quantity}, Amount: ${totalAmount}`);
      
      return c.json({ 
        success: true,
        chargedAmount: totalAmount,
        paymentIntentId: paymentIntent.id
      });
    } catch (error: any) {
      console.error("‚ùå Error charging for snow upsell:", error);
      
      if (error.type === 'StripeCardError' || error.code) {
        return c.json({ 
          error: error.message || "Payment was declined",
          declineCode: error.code
        }, 402);
      }
      
      throw error;
    }
  } catch (error: any) {
    console.error("‚ùå Error accepting snow upsell:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Accept snow downsell (funnel - $7.99)
app.post("/make-server-cf244566/upsell/accept-snow-downsell", async (c) => {
  try {
    const { orderToken, quantity } = await c.req.json();
    
    if (!orderToken || !quantity || quantity < 1) {
      return c.json({ error: "Invalid request" }, 400);
    }
    
    // Get order
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === orderToken) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!stripe) {
      return c.json({ error: "Payment system not configured" }, 503);
    }
    
    const pricePerUnit = 7.99;
    const totalAmount = pricePerUnit * quantity;
    
    try {
      // Charge using saved payment method
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(totalAmount * 100),
        currency: 'usd',
        customer: order.stripeCustomerId,
        payment_method: order.stripePaymentMethodId,
        off_session: true,
        confirm: true,
        description: `Certified North Pole Snow - SPECIAL DISCOUNT (${quantity}x) - Order ${order.orderId}`,
        metadata: {
          orderId: order.orderId,
          upsellType: 'snow_downsell',
          quantity: quantity.toString(),
          price: pricePerUnit.toString(),
          source: 'funnel_downsell'
        }
      });
      
      // Add to order
      if (!order.acceptedUpsells) {
        order.acceptedUpsells = [];
      }
      
      order.acceptedUpsells.push({
        id: 'snow_downsell',
        name: 'Certified North Pole Snow (Special Discount)',
        price: pricePerUnit,
        quantity,
        total: totalAmount,
        acceptedAt: new Date().toISOString(),
        paymentIntentId: paymentIntent.id,
        source: 'funnel_downsell',
        originalPrice: 9.99,
        discount: 2.00
      });
      
      order.total += totalAmount;
      order.updatedAt = new Date().toISOString();
      
      // Add activity log entry
      if (!order.activityLog) {
        order.activityLog = [];
      }
      const savings = 2.00 * quantity;
      order.activityLog.push({
        timestamp: new Date().toISOString(),
        action: 'Upsell Accepted - Snow Downsell',
        details: `Certified North Pole Snow (Special Discount) - Quantity: ${quantity}, Amount: ${totalAmount.toFixed(2)} (saved ${savings.toFixed(2)})`,
        user: 'Customer',
        stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntent.id}`
      });
      
      await kv.set(`order:${order.orderId}`, order);
      
      console.log(`‚úÖ Snow downsell accepted: Order ${order.orderId}, Quantity: ${quantity}, Amount: ${totalAmount}`);
      
      return c.json({ 
        success: true,
        chargedAmount: totalAmount,
        paymentIntentId: paymentIntent.id
      });
    } catch (error: any) {
      console.error("‚ùå Error charging for snow downsell:", error);
      
      if (error.type === 'StripeCardError' || error.code) {
        return c.json({ 
          error: error.message || "Payment was declined",
          declineCode: error.code
        }, 402);
      }
      
      throw error;
    }
  } catch (error: any) {
    console.error("‚ùå Error accepting snow downsell:", error);
    return c.json({ error: error.message }, 500);
  }
});

// OLD ROUTE - DISABLED - Duplicate route that doesn't handle subscriptions properly
// The correct route with subscription support is further down in the file (line ~11007)
/*
// Create payment intent for upsell from success page
app.post("/make-server-cf244566/order/:token/create-upsell-payment", async (c) => {
  try {
    const token = c.req.param("token");
    const { upsellId, upsellName, price, quantity } = await c.req.json();
    
    if (!token || !upsellId || !upsellName || !price || !quantity || quantity < 1) {
      return c.json({ error: "Invalid request" }, 400);
    }
    
    // Get order by token
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === token) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      console.error("‚ùå Order not found for token:", token);
      return c.json({ error: "Order not found" }, 404);
    }
    
    // AUTO-FIX: If customer ID is missing, try to retrieve or create it
    if (!order.stripeCustomerId && stripe) {
      console.log("üîß AUTO-FIXING: Missing customer ID for order:", order.orderId);
      try {
        let customerId = null;
        
        // Try to get customer from payment intent first
        if (order.stripePaymentId) {
          try {
            const paymentIntent = await stripe.paymentIntents.retrieve(order.stripePaymentId);
            if (paymentIntent.customer) {
              customerId = paymentIntent.customer as string;
              console.log("‚úÖ Found customer ID from payment intent:", customerId);
              
              // Also get payment method if available
              if (paymentIntent.payment_method && !order.stripePaymentMethodId) {
                order.stripePaymentMethodId = paymentIntent.payment_method as string;
              }
            }
          } catch (piError: any) {
            console.log("‚ö†Ô∏è Could not retrieve payment intent:", piError.message);
          }
        }
        
        // If still no customer, create a new one from order data
        if (!customerId && order.customerInfo?.email) {
          console.log("üÜï Creating new Stripe customer for order:", order.orderId);
          const customer = await stripe.customers.create({
            email: order.customerInfo.email,
            name: order.customerInfo.name || "Customer",
            phone: order.customerInfo.phone || undefined,
            address: order.customerInfo.address ? {
              line1: order.customerInfo.address.line1 || undefined,
              line2: order.customerInfo.address.line2 || undefined,
              city: order.customerInfo.address.city || undefined,
              state: order.customerInfo.address.state || undefined,
              postal_code: order.customerInfo.address.postal_code || undefined,
              country: order.customerInfo.address.country || "US"
            } : undefined,
            metadata: {
              orderId: order.orderId,
              source: "auto-fix-upsell"
            }
          });
          customerId = customer.id;
          console.log("‚úÖ Created new Stripe customer:", customerId);
        }
        
        // Save customer ID to order
        if (customerId) {
          order.stripeCustomerId = customerId;
          await kv.set(`order:${order.orderId}`, order);
          console.log("‚úÖ AUTO-FIXED: Saved customer ID to order");
        }
      } catch (error: any) {
        console.error("‚ùå Auto-fix failed:", error.message);
      }
    }
    
    console.log("üì¶ Order found for upsell payment:", {
      orderId: order.orderId,
      hasCustomerId: !!order.stripeCustomerId,
      customerId: order.stripeCustomerId ? `${order.stripeCustomerId.substring(0, 15)}...` : 'MISSING',
      hasCustomerInfo: !!order.customerInfo,
      customerEmail: order.customerInfo?.email || 'MISSING'
    });
    
    if (!stripe) {
      return c.json({ error: "Payment system not configured" }, 503);
    }
    
    // If still missing customer ID after auto-fix attempt, log but continue
    if (!order.stripeCustomerId) {
      console.error("‚ùå Order still missing customer ID after auto-fix. This shouldn't happen but continuing anyway:", order.orderId);
      // Don't return error - let Stripe handle it when creating payment intent
    }
    
    const totalAmount = price * quantity;
    
    console.log(`üí≥ Creating payment intent for customer: ${order.stripeCustomerId}`);
    
    // Create payment intent with customer
    const paymentIntentData: any = {
      amount: Math.round(totalAmount * 100),
      currency: 'usd',
      description: `${upsellName} (${quantity}x) - Order ${order.orderId}`,
      metadata: {
        orderId: order.orderId,
        upsellId: upsellId,
        upsellName: upsellName,
        quantity: quantity.toString(),
        price: price.toString(),
        type: 'upsell_from_success_page',
        customerEmail: order.customerInfo?.email || '',
        customerName: order.customerInfo?.name || ''
      }
    };
    
    // Only add customer if we have a valid ID
    if (order.stripeCustomerId && order.stripeCustomerId.trim() !== '') {
      paymentIntentData.customer = order.stripeCustomerId;
    }
    
    const paymentIntent = await stripe.paymentIntents.create(paymentIntentData);
    
    console.log(`‚úÖ Created payment intent for upsell: ${paymentIntent.id}`);
    
    return c.json({ clientSecret: paymentIntent.client_secret });
  } catch (error: any) {
    console.error("‚ùå Error creating upsell payment intent:", error);
    return c.json({ error: error.message || "Failed to create payment intent" }, 500);
  }
});

// Confirm upsell after payment success
app.post("/make-server-cf244566/order/:token/confirm-upsell", async (c) => {
  try {
    const token = c.req.param("token");
    const { paymentIntentId } = await c.req.json();
    
    if (!token || !paymentIntentId) {
      return c.json({ error: "Invalid request" }, 400);
    }
    
    // Get order by token
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === token) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!stripe) {
      return c.json({ error: "Payment system not configured" }, 503);
    }
    
    // Retrieve payment intent to get metadata
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
    
    if (paymentIntent.status !== 'succeeded') {
      return c.json({ error: "Payment not completed" }, 400);
    }
    
    const { upsellId, upsellName, quantity, price } = paymentIntent.metadata;
    const totalAmount = parseFloat(price) * parseInt(quantity);
    
    // Add upsell to order's accepted upsells
    if (!order.acceptedUpsells) {
      order.acceptedUpsells = [];
    }
    
    order.acceptedUpsells.push({
      id: upsellId,
      name: upsellName,
      price: parseFloat(price),
      quantity: parseInt(quantity),
      total: totalAmount,
      addedAt: new Date().toISOString(),
      paymentIntentId: paymentIntentId,
      source: 'success_page'
    });
    
    // Update total
    order.total = (order.total || 0) + totalAmount;
    
    // Save updated order
    await kv.set(`order:${order.orderId}`, order);
    
    console.log(`‚úÖ Upsell confirmed for order ${order.orderId}: ${upsellName} x${quantity}`);
    
    // Send confirmation email
    try {
      const resendApiKey = Deno.env.get("RESEND_API_KEY");
      if (resendApiKey) {
        await fetch("https://api.resend.com/emails", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${resendApiKey}`,
          },
          body: JSON.stringify({
            from: EMAIL_FROM,
            to: order.customerInfo.email,
            subject: `üéÅ ${upsellName} Added to Your Order!`,
            html: `
              <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                <h1 style="color: #c41e3a;">‚úÖ Purchase Confirmed!</h1>
                <p>Great news! We've successfully added the following to your order:</p>
                
                <div style="background: #f0f9ff; padding: 20px; border-radius: 8px; margin: 20px 0;">
                  <h2 style="color: #0369a1; margin-top: 0;">${upsellName}</h2>
                  <p style="font-size: 18px; margin: 10px 0;">
                    <strong>Quantity:</strong> ${quantity}<br>
                    <strong>Total:</strong> ${totalAmount.toFixed(2)}
                  </p>
                </div>
                
                <p>This item will be shipped with your Santa letter package.</p>
                
                <div style="margin-top: 30px; padding: 15px; background: #fef3c7; border-radius: 8px;">
                  <p style="margin: 0; color: #92400e;">
                    <strong>Order #${order.orderId}</strong><br>
                    Your order has been updated and will be processed together.
                  </p>
                </div>
                
                <p style="margin-top: 30px;">
                  Thank you for your purchase!<br>
                  üéÖ Santa's Workshop Team
                </p>
              </div>
            `,
          }),
        });
        console.log(`‚úÖ Upsell confirmation email sent to ${order.customerInfo.email}`);
      }
    } catch (emailError) {
      console.error("‚ùå Failed to send upsell confirmation email:", emailError);
    }
    
    return c.json({ 
      success: true, 
      upsellName,
      quantity: parseInt(quantity),
      total: totalAmount 
    });
  } catch (error: any) {
    console.error("‚ùå Error confirming upsell:", error);
    return c.json({ error: error.message || "Failed to confirm upsell" }, 500);
  }
});
*/
// END OF DISABLED OLD ROUTES

// Legacy endpoint - kept for backwards compatibility
app.post("/make-server-cf244566/order/:token/add-upsell", async (c) => {
  try {
    const token = c.req.param("token");
    const { upsellId, upsellName, price, quantity, cardDetails } = await c.req.json();
    
    if (!token || !upsellId || !upsellName || !price || !quantity || quantity < 1) {
      return c.json({ error: "Invalid request" }, 400);
    }
    
    if (!cardDetails || !cardDetails.number || !cardDetails.expMonth || !cardDetails.expYear || !cardDetails.cvc) {
      return c.json({ error: "Card details required" }, 400);
    }
    
    // Get order by token
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === token) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!stripe) {
      return c.json({ error: "Payment system not configured" }, 503);
    }
    
    const totalAmount = price * quantity;
    
    // Create a payment method from card details
    const paymentMethod = await stripe.paymentMethods.create({
      type: 'card',
      card: {
        number: cardDetails.number,
        exp_month: cardDetails.expMonth,
        exp_year: cardDetails.expYear,
        cvc: cardDetails.cvc,
      },
      billing_details: {
        address: {
          postal_code: cardDetails.zip,
        },
      },
    });
    
    // Attach the payment method to the customer
    await stripe.paymentMethods.attach(paymentMethod.id, {
      customer: order.stripeCustomerId,
    });
    
    // Charge customer for the upsell using the new payment method
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(totalAmount * 100),
      currency: 'usd',
      customer: order.stripeCustomerId,
      payment_method: paymentMethod.id,
      off_session: false,
      confirm: true,
      description: `${upsellName} (${quantity}x) - Order ${order.orderId}`,
      metadata: {
        orderId: order.orderId,
        upsellId: upsellId,
        quantity: quantity.toString(),
        type: 'upsell_from_success_page'
      }
    });
    
    if (paymentIntent.status !== 'succeeded') {
      console.error(`‚ùå Payment failed: ${paymentIntent.status}`);
      return c.json({ 
        error: "Payment was declined. Please check your card.",
        declineCode: paymentIntent.last_payment_error?.code
      }, 402);
    }
    
    // Add upsell to order's accepted upsells
    if (!order.acceptedUpsells) {
      order.acceptedUpsells = [];
    }
    
    order.acceptedUpsells.push({
      name: upsellName,
      quantity: quantity,
      price: price,
      total: totalAmount
    });
    
    // Update order total
    order.total = (order.total || 0) + totalAmount;
    order.updatedAt = new Date().toISOString();
    
    // Add activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Upsell Added from Success Page',
      details: `${quantity}x ${upsellName} - ${totalAmount.toFixed(2)} charged`,
      user: 'Customer',
      stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntent.id}`
    });
    
    await kv.set(`order:${order.orderId}`, order);
    
    console.log(`‚úÖ Upsell added from success page: ${upsellName} x${quantity}`);
    
    // Send confirmation email
    try {
      const resendApiKey = Deno.env.get("RESEND_API_KEY");
      if (resendApiKey && order.customerInfo?.email) {
        const emailHtml = `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
          </head>
          <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÅ Item Added!</h1>
              </div>
              <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                <p>Hi ${order.customerInfo.name || 'there'},</p>
                
                <p style="font-size: 18px; color: #059669;"><strong>‚úÖ We're adding ${upsellName} to your order!</strong></p>
                
                <div style="background: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #16a34a;">
                  <p style="margin: 0 0 10px 0;"><strong>Item Added:</strong></p>
                  <p style="font-size: 20px; margin: 0; color: #16a34a;"><strong>${quantity}x ${upsellName}</strong></p>
                  <p style="margin: 10px 0 0 0; font-size: 14px; color: #166534;">
                    üí≥ Amount charged: ${totalAmount.toFixed(2)}
                  </p>
                </div>
                
                <div style="background: #f9fafb; padding: 20px; border-radius: 8px; margin: 20px 0;">
                  <p style="margin: 0 0 10px 0;"><strong>üìã Order Summary:</strong></p>
                  <p style="margin: 5px 0;"><strong>Order #:</strong> ${order.orderId.slice(-8)}</p>
                  <p style="margin: 5px 0;"><strong>Updated Total:</strong> ${order.total.toFixed(2)}</p>
                </div>
                
                <div style="background: #dbeafe; padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #3b82f6;">
                  <p style="margin: 0; font-size: 14px; color: #1e40af;">
                    <strong>‚ú® Your ${upsellName} will be shipped with your letter package!</strong>
                  </p>
                </div>
                
                <p style="margin-top: 30px;">Thank you for your purchase! The magic continues... ‚ú®</p>
                
                <p>With Christmas cheer,<br>The Santa's Letters Team üéÑ</p>
              </div>
              <div style="background: #f9fafb; padding: 20px; text-align: center; color: #6b7280; font-size: 14px; border-radius: 0 0 10px 10px;">
                <p>Questions? Contact us at support@letterfromsanta.com</p>
                <p style="margin: 5px 0 0 0;">¬© ${new Date().getFullYear()} Letter From Santa. All rights reserved.</p>
              </div>
            </div>
          </body>
          </html>
        `;

        const response = await fetch("https://api.resend.com/emails", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${resendApiKey}`,
          },
          body: JSON.stringify({
            from: EMAIL_FROM,
            to: [order.customerInfo.email],
            subject: `üéÅ ${upsellName} Added to Your Order!`,
            html: emailHtml,
          }),
        });

        if (response.ok) {
          console.log("‚úÖ Upsell confirmation email sent to:", order.customerInfo.email);
        } else {
          const errorText = await response.text();
          console.error("‚ùå Failed to send email:", errorText);
        }
      }
    } catch (emailError) {
      console.error("‚ùå Error sending email:", emailError);
    }
    
    return c.json({ 
      success: true,
      message: `${upsellName} added to your order!`,
      order: {
        orderId: order.orderId,
        total: order.total,
        acceptedUpsells: order.acceptedUpsells
      }
    });
  } catch (error: any) {
    console.error("‚ùå Error adding upsell from success page:", error);
    return c.json({ error: error.message || "Failed to add item" }, 500);
  }
});

// Decline upsell
app.post("/make-server-cf244566/upsell/decline", async (c) => {
  try {
    const { orderToken, upsellId } = await c.req.json();
    
    // Get order
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === orderToken) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    // Track decline attempts
    if (!order.upsellDeclineAttempts) {
      order.upsellDeclineAttempts = {};
    }
    if (!order.upsellsDeclined) {
      order.upsellsDeclined = [];
    }
    
    // Increment decline attempts
    if (upsellId) {
      const currentAttempts = order.upsellDeclineAttempts[upsellId] || 0;
      order.upsellDeclineAttempts[upsellId] = currentAttempts + 1;
      
      // If declined 2 times, add to fully declined list
      if (order.upsellDeclineAttempts[upsellId] >= 2) {
        if (!order.upsellsDeclined.includes(upsellId)) {
          order.upsellsDeclined.push(upsellId);
        }
      }
    }
    
    order.updatedAt = new Date().toISOString();
    await kv.set(`order:${order.orderId}`, order);
    
    const attempts = order.upsellDeclineAttempts[upsellId] || 0;
    console.log(`üëé Upsell declined: ${upsellId} (Attempt ${attempts}/2)`);
    
    return c.json({ 
      success: true,
      shouldRetry: attempts < 2 // Tell frontend if we should show downsell
    });
  } catch (error: any) {
    console.error("‚ùå Error declining upsell:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Mark upsell flow complete and send confirmation email
app.post("/make-server-cf244566/upsell/complete", async (c) => {
  try {
    const { orderToken } = await c.req.json();
    
    // Get order
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === orderToken) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    // Mark upsell flow as complete
    order.upsellFlowCompleted = true;
    order.upsellFlowCompletedAt = new Date().toISOString();
    await kv.set(`order:${order.orderId}`, order);
    
    // Send confirmation email with upsells
    await sendOrderConfirmationWithUpsells(order);
    
    console.log(`‚úÖ Upsell flow completed for order: ${order.orderId}`);
    
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error completing upsell flow:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Helper function to send order confirmation with upsells
async function sendOrderConfirmationWithUpsells(order: any) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  if (!resendApiKey) {
    console.log("‚ö†Ô∏è No Resend API key - skipping email");
    return;
  }
  
  const hasUpsells = order.upsellsAccepted && order.upsellsAccepted.length > 0;
  
  // Build upsells HTML
  let upsellsHtml = '';
  if (hasUpsells) {
    upsellsHtml = `
      <div style="background: #f0fdf4; border: 2px solid #059669; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <h3 style="margin-top: 0; color: #059669; font-family: 'Pacifico', cursive;">üéÅ Bonus Items Added</h3>
        ${order.upsellsAccepted.map((upsell: any) => `
          <div style="padding: 10px 0; border-bottom: 1px solid #d1fae5;">
            <div style="display: flex; justify-content: space-between;">
              <span>${upsell.quantity}x ${upsell.name}</span>
              <span style="font-weight: bold;">${upsell.total.toFixed(2)}</span>
            </div>
          </div>
        `).join('')}
      </div>
    `;
  }
  
  const emailHtml = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
    </head>
    <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
      <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
          <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÖ Order Confirmed!</h1>
        </div>
        <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
          <p>Hi ${order.customerInfo.name},</p>
          
          <p style="font-size: 18px; color: #059669;"><strong>‚úÖ Your order has been confirmed and is being processed!</strong></p>
          
          <div style="background: #f9fafb; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <p style="margin: 0 0 10px 0;"><strong>Order #:</strong> ${order.orderId}</p>
            <p style="margin: 0 0 10px 0;"><strong>Letter Packages:</strong> ${order.letterPackages?.length || 0}</p>
            ${order.monthlySubscription ? `<p style="margin: 0;"><strong>Subscription:</strong> Monthly Letters</p>` : ''}
          </div>
          
          ${upsellsHtml}
          
          <div style="background: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: center;">
            <p style="font-size: 24px; margin: 0; color: #16a34a;"><strong>${order.total.toFixed(2)}</strong></p>
            <p style="margin: 5px 0 0 0;">Total Paid</p>
          </div>
          
          <p>Your magical letters from Santa are being prepared and will be mailed soon!</p>
          
          ${order.monthlySubscription ? `
          <div style="background: #dbeafe; border-left: 4px solid #3b82f6; padding: 15px; margin: 20px 0;">
            <p style="margin: 0;"><strong>üìÖ Monthly Subscription Active</strong></p>
            <p style="margin: 5px 0 0 0;">You'll receive new letters every month. Manage your subscription anytime.</p>
          </div>
          ` : ''}
          
          <p style="margin-top: 30px;">Thank you for choosing Santa's Letters!</p>
          
          <p>With Christmas cheer,<br>The Santa's Letters Team üéÑ</p>
        </div>
      </div>
    </body>
    </html>
  `;
  
  try {
    const response = await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${resendApiKey}`,
      },
      body: JSON.stringify({
        from: EMAIL_FROM,
        to: order.customerInfo.email,
        subject: `üéÖ Order Confirmed - Santa's Letters`,
        html: emailHtml,
      }),
    });

    if (!response.ok) {
      console.error("‚ùå Failed to send confirmation email:", await response.text());
    } else {
      console.log(`‚úÖ Confirmation email sent to ${order.customerInfo.email}`);
    }
  } catch (error) {
    console.error("‚ùå Error sending confirmation email:", error);
  }
}

// ============================================
// ADMIN ALERTS SYSTEM
// ============================================

// Get all alerts
app.get("/make-server-cf244566/admin/alerts", async (c) => {
  try {
    const allAlertIds = (await kv.get("alerts:all")) || [];
    const alerts = [];
    let unreadCount = 0;
    
    for (const id of allAlertIds) {
      const alert = await kv.get(`alert:${id}`);
      if (alert) {
        alerts.push(alert);
        if ((alert as any).status === "unread") {
          unreadCount++;
        }
      }
    }
    
    // Sort by created date, newest first
    alerts.sort((a: any, b: any) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
    
    return c.json({ success: true, alerts, unreadCount });
  } catch (error: any) {
    console.error("‚ùå Error fetching alerts:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Mark alert as read
app.patch("/make-server-cf244566/admin/alerts/:alertId/read", async (c) => {
  try {
    const alertId = c.req.param("alertId");
    const alert: any = await kv.get(`alert:${alertId}`);
    
    if (!alert) {
      return c.json({ error: "Alert not found" }, 404);
    }
    
    alert.status = "read";
    alert.readAt = new Date().toISOString();
    
    await kv.set(`alert:${alertId}`, alert);
    
    return c.json({ success: true, alert });
  } catch (error: any) {
    console.error("‚ùå Error marking alert as read:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Mark all alerts as read
app.post("/make-server-cf244566/admin/alerts/read-all", async (c) => {
  try {
    const allAlertIds = (await kv.get("alerts:all")) || [];
    
    for (const id of allAlertIds) {
      const alert: any = await kv.get(`alert:${id}`);
      if (alert && alert.status === "unread") {
        alert.status = "read";
        alert.readAt = new Date().toISOString();
        await kv.set(`alert:${id}`, alert);
      }
    }
    
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error marking all alerts as read:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Delete alert
app.delete("/make-server-cf244566/admin/alerts/:alertId", async (c) => {
  try {
    const alertId = c.req.param("alertId");
    
    await kv.del(`alert:${alertId}`);
    
    const allAlertIds = (await kv.get("alerts:all")) || [];
    const updatedIds = allAlertIds.filter((id: string) => id !== alertId);
    await kv.set("alerts:all", updatedIds);
    
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error deleting alert:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Helper function to create an admin alert
async function createAdminAlert(
  type: string,
  orderId: string,
  message: string,
  details: any,
  priority: "low" | "medium" | "high" = "low",
  relatedOrderId?: string
) {
  try {
    const alertId = `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    const alert = {
      id: alertId,
      type,
      orderId,
      relatedOrderId,
      message,
      details,
      status: "unread",
      priority,
      createdAt: new Date().toISOString(),
    };
    
    await kv.set(`alert:${alertId}`, alert);
    
    const allAlertIds = (await kv.get("alerts:all")) || [];
    allAlertIds.push(alertId);
    await kv.set("alerts:all", allAlertIds);
    
    console.log(`‚úÖ Admin alert created: ${type} for order ${orderId}`);
  } catch (error) {
    console.error("‚ùå Error creating admin alert:", error);
  }
}

// ============================================
// DECLINED CHARGE AUTO-RETRY SYSTEM
// ============================================

// Stripe webhook handler for declined charges
app.post("/make-server-cf244566/stripe-webhook", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }

  try {
    const signature = c.req.header("stripe-signature");
    const webhookSecret = Deno.env.get("STRIPE_WEBHOOK_SECRET");
    
    if (!webhookSecret) {
      console.error("‚ùå STRIPE_WEBHOOK_SECRET not configured");
      return c.json({ error: "Webhook secret not configured" }, 500);
    }

    if (!signature) {
      console.error("‚ùå No signature provided");
      return c.json({ error: "No signature" }, 400);
    }

    const body = await c.req.text();
    let event: Stripe.Event;

    try {
      event = stripe.webhooks.constructEvent(body, signature, webhookSecret);
    } catch (err: any) {
      console.error("‚ùå Webhook signature verification failed:", err.message);
      return c.json({ error: `Webhook Error: ${err.message}` }, 400);
    }

    console.log(`üì• Webhook received: ${event.type}`);

    // Handle invoice.payment_failed for subscription declines
    if (event.type === "invoice.payment_failed") {
      const invoice = event.data.object as Stripe.Invoice;
      const subscriptionId = invoice.subscription as string;

      if (!subscriptionId) {
        console.log("‚ö†Ô∏è Invoice has no subscription, skipping");
        return c.json({ received: true });
      }

      console.log(`üí≥‚ùå Subscription payment failed: ${subscriptionId}`);

      // Find order with this subscription
      const allOrderIds = (await kv.get("orders:all")) || [];
      let targetOrder = null;
      let targetOrderId = null;

      for (const orderId of allOrderIds) {
        const order = await kv.get(`order:${orderId}`);
        if (order && (order as any).subscriptionId === subscriptionId) {
          targetOrder = order;
          targetOrderId = orderId;
          break;
        }
      }

      if (!targetOrder) {
        console.error(`‚ùå No order found for subscription ${subscriptionId}`);
        return c.json({ received: true });
      }

      const order = targetOrder as any;

      // Create or update decline record
      const declineId = `decline_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const now = new Date().toISOString();

      const declineData = {
        declineId,
        timestamp: now,
        orderId: targetOrderId,
        subscriptionId,
        stripeInvoiceId: invoice.id,
        status: "payment_failed",
        declineReason: invoice.last_finalization_error?.message || "Payment failed",
        declineCode: invoice.last_finalization_error?.code || "unknown",
        amount: invoice.amount_due / 100,
        customerInfo: order.customerInfo,
        letterPackages: order.letterPackages,
        numberOfPackages: order.letterPackages?.length || 0,
        affiliateId: order.affiliateId || null,
        // Retry tracking fields
        retryAttempts: 0,
        firstFailureDate: now,
        lastFailureDate: now,
        nextRetryDate: new Date(Date.now() + 12 * 60 * 60 * 1000).toISOString(), // 12 hours from now
        emailsSent: [],
        retryHistory: [
          {
            timestamp: now,
            event: "Initial decline",
            details: invoice.last_finalization_error?.message || "Payment failed",
          },
        ],
      };

      await kv.set(`decline:${declineId}`, declineData);
      console.log(`‚úÖ Decline tracked: ${declineId}`);

      // Create admin alert
      await createAdminAlert(
        "payment_failed",
        targetOrderId as string,
        `Subscription payment failed for ${order.customerInfo.name}`,
        {
          subscriptionId,
          amount: declineData.amount,
          reason: declineData.declineReason,
        },
        "high"
      );

      return c.json({ received: true });
    }

    return c.json({ received: true });
  } catch (error: any) {
    console.error("‚ùå Webhook error:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Process declined charge retries (called by cron or manually)
app.post("/make-server-cf244566/admin/process-retries", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }

  try {
    console.log("üîÑ Processing declined charge retries...");

    // Get all decline records
    const allDeclines = await kv.getByPrefix("decline:");
    const now = new Date();

    let retriesAttempted = 0;
    let retriesSucceeded = 0;
    let retriesFailed = 0;
    let emailsSent = 0;

    for (const decline of allDeclines) {
      const declineData = decline as any;

      // Skip if already attempted 3 times
      if (declineData.retryAttempts >= 3) {
        continue;
      }

      // Check if it's time to retry
      const nextRetryDate = new Date(declineData.nextRetryDate);
      if (now < nextRetryDate) {
        continue; // Not time yet
      }

      console.log(`üîÑ Processing retry for decline ${declineData.declineId}`);
      retriesAttempted++;

      // Get the order
      const order = await kv.get(`order:${declineData.orderId}`);
      if (!order) {
        console.error(`‚ùå Order not found: ${declineData.orderId}`);
        continue;
      }

      const orderData = order as any;

      // Try to charge the subscription
      try {
        const subscription = await stripe.subscriptions.retrieve(declineData.subscriptionId);

        if (!subscription.latest_invoice) {
          console.error(`‚ùå No invoice found for subscription ${declineData.subscriptionId}`);
          retriesFailed++;
          continue;
        }

        // Retry the invoice payment
        const invoice = await stripe.invoices.retrieve(subscription.latest_invoice as string);
        
        if (invoice.status === "paid") {
          console.log(`‚úÖ Invoice already paid: ${invoice.id}`);
          
          // Mark decline as resolved
          declineData.status = "resolved";
          declineData.resolvedDate = new Date().toISOString();
          declineData.retryHistory.push({
            timestamp: new Date().toISOString(),
            event: "Resolved - payment successful",
            details: "Invoice was paid",
          });
          await kv.set(`decline:${declineData.declineId}`, declineData);
          
          retriesSucceeded++;
          continue;
        }

        // Try to pay the invoice
        const paidInvoice = await stripe.invoices.pay(invoice.id);

        if (paidInvoice.status === "paid") {
          console.log(`‚úÖ Retry successful for ${declineData.declineId}`);
          retriesSucceeded++;

          // Mark decline as resolved
          declineData.status = "resolved";
          declineData.resolvedDate = new Date().toISOString();
          declineData.retryHistory.push({
            timestamp: new Date().toISOString(),
            event: "Retry successful",
            details: `Payment processed successfully. Invoice: ${paidInvoice.id}`,
          });
          await kv.set(`decline:${declineData.declineId}`, declineData);

          // Send success email
          const childNames = orderData.letterPackages
            .map((pkg: any) => pkg.childFirstName)
            .join(' and ');
          await sendRetrySuccessEmail(orderData, childNames);

          continue;
        }
      } catch (error: any) {
        console.error(`‚ùå Retry failed for ${declineData.declineId}:`, error.message);
        retriesFailed++;

        // Update retry attempt
        declineData.retryAttempts++;
        declineData.lastFailureDate = new Date().toISOString();
        
        // Calculate next retry date based on attempt number
        // Attempt 1: 12h + 24h = 36h total (1.5 days)
        // Attempt 2: 36h + 24h = 60h total (2.5 days)
        // Attempt 3: stop
        if (declineData.retryAttempts < 3) {
          declineData.nextRetryDate = new Date(now.getTime() + 24 * 60 * 60 * 1000).toISOString();
        }

        declineData.retryHistory.push({
          timestamp: new Date().toISOString(),
          event: `Retry attempt ${declineData.retryAttempts} failed`,
          details: error.message,
        });

        // Send recovery email
        await sendRecoveryEmail(orderData, declineData);
        emailsSent++;

        declineData.emailsSent.push({
          timestamp: new Date().toISOString(),
          attemptNumber: declineData.retryAttempts,
          type: "recovery",
        });

        await kv.set(`decline:${declineData.declineId}`, declineData);

        // If this was the 3rd attempt, create admin alert
        if (declineData.retryAttempts >= 3) {
          await createAdminAlert(
            "payment_retry_exhausted",
            declineData.orderId,
            `All retry attempts exhausted for ${orderData.customerInfo.name}`,
            {
              declineId: declineData.declineId,
              amount: declineData.amount,
              attempts: declineData.retryAttempts,
            },
            "high"
          );
        }
      }
    }

    console.log(`‚úÖ Retry processing complete:`);
    console.log(`   Attempted: ${retriesAttempted}`);
    console.log(`   Succeeded: ${retriesSucceeded}`);
    console.log(`   Failed: ${retriesFailed}`);
    console.log(`   Emails sent: ${emailsSent}`);

    return c.json({
      success: true,
      retriesAttempted,
      retriesSucceeded,
      retriesFailed,
      emailsSent,
    });
  } catch (error: any) {
    console.error("‚ùå Error processing retries:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Send recovery email when payment fails
async function sendRecoveryEmail(order: any, decline: any) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  if (!resendApiKey || !order.customerInfo?.email) {
    console.log("‚ö†Ô∏è Cannot send recovery email - missing API key or email");
    return;
  }

  // Get child names from letter packages
  const childNames = order.letterPackages
    .map((pkg: any) => pkg.childFirstName)
    .join(", ");

  const emailHtml = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
    </head>
    <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
      <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background: linear-gradient(135deg, #dc2626 0%, #ea580c 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
          <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÖ Payment Issue</h1>
        </div>
        <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
          <p>Hi ${order.customerInfo.name},</p>
          
          <p style="font-size: 18px; color: #dc2626;"><strong>‚ö†Ô∏è ${childNames}'s Letter is Waiting!</strong></p>
          
          <p>We tried to process your monthly subscription payment, but it didn't go through.</p>
          
          <div style="background: #fef2f2; border-left: 4px solid #dc2626; padding: 15px; margin: 20px 0;">
            <p style="margin: 0;"><strong>What happened?</strong></p>
            <p style="margin: 5px 0 0 0;">Your card may have expired, reached its limit, or there might be insufficient funds.</p>
          </div>
          
          <div style="background: #dcfce7; border: 2px solid #16a34a; border-radius: 8px; padding: 20px; margin: 20px 0; text-align: center;">
            <p style="margin: 0 0 15px 0;"><strong>Don't let ${childNames} miss out on their magical letter!</strong></p>
            <a href="https://billing.stripe.com/p/login/test_placeholder" 
               style="display: inline-block; background: #16a34a; color: white; padding: 12px 30px; text-decoration: none; border-radius: 6px; font-weight: bold;">
              Update Payment Method
            </a>
          </div>
          
          <p><strong>Attempt ${decline.retryAttempts} of 3</strong></p>
          <p style="font-size: 14px; color: #6b7280;">We'll automatically try again in 24 hours. After 3 failed attempts, your subscription will be cancelled.</p>
          
          <p style="margin-top: 30px;">Questions? Reply to this email and we'll help!</p>
          
          <p>With Christmas cheer,<br>The Santa's Letters Team üéÑ</p>
        </div>
      </div>
    </body>
    </html>
  `;

  try {
    const response = await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${resendApiKey}`,
      },
      body: JSON.stringify({
        from: EMAIL_FROM,
        to: order.customerInfo.email,
        subject: `üéÖ Payment Issue - ${childNames}'s Letter is Waiting!`,
        html: emailHtml,
      }),
    });

    if (!response.ok) {
      console.error("‚ùå Failed to send recovery email:", await response.text());
    } else {
      console.log(`‚úÖ Recovery email sent to ${order.customerInfo.email}`);
    }
  } catch (error) {
    console.error("‚ùå Error sending recovery email:", error);
  }
}

// Migration endpoint - backfill customer IDs for existing orders
app.post("/make-server-cf244566/admin/migrate-customer-ids", async (c) => {
  try {
    const { adminPassword } = await c.req.json();
    
    // Verify admin password
    const correctPassword = Deno.env.get("ADMIN_PASSWORD");
    if (!correctPassword || adminPassword !== correctPassword) {
      return c.json({ error: "Unauthorized" }, 401);
    }
    
    if (!stripe) {
      return c.json({ error: "Stripe not configured" }, 503);
    }
    
    const allOrderIds = (await kv.get("orders:all")) || [];
    let updated = 0;
    let skipped = 0;
    let errors = 0;
    
    console.log(`üîÑ Starting migration for ${allOrderIds.length} orders...`);
    
    for (const orderId of allOrderIds) {
      const order: any = await kv.get(`order:${orderId}`);
      
      if (!order) {
        skipped++;
        continue;
      }
      
      // Skip if already has customer ID
      if (order.stripeCustomerId) {
        skipped++;
        continue;
      }
      
      // Try to get customer ID from payment intent
      if (order.stripePaymentId) {
        try {
          const paymentIntent = await stripe.paymentIntents.retrieve(order.stripePaymentId);
          
          if (paymentIntent.customer) {
            order.stripeCustomerId = paymentIntent.customer as string;
            
            // Also get payment method if available
            if (paymentIntent.payment_method && !order.stripePaymentMethodId) {
              order.stripePaymentMethodId = paymentIntent.payment_method as string;
            }
            
            await kv.set(`order:${orderId}`, order);
            updated++;
            console.log(`‚úÖ Updated order ${orderId} with customer ID`);
          } else {
            skipped++;
            console.log(`‚è≠Ô∏è Order ${orderId} has no customer in payment intent`);
          }
        } catch (error: any) {
          errors++;
          console.error(`‚ùå Error processing order ${orderId}:`, error.message);
        }
      } else {
        skipped++;
      }
    }
    
    console.log(`‚úÖ Migration complete: ${updated} updated, ${skipped} skipped, ${errors} errors`);
    
    return c.json({ 
      success: true, 
      updated, 
      skipped, 
      errors,
      total: allOrderIds.length 
    });
  } catch (error: any) {
    console.error("‚ùå Migration error:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Retry Payment - Manual admin action to force charge existing payment method
app.post("/make-server-cf244566/decline/retry-payment", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not initialized" }, 500);
  }

  try {
    const { declineId, paymentIntentId } = await c.req.json();

    if (!declineId || !paymentIntentId) {
      return c.json({ error: "Missing declineId or paymentIntentId" }, 400);
    }

    console.log(`üîÑ Admin retry payment: ${paymentIntentId}`);

    // Get the payment intent
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);

    // Try to confirm/retry the payment
    let result;
    if (paymentIntent.status === 'requires_payment_method') {
      // Cannot retry - needs new payment method
      return c.json({ 
        error: "Card declined. Please update payment method first.",
        details: "This payment requires a new payment method before it can be retried."
      }, 400);
    } else if (paymentIntent.status === 'requires_confirmation') {
      result = await stripe.paymentIntents.confirm(paymentIntentId);
    } else if (paymentIntent.status === 'requires_action') {
      // Might need 3D secure - just return current status
      return c.json({
        error: "Payment requires customer action (3D Secure)",
        details: "Customer must complete authentication",
        paymentIntentId
      }, 400);
    } else {
      // Try to create a new payment intent with same payment method
      const newPaymentIntent = await stripe.paymentIntents.create({
        amount: paymentIntent.amount,
        currency: paymentIntent.currency,
        customer: paymentIntent.customer as string,
        payment_method: paymentIntent.payment_method as string,
        confirm: true,
        description: `Retry of ${paymentIntentId}`,
        metadata: paymentIntent.metadata,
      });
      result = newPaymentIntent;
    }

    if (result.status === 'succeeded') {
      // Update decline record to resolved
      const declineData = await kv.get(`decline:${declineId}`);
      if (declineData) {
        declineData.status = 'resolved';
        declineData.resolvedDate = new Date().toISOString();
        declineData.retryHistory = declineData.retryHistory || [];
        declineData.retryHistory.push({
          timestamp: new Date().toISOString(),
          event: 'Admin Manual Retry - Success',
          details: `Payment succeeded: ${result.id}`
        });
        await kv.set(`decline:${declineId}`, declineData);
      }

      console.log(`‚úÖ Payment retry successful: ${result.id}`);
      return c.json({ success: true, paymentIntentId: result.id });
    } else {
      console.log(`‚ùå Payment retry failed: ${result.status}`);
      return c.json({ 
        error: "Payment retry failed", 
        details: result.last_payment_error?.message || result.status 
      }, 400);
    }
  } catch (error: any) {
    console.error("‚ùå Retry payment error:", error);
    return c.json({ error: error.message, details: error.raw?.message }, 500);
  }
});

// Update Payment Method - Admin adds new card from phone call
app.post("/make-server-cf244566/decline/update-payment-method", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not initialized" }, 500);
  }

  try {
    const { declineId, paymentIntentId, cardNumber, expMonth, expYear, cvc } = await c.req.json();

    if (!declineId || !paymentIntentId || !cardNumber || !expMonth || !expYear || !cvc) {
      return c.json({ error: "Missing required card details" }, 400);
    }

    console.log(`üí≥ Admin updating payment method for: ${paymentIntentId}`);

    // Get the payment intent to get customer ID
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
    const customerId = paymentIntent.customer as string;

    if (!customerId) {
      return c.json({ error: "No customer found for this payment" }, 400);
    }

    // Create a payment method from card details
    const paymentMethod = await stripe.paymentMethods.create({
      type: 'card',
      card: {
        number: cardNumber,
        exp_month: parseInt(expMonth),
        exp_year: parseInt(expYear),
        cvc: cvc,
      },
    });

    // Attach payment method to customer
    await stripe.paymentMethods.attach(paymentMethod.id, {
      customer: customerId,
    });

    // Set as default payment method
    await stripe.customers.update(customerId, {
      invoice_settings: {
        default_payment_method: paymentMethod.id,
      },
    });

    // Update the payment intent with new payment method
    await stripe.paymentIntents.update(paymentIntentId, {
      payment_method: paymentMethod.id,
    });

    // Update decline record
    const declineData = await kv.get(`decline:${declineId}`);
    if (declineData) {
      declineData.retryHistory = declineData.retryHistory || [];
      declineData.retryHistory.push({
        timestamp: new Date().toISOString(),
        event: 'Admin Updated Payment Method',
        details: `New card ending in ${cardNumber.slice(-4)}`
      });
      await kv.set(`decline:${declineId}`, declineData);
    }

    console.log(`‚úÖ Payment method updated for customer: ${customerId}`);
    return c.json({ success: true, paymentMethodId: paymentMethod.id });
  } catch (error: any) {
    console.error("‚ùå Update payment method error:", error);
    return c.json({ 
      error: error.message || "Failed to update payment method",
      details: error.raw?.message 
    }, 500);
  }
});

// Stop Recovery - Remove from retry queue and stop emails
app.post("/make-server-cf244566/decline/stop-recovery", async (c) => {
  try {
    const { declineId } = await c.req.json();

    if (!declineId) {
      return c.json({ error: "Missing declineId" }, 400);
    }

    console.log(`üõë Admin stopping recovery for: ${declineId}`);

    // Update decline record
    const declineData = await kv.get(`decline:${declineId}`);
    if (!declineData) {
      return c.json({ error: "Decline not found" }, 404);
    }

    // Mark as stopped
    declineData.status = 'stopped';
    declineData.unsubscribed = true;
    declineData.unsubscribedAt = new Date().toISOString();
    declineData.retryHistory = declineData.retryHistory || [];
    declineData.retryHistory.push({
      timestamp: new Date().toISOString(),
      event: 'Admin Stopped Recovery',
      details: 'All recovery attempts and emails stopped by admin'
    });

    await kv.set(`decline:${declineId}`, declineData);

    console.log(`‚úÖ Recovery stopped for: ${declineId}`);
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Stop recovery error:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Create payment intent for upsell from success page (requires new card input)
app.post("/make-server-cf244566/order/:token/create-upsell-payment", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not initialized" }, 500);
  }

  try {
    const token = c.req.param("token");
    const { upsellId, upsellName, price, quantity } = await c.req.json();

    if (!token || !upsellId || !price || !quantity) {
      return c.json({ error: "Missing required fields" }, 400);
    }

    console.log(`üí≥ Creating payment intent for upsell: ${upsellName} x${quantity}`);

    // Find order by access token
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;

    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === token) {
        order = orderData;
        break;
      }
    }

    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    // For subscriptions, charge $0 initially (billing starts January 1st)
    const isSubscription = upsellId === "upsell_subscription";
    const totalAmount = isSubscription ? 0 : (price * quantity);

    // For subscriptions, use SetupIntent (can't charge $0 with PaymentIntent)
    // For regular upsells, use PaymentIntent
    if (isSubscription) {
      // Create SetupIntent for subscription (saves payment method for future use)
      const setupIntent = await stripe.setupIntents.create({
        customer: order.stripeCustomerId,
        description: `Santa's Magical Journey Subscription Setup (${quantity} ${quantity === 1 ? 'child' : 'children'}) - Billing starts Jan 1st`,
        metadata: {
          orderId: order.orderId,
          upsellId,
          upsellName,
          quantity: quantity.toString(),
          price: price.toString(),
          source: "success_page",
          type: "success_page_upsell",
          isSubscription: "true",
        },
        automatic_payment_methods: {
          enabled: true,
        },
      });

      console.log(`‚úÖ SetupIntent created for subscription: ${setupIntent.id}`);
      return c.json({ clientSecret: setupIntent.client_secret });
    }

    // Create payment intent for regular upsells
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(totalAmount * 100),
      currency: "usd",
      customer: order.stripeCustomerId,
      description: `${quantity}x ${upsellName} - Order ${order.orderId}`,
      metadata: {
        orderId: order.orderId,
        upsellId,
        upsellName,
        quantity: quantity.toString(),
        price: price.toString(),
        source: "success_page",
        type: "success_page_upsell",
        isSubscription: "false",
      },
      automatic_payment_methods: {
        enabled: true,
      },
    });

    console.log(`‚úÖ Payment intent created: ${paymentIntent.id}`);

    return c.json({ clientSecret: paymentIntent.client_secret });
  } catch (error: any) {
    console.error("‚ùå Error creating upsell payment intent:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Confirm upsell payment and add to order (after successful payment)
app.post("/make-server-cf244566/order/:token/confirm-upsell", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not initialized" }, 500);
  }

  try {
    const token = c.req.param("token");
    const { paymentIntentId } = await c.req.json();

    if (!token || !paymentIntentId) {
      return c.json({ error: "Missing required fields" }, 400);
    }

    console.log(`‚úÖ Confirming upsell payment: ${paymentIntentId}`);

    // Determine if this is a SetupIntent (subscription) or PaymentIntent (regular upsell)
    let metadata: any;
    let paymentMethodId: string | null = null;
    
    if (paymentIntentId.startsWith('seti_')) {
      // This is a SetupIntent (subscription)
      const setupIntent = await stripe.setupIntents.retrieve(paymentIntentId);
      
      if (setupIntent.status !== "succeeded") {
        return c.json({ error: "Setup not completed" }, 400);
      }
      
      metadata = setupIntent.metadata;
      paymentMethodId = setupIntent.payment_method as string;
    } else {
      // This is a PaymentIntent (regular upsell)
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
      
      if (paymentIntent.status !== "succeeded") {
        return c.json({ error: "Payment not completed" }, 400);
      }
      
      metadata = paymentIntent.metadata;
      paymentMethodId = paymentIntent.payment_method as string;
    }

    const { orderId, upsellId, upsellName, quantity, price, source } = metadata;

    // Find order
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    // Verify token
    if (order.accessToken !== token) {
      return c.json({ error: "Invalid access token" }, 403);
    }

    const qty = parseInt(quantity);
    const unitPrice = parseFloat(price);
    const total = unitPrice * qty;

    // HANDLE SUBSCRIPTION UPSELL - Same logic as pre-checkout
    if (upsellId === "upsell_subscription") {
      console.log(`üéÖ Creating subscription from success page for ${qty} children`);
      
      // Calculate trial end date: January 1st of next year
      const january1st = new Date(new Date().getFullYear() + 1, 0, 1);
      const trialEndTimestamp = Math.floor(january1st.getTime() / 1000);
      
      console.log(`üìÖ Setting trial_end to January 1st: ${january1st.toISOString()}`);

      try {
        // Attach payment method to customer (if not already attached)
        if (paymentMethodId) {
          try {
            await stripe.paymentMethods.attach(paymentMethodId, {
              customer: order.stripeCustomerId,
            });
          } catch (e: any) {
            // Payment method might already be attached, that's OK
            if (!e.message?.includes('already been attached')) {
              throw e;
            }
          }
          
          // Set as default payment method
          await stripe.customers.update(order.stripeCustomerId, {
            invoice_settings: {
              default_payment_method: paymentMethodId,
            },
          });
        }

        // Get the subscription price ID from environment variable
        const subscriptionPriceId = Deno.env.get('STRIPE_SUBSCRIPTION_PRICE_ID');
        if (!subscriptionPriceId) {
          console.error('‚ùå STRIPE_SUBSCRIPTION_PRICE_ID environment variable not set!');
          throw new Error('Subscription price not configured. Please create a Stripe Price for $12/month and set STRIPE_SUBSCRIPTION_PRICE_ID environment variable.');
        }

        // Create the subscription with trial period until January 1st
        const subscription = await stripe.subscriptions.create({
          customer: order.stripeCustomerId,
          items: [
            {
              price: subscriptionPriceId, // $12/month subscription price from env
              quantity: qty,
            },
          ],
          trial_end: trialEndTimestamp, // Use trial_end instead of billing_cycle_anchor
          proration_behavior: "none",
          default_payment_method: paymentMethodId,
          metadata: {
            orderId: order.orderId,
            source: "success_page_subscription",
            numberOfChildren: qty.toString(),
          },
        });

        console.log(`‚úÖ Subscription created: ${subscription.id} for ${qty} children, billing starts January 1st`);

        // CREATE A NEW SEPARATE SUBSCRIPTION ORDER (no letters sent immediately)
        const subscriptionOrderId = `SUB-${Date.now()}-${Math.random().toString(36).substring(7)}`;
        
        // Copy letter data from original order for subscription letters (up to qty)
        const subscriptionLetters = [];
        if (order.letterPackages && order.letterPackages.length > 0) {
          // Copy up to qty letters from the original order
          for (let i = 0; i < qty; i++) {
            const sourceLetter = order.letterPackages[i] || order.letterPackages[0]; // Use first letter as template if not enough
            subscriptionLetters.push({
              childFirstName: sourceLetter.childFirstName || "",
              childLastName: sourceLetter.childLastName || "",
              friendName: sourceLetter.friendName || "",
              streetAddress: sourceLetter.streetAddress || "",
              unitApt: sourceLetter.unitApt || "",
              city: sourceLetter.city || "",
              state: sourceLetter.state || "",
              zipCode: sourceLetter.zipCode || "",
              letterIndex: i + 1, // Track which letter this is
            });
          }
        } else {
          // Create blank letter data if no original order data
          for (let i = 0; i < qty; i++) {
            subscriptionLetters.push({
              childFirstName: "",
              childLastName: "",
              friendName: "",
              streetAddress: "",
              unitApt: "",
              city: "",
              state: "",
              zipCode: "",
              letterIndex: i + 1,
            });
          }
        }
        
        const subscriptionOrder: any = {
          orderId: subscriptionOrderId,
          orderDate: new Date().toISOString(),
          status: "subscription_active",
          total: 0, // $0 initial charge
          customerInfo: order.customerInfo,
          stripeCustomerId: order.stripeCustomerId,
          stripePaymentMethodId: paymentMethodId,
          stripePaymentId: paymentIntentId,
          stripeCheckoutUrl: `https://dashboard.stripe.com/subscriptions/${subscription.id}`,
          letterPackages: [], // NO LETTERS sent in this order - subscription only
          subscriptionLetters: subscriptionLetters, // Store subscription letter data separately
          numberOfPackages: 0,
          shippingDate: order.shippingDate || "", // Copy shipping date from original order
          monthlySubscription: true,
          subscriptionId: subscription.id,
          subscriptionQuantity: qty,
          subscriptionStartDate: new Date(january1st).toISOString(),
          subscriptionNextBillingDate: new Date(january1st).toISOString(),
          subscriptionMonthsActive: 0,
          subscriptionPrice: 12.00 * qty, // Total monthly price: $12 per child
          subscriptionProductName: "Santa's Magical Journey",
          billingIntervalDays: 30,
          subscriptionSource: "success_page_upsell",
          originalOrderId: order.orderId, // Reference to the original order
          accessToken: `sub_${Date.now()}_${Math.random().toString(36).substring(7)}`,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          activityLog: [
            {
              timestamp: new Date().toISOString(),
              action: "Subscription Order Created",
              details: `Subscription activated from success page for ${qty} ${qty === 1 ? 'child' : 'children'}. First billing: January 1st, ${january1st.getFullYear()} (${(12 * qty).toFixed(2)}/month). Letter data copied from original order. No immediate letters sent.`,
              user: "Customer",
              stripeUrl: `https://dashboard.stripe.com/subscriptions/${subscription.id}`,
            }
          ],
        };

        // Save the NEW subscription order
        await kv.set(`order:${subscriptionOrderId}`, subscriptionOrder);
        
        // Add to global orders list
        const allOrderIds = (await kv.get("orders:all")) || [];
        allOrderIds.push(subscriptionOrderId);
        await kv.set("orders:all", allOrderIds);

        console.log(`‚úÖ Created separate subscription order: ${subscriptionOrderId}`);

        // Update ORIGINAL order to reference the subscription order
        if (!order.activityLog) {
          order.activityLog = [];
        }
        order.activityLog.push({
          timestamp: new Date().toISOString(),
          action: "Subscription Upsell Accepted",
          details: `Customer added Santa's Magical Journey subscription (${qty} ${qty === 1 ? 'child' : 'children'}). Separate subscription order created: ${subscriptionOrderId}`,
          user: "Customer",
          stripeUrl: `https://dashboard.stripe.com/subscriptions/${subscription.id}`,
        });
        
        order.linkedSubscriptionOrderId = subscriptionOrderId;
        order.updatedAt = new Date().toISOString();
        await kv.set(`order:${orderId}`, order);
        
        console.log(`‚úÖ Original order ${orderId} updated with subscription reference`);

        // Return subscription-specific data
        return c.json({
          success: true,
          isSubscription: true,
          subscriptionId: subscription.id,
          subscriptionOrderId: subscriptionOrderId,
          upsellName: "Santa's Magical Journey",
          quantity: qty,
          total: 0,
          billingStart: january1st.toISOString(),
          monthlyPrice: 12 * qty,
        });

      } catch (subError: any) {
        console.error("‚ùå Failed to create subscription from success page:", subError);
        throw new Error(`Subscription creation failed: ${subError.message}`);
      }
    } else {
      // Regular upsell (non-subscription)
      if (!order.upsellsAccepted) {
        order.upsellsAccepted = [];
      }

      order.upsellsAccepted.push({
        upsellId: upsellId,
        name: upsellName,
        quantity: qty,
        price: unitPrice,
        total,
        chargedAt: new Date().toISOString(),
        stripePaymentIntentId: paymentIntentId,
        source: source || "success_page",
      });

      // Update order total
      order.total = (order.total || 0) + total;
      order.updatedAt = new Date().toISOString();

      // Add activity log
      if (!order.activityLog) {
        order.activityLog = [];
      }
      order.activityLog.push({
        timestamp: new Date().toISOString(),
        action: "Success Page Upsell Added",
        details: `${qty}x ${upsellName} - ${total.toFixed(2)} charged`,
        user: "Customer",
        stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntentId}`,
      });

      await kv.set(`order:${orderId}`, order);
      
      console.log(`‚úÖ Upsell confirmed and added to order: ${upsellName}`);

      // Send confirmation email for regular upsells
      try {
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        if (resendApiKey && order.customerInfo?.email) {
          const emailHtml = `
            <!DOCTYPE html>
            <html>
            <head>
              <meta charset="utf-8">
              <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
            </head>
            <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
              <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                  <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÅ Item Added to Your Order!</h1>
                </div>
                <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                  <p>Hi ${order.customerInfo.name || "there"},</p>
                  
                  <p style="font-size: 18px; color: #059669;"><strong>‚úÖ Great choice! Your order has been updated.</strong></p>
                  
                  <div style="background: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #16a34a;">
                    <p style="margin: 0 0 10px 0;"><strong>Item Added:</strong></p>
                    <p style="font-size: 20px; margin: 0; color: #16a34a;"><strong>${qty}x ${upsellName}</strong></p>
                    <p style="margin: 10px 0 0 0; font-size: 24px; color: #16a34a;"><strong>${total.toFixed(2)}</strong></p>
                  </div>
                  
                  <p style="margin-top: 30px;">This item has been added to Order #${order.orderId} and will be included with your original order.</p>
                  
                  <p style="margin-top: 30px;">Questions? Reply to this email and we'll help!</p>
                  
                  <p>With Christmas cheer,<br>The Santa's Letters Team üéÑ</p>
                </div>
              </div>
            </body>
            </html>
          `;

          await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${resendApiKey}`,
            },
            body: JSON.stringify({
              from: EMAIL_FROM,
              to: [order.customerInfo.email],
              subject: `üéÅ ${upsellName} Added to Your Order!`,
              html: emailHtml,
            }),
          });

          console.log("üìß Upsell confirmation email sent");
        }
      } catch (emailError) {
        console.error("‚ùå Failed to send confirmation email:", emailError);
        // Don't fail the request if email fails
      }

      return c.json({
        success: true,
        isSubscription: false,
        upsellName,
        quantity: qty,
        total,
      });
    }
  } catch (error: any) {
    console.error("‚ùå Error confirming upsell:", error);
    return c.json({ error: error.message }, 500);
  }
});

// ========== ADMIN SUBSCRIPTION MANAGEMENT ENDPOINTS ==========

// Update subscription letters
app.post("/make-server-cf244566/admin/update-subscription-letters", async (c) => {
  try {
    const { orderId, subscriptionLetters } = await c.req.json();

    // Get order
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    // Update subscription letters
    order.subscriptionLetters = subscriptionLetters;
    order.updatedAt = new Date().toISOString();

    // Add activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: "Subscription Letters Updated",
      details: `Subscription letter data updated by admin. Total letters: ${subscriptionLetters.length}`,
      user: "Admin",
    });

    await kv.set(`order:${orderId}`, order);

    console.log(`‚úÖ Updated subscription letters for ${orderId}`);
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error updating subscription letters:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Update subscription quantity and sync with Stripe
app.post("/make-server-cf244566/admin/update-subscription-quantity", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }

  try {
    const { orderId, newQuantity, subscriptionLetters, subscriptionId } = await c.req.json();

    // Get order
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    const oldQuantity = order.subscriptionQuantity || 0;
    const oldPrice = order.subscriptionPrice || 12.00;

    // Calculate new price based on quantity ($12 per letter)
    const newPrice = newQuantity * 12.00;

    // Update order
    order.subscriptionQuantity = newQuantity;
    order.subscriptionLetters = subscriptionLetters;
    order.subscriptionPrice = newPrice;
    order.updatedAt = new Date().toISOString();

    // Update Stripe subscription quantity
    if (subscriptionId && stripe) {
      try {
        const subscription = await stripe.subscriptions.retrieve(subscriptionId);
        
        if (subscription.items.data.length > 0) {
          const subscriptionItemId = subscription.items.data[0].id;
          
          await stripe.subscriptionItems.update(subscriptionItemId, {
            quantity: newQuantity,
          });

          console.log(`‚úÖ Updated Stripe subscription quantity from ${oldQuantity} to ${newQuantity} (Price: ${oldPrice.toFixed(2)} ‚Üí ${newPrice.toFixed(2)})`);
        }
      } catch (stripeError) {
        console.error("‚ùå Error updating Stripe subscription:", stripeError);
        throw new Error("Failed to update Stripe subscription quantity");
      }
    }

    // Add activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: "Subscription Quantity Adjusted",
      details: `Subscription quantity changed from ${oldQuantity} to ${newQuantity} letters by admin. Monthly price updated from ${oldPrice.toFixed(2)} to ${newPrice.toFixed(2)}. Stripe subscription updated.`,
      user: "Admin",
      stripeUrl: subscriptionId ? `https://dashboard.stripe.com/subscriptions/${subscriptionId}` : undefined,
    });

    await kv.set(`order:${orderId}`, order);

    console.log(`‚úÖ Updated subscription quantity for ${orderId}: ${oldQuantity} ‚Üí ${newQuantity} (Price: ${oldPrice.toFixed(2)} ‚Üí ${newPrice.toFixed(2)})`);
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error updating subscription quantity:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Charge subscription immediately
app.post("/make-server-cf244566/admin/charge-subscription-now", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }

  try {
    const { orderId, amount, quantity, customerId, paymentMethodId } = await c.req.json();

    // Get order
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    // Create a payment intent to charge the customer
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(amount * 100), // Convert to cents
      currency: "usd",
      customer: customerId,
      payment_method: paymentMethodId,
      confirm: true,
      off_session: true,
      description: `Santa's Magical Journey - Manual charge for ${quantity} ${quantity === 1 ? 'letter' : 'letters'}`,
      metadata: {
        orderId: orderId,
        subscriptionCharge: "true",
        quantity: quantity.toString(),
      },
    });

    if (paymentIntent.status !== "succeeded") {
      throw new Error(`Payment failed: ${paymentIntent.status}`);
    }

    console.log(`‚úÖ Successfully charged ${amount} for subscription ${orderId}`);

    // Increment successful charges counter
    order.successfulCharges = (order.successfulCharges || 0) + 1;
    order.subscriptionMonthsActive = order.successfulCharges;
    
    // Add activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: "Manual Subscription Charge",
      details: `Admin manually charged ${amount.toFixed(2)} for ${quantity} ${quantity === 1 ? 'letter' : 'letters'}. Month ${order.successfulCharges}.`,
      user: "Admin",
      stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntent.id}`,
    });

    order.updatedAt = new Date().toISOString();
    await kv.set(`order:${orderId}`, order);

    // Create a new order for this charge (for fulfillment)
    console.log(`üì¶ [Custom Charge] Creating fulfillment order. Subscription letters count: ${(order.subscriptionLetters || []).length}`);
    console.log(`üì¶ [Custom Charge] Subscription letters data:`, JSON.stringify(order.subscriptionLetters));
    
    const allOrderIds = (await kv.get("orders:all")) || [];
    const newOrderId = `ord_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    const newOrder = {
      orderId: newOrderId,
      parentOrderId: order.orderId,
      subscriptionId: order.subscriptionId,
      sessionId: paymentIntent.id,
      stripePaymentId: paymentIntent.id,
      stripeCheckoutUrl: `https://dashboard.stripe.com/payments/${paymentIntent.id}`,
      orderDate: new Date().toISOString(),
      status: "pending",
      total: amount,
      customerInfo: order.customerInfo,
      letterPackages: order.letterPackages,
      numberOfPackages: order.numberOfPackages,
      letters: order.subscriptionLetters || [], // Copy subscription letter data for fulfillment
      shippingDate: "",
      monthlySubscription: false,
      subscriptionRecurringOrder: true,
      subscriptionMonth: order.successfulCharges,
      subscriptionProductName: order.subscriptionProductName || "Santa's Magical Journey",
      affiliateId: order.affiliateId,
      affiliateName: order.affiliateName,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      activityLog: [{
        timestamp: new Date().toISOString(),
        action: 'Order Created',
        details: `Recurring subscription order - Manual charge. Copied ${(order.subscriptionLetters || []).length} letter(s) from subscription.`,
        user: 'Admin'
      }]
    };
    
    await kv.set(`order:${newOrderId}`, newOrder);
    allOrderIds.push(newOrderId);
    await kv.set("orders:all", allOrderIds);
    
    console.log(`‚úÖ Created new order ${newOrderId} for manual charge`);

    // Send email notification
    try {
      const resendApiKey = Deno.env.get("RESEND_API_KEY");
      if (resendApiKey && order.customerInfo?.email) {
        const emailHtml = `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
          </head>
          <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <div style="background: linear-gradient(135deg, #7c3aed 0%, #db2777 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üí≥ Payment Processed</h1>
              </div>
              <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                <p>Hi ${order.customerInfo.name || "there"},</p>
                
                <p style="font-size: 18px; color: #7c3aed;"><strong>Your subscription payment has been processed successfully.</strong></p>
                
                <div style="background: #f3e8ff; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #7c3aed;">
                  <p style="margin: 0 0 10px 0;"><strong>Santa's Magical Journey</strong></p>
                  <p style="font-size: 20px; margin: 0; color: #7c3aed;"><strong>${quantity} ${quantity === 1 ? 'Letter' : 'Letters'}</strong></p>
                  <p style="margin: 10px 0 0 0; font-size: 24px; color: #7c3aed;"><strong>${amount.toFixed(2)}</strong></p>
                </div>
                
                <p style="margin-top: 30px;">Your personalized letters from Santa will continue to arrive monthly, bringing joy and magic to your child throughout the year!</p>
                
                <p style="margin-top: 30px;">Questions? Reply to this email and we'll help!</p>
                
                <p>With Christmas cheer,<br>The Santa's Letters Team üéÑ</p>
              </div>
            </div>
          </body>
          </html>
        `;

        const emailResponse = await fetch("https://api.resend.com/emails", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${resendApiKey}`,
          },
          body: JSON.stringify({
            from: EMAIL_FROM,
            to: [order.customerInfo.email],
            subject: `üí≥ Subscription Payment Processed - ${amount.toFixed(2)}`,
            html: emailHtml,
          }),
        });

        if (emailResponse.ok) {
          const emailData = await emailResponse.json();
          console.log(`‚úÖ Payment confirmation email sent to ${order.customerInfo.email}`);

          // Log email in activity log
          await logEmailActivity(
            orderId,
            "subscription_charge_email",
            order.customerInfo.email,
            `üí≥ Subscription Payment Processed - ${amount.toFixed(2)}`,
            emailData.id
          );
        } else {
          const errorText = await emailResponse.text();
          console.error("‚ùå Failed to send payment confirmation email:", errorText);
        }
      }
    } catch (emailError) {
      console.error("‚ùå Error sending payment email:", emailError);
      // Don't fail the charge if email fails
    }

    return c.json({
      success: true,
      paymentIntentId: paymentIntent.id,
      amount,
    });
  } catch (error: any) {
    console.error("‚ùå Error charging subscription:", error);
    return c.json({ error: error.message }, 500);
  }
});

// ========== GLOBAL SETTINGS ENDPOINTS ==========

// Get global settings (default prices, etc.)
app.get("/make-server-cf244566/settings", async (c) => {
  try {
    const settings: any = await kv.get("global:settings") || {
      defaultLetterPrice: 17.95,
      updatedAt: new Date().toISOString(),
    };

    // Ensure default values exist
    if (!settings.defaultLetterPrice) {
      settings.defaultLetterPrice = 17.95;
    }

    return c.json(settings);
  } catch (error: any) {
    console.error("‚ùå Error fetching settings:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Update global settings (admin only)
app.post("/make-server-cf244566/admin/update-settings", async (c) => {
  try {
    const { defaultLetterPrice } = await c.req.json();

    if (typeof defaultLetterPrice !== 'number' || defaultLetterPrice <= 0) {
      return c.json({ error: "Invalid price value" }, 400);
    }

    const settings = {
      defaultLetterPrice,
      updatedAt: new Date().toISOString(),
    };

    await kv.set("global:settings", settings);

    console.log(`‚úÖ Updated global settings: defaultLetterPrice = ${defaultLetterPrice}`);
    return c.json({ success: true, settings });
  } catch (error: any) {
    console.error("‚ùå Error updating settings:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Delete order permanently
app.delete("/make-server-cf244566/orders/:orderId/delete", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const order: any = await kv.get(`order:${orderId}`);
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    // Only allow deletion of archived orders for safety
    if (!order.archived) {
      return c.json({ error: "Only archived orders can be permanently deleted. Archive the order first." }, 400);
    }

    // Delete the order from KV store
    await kv.del(`order:${orderId}`);
    
    // Remove from orders list
    const allOrderIds: string[] = (await kv.get("orders:all")) || [];
    const updatedOrderIds = allOrderIds.filter(id => id !== orderId);
    await kv.set("orders:all", updatedOrderIds);
    
    // Delete token mapping if exists
    if (order.accessToken) {
      await kv.del(`token:${order.accessToken}`);
    }

    console.log(`‚úÖ Order ${orderId} permanently deleted from database`);
    return c.json({ success: true, message: "Order permanently deleted" });
  } catch (error: any) {
    console.error("Error deleting order:", error);
    return c.json({ error: "Failed to delete order" }, 500);
  }
});

// Register Trackdesk postback routes
registerTrackdeskRoutes(app);

Deno.serve(app.fetch);
/*
=== ORPHANED CODE DISABLED ===
All code below this line has been commented out to fix deployment errors.
This orphaned code was left from previous refactoring and is no longer needed.
                  
                  <h3 style="color: #dc2626; margin-top: 30px;">üì¨ Your Letter Packages:</h3>
                  ${packagesHtml}
                  
                  <p style="margin-top: 30px;"><strong>What happens next?</strong></p>
                  <ul>
                    <li>‚ú® We're preparing your personalized letters from Santa</li>
                    <li>üìù Each letter will include a Good Behavior Certificate and Nice List</li>
                    <li>üìÆ Your packages will ship within 2-3 business days</li>
                    <li>üìß You'll receive a shipping notification with tracking</li>
                  </ul>
                  ${monthlySubscription ? `
                  <p style="margin-top: 30px; padding: 20px; background: #fff7ed; border-radius: 8px; border-left: 4px solid #f97316;">
                    <strong>üéÅ Welcome to Santa's Magical Adventures!</strong><br>
                    You're all set! Your subscription will start in January 2026 at $12/month. You can cancel anytime. Get ready for monthly packages filled with heartwarming stories from Santa!
                  </p>
                  ` : ''}
                  
                  <p style="margin-top: 30px; padding: 20px; background: #fef2f2; border-radius: 8px; border-left: 4px solid #dc2626;">
                    <strong>üéÑ Keep the Magic Alive!</strong><br>
                    Make sure to retrieve the mail before your little ones do! üòä
                  </p>
                </div>
                <div style="background: #f9fafb; padding: 20px; text-align: center; color: #6b7280; font-size: 14px; border-radius: 0 0 10px 10px;">
                  <p>Questions? Contact us at support@letterfromsanta.com</p>
                  <p style="margin-top: 10px; color: #9ca3af;">¬© 2025 Letters From Santa. All rights reserved.</p>
                </div>
              </div>
            </body>
            </html>
          `;

          const emailResponse = await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${resendApiKey}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
              to: [customerEmail],
              subject: `üéÖ Your Letters From Santa Order Confirmed! #${session.id.slice(-8)}`,
              html: emailHtml,
            }),
          });

          if (emailResponse.ok) {
            console.log("Order confirmation email sent to:", customerEmail);
          } else {
            console.error("Failed to send confirmation email:", await emailResponse.text());
          }

          // Send SMS if phone number provided
          const twilioSid = Deno.env.get("TWILIO_ACCOUNT_SID");
          const twilioToken = Deno.env.get("TWILIO_AUTH_TOKEN");
          const twilioPhone = Deno.env.get("TWILIO_PHONE_NUMBER");

          if (twilioSid && twilioToken && twilioPhone && customerPhone) {
            const twilioUrl = `https://api.twilio.com/2010-04-01/Accounts/${twilioSid}/Messages.json`;
            const credentials = btoa(`${twilioSid}:${twilioToken}`);

            const formData = new URLSearchParams();
            formData.append("To", customerPhone);
            formData.append("From", twilioPhone);
            formData.append("Body", `üéÖ Thank you! Your Letters From Santa order #${session.id.slice(-8)} is confirmed. We'll send tracking info when it ships! Check your email for details.`);

            const smsResponse = await fetch(twilioUrl, {
              method: "POST",
              headers: {
                Authorization: `Basic ${credentials}`,
                "Content-Type": "application/x-www-form-urlencoded",
              },
              body: formData.toString(),
            });

            if (smsResponse.ok) {
              console.log("Order confirmation SMS sent to:", customerPhone);
            } else {
              console.error("Failed to send confirmation SMS:", await smsResponse.text());
            }
          }
        }
      } catch (error) {
        console.error("Error sending order confirmation notifications:", error);
        // Don't fail the webhook if email/SMS fails
      }

      // Track sale event for affiliate
      if (affiliateId) {
        const eventId = `event_${Date.now()}_${Math.random().toString(36).substring(7)}`;
        const event = {
          eventId,
          affiliateId,
          eventType: "sale",
          orderId: session.id,
          revenue: order.total,
          commission: affiliateCommission,
          subIds: subIds || {},
          timestamp: new Date().toISOString(),
        };

        await kv.set(`event:${eventId}`, event);

        const allEventIds = (await kv.get("events:all")) || [];
        allEventIds.push(eventId);
        await kv.set("events:all", allEventIds);

        // Fire sale postback
        const postbacks = (await kv.get(`postbacks:${affiliateId}`)) || [];
        for (const postback of postbacks) {
          if (postback.enabledEvents && postback.enabledEvents.includes("sale")) {
            try {
              let url = postback.postbackUrl
                .replace('{affiliate_id}', affiliateId)
                .replace('{event_type}', 'sale')
                .replace('{amount}', order.total.toString())
                .replace('{commission}', affiliateCommission.toString())
                .replace('{orderid}', session.id)
                .replace('{timestamp}', event.timestamp);

              // Add sub IDs to URL
              Object.entries(subIds || {}).forEach(([key, value]) => {
                url = url.replace(`{${key}}`, value as string);
              });

              const response = await fetch(url, { method: 'GET' });
              
              const postbackLog = {
                postbackId: `pb_${Date.now()}`,
                affiliateId,
                eventId,
                eventType: "sale",
                orderId: session.id,
                url,
                status: response.ok ? "success" : "failed",
                statusCode: response.status,
                timestamp: new Date().toISOString(),
              };

              await kv.set(`postback_log:${postbackLog.postbackId}`, postbackLog);

              const allPostbackLogs = (await kv.get("postback_logs:all")) || [];
              allPostbackLogs.push(postbackLog.postbackId);
              await kv.set("postback_logs:all", allPostbackLogs);
            } catch (err: any) {
              console.error("Error firing sale postback:", err);
            }
          }
        }
      }
    }

    // Handle chargebacks
    if (event.type === "charge.dispute.created") {
      const dispute = event.data.object as any;
      const chargeId = dispute.charge;
      
      console.log("Chargeback created:", dispute.id);

      try {
        // Find the order associated with this charge
        const allOrderIds = (await kv.get("orders:all")) || [];
        let affectedOrder: any = null;
        
        for (const orderId of allOrderIds) {
          const order: any = await kv.get(`order:${orderId}`);
          if (order && order.sessionId && order.sessionId.includes(chargeId)) {
            affectedOrder = order;
            break;
          }
        }

        if (affectedOrder) {
          const chargebackId = `cb_${Date.now()}_${Math.random().toString(36).substring(7)}`;
          
          const chargeback = {
            chargebackId,
            orderId: affectedOrder.orderId,
            sessionId: affectedOrder.sessionId,
            affiliateId: affectedOrder.affiliateId || "direct",
            affiliateName: affectedOrder.affiliateName || "Direct Sale",
            amount: affectedOrder.total || 0,
            commission: affectedOrder.affiliateCommission || 0,
            reason: dispute.reason || "unknown",
            stripeChargeId: chargeId,
            stripeDisputeId: dispute.id,
            chargebackDate: new Date().toISOString(),
            orderDate: affectedOrder.orderDate,
            status: "pending",
            customerEmail: affectedOrder.customerInfo?.email || "",
            createdAt: new Date().toISOString(),
          };

          // Save chargeback
          await kv.set(`chargeback:${chargebackId}`, chargeback);
          
          const allChargebacks = (await kv.get("chargebacks:all")) || [];
          allChargebacks.push(chargebackId);
          await kv.set("chargebacks:all", allChargebacks);

          // Update order status
          affectedOrder.status = "chargeback";
          affectedOrder.chargebackId = chargebackId;
          affectedOrder.updatedAt = new Date().toISOString();
          await kv.set(`order:${affectedOrder.sessionId}`, affectedOrder);

          console.log("Chargeback recorded:", chargebackId);
        }
      } catch (error) {
        console.error("Error processing chargeback:", error);
      }
    }

    // Handle chargeback updates
    if (event.type === "charge.dispute.closed") {
      const dispute = event.data.object as any;
      
      // Find the chargeback
      const allChargebacks = (await kv.get("chargebacks:all")) || [];
      for (const chargebackId of allChargebacks) {
        const chargeback: any = await kv.get(`chargeback:${chargebackId}`);
        if (chargeback && chargeback.stripeDisputeId === dispute.id) {
          chargeback.status = dispute.status === "won" ? "won" : "lost";
          chargeback.updatedAt = new Date().toISOString();
          await kv.set(`chargeback:${chargebackId}`, chargeback);
          
          console.log(`Chargeback ${chargebackId} updated to: ${chargeback.status}`);
          break;
        }
      }
    }

    // Handle payment declines
    if (event.type === "payment_intent.payment_failed") {
      const paymentIntent = event.data.object as any;
      
      console.log("Payment declined:", paymentIntent.id);

      const declineId = `dec_${Date.now()}_${Math.random().toString(36).substring(7)}`;
      
      const decline = {
        declineId,
        paymentIntentId: paymentIntent.id,
        amount: paymentIntent.amount / 100,
        reason: paymentIntent.last_payment_error?.message || "unknown",
        customerEmail: paymentIntent.receipt_email || "",
        declineDate: new Date().toISOString(),
        createdAt: new Date().toISOString(),
      };

      await kv.set(`decline:${declineId}`, decline);
      
      const allDeclines = (await kv.get("declines:all")) || [];
      allDeclines.push(declineId);
      await kv.set("declines:all", allDeclines);
    }

    // Handle successful subscription payments (recurring charges)
    if (event.type === "invoice.payment_succeeded") {
      const invoice = event.data.object as any;
      
      // Skip if this is the initial $0 invoice
      if (invoice.amount_paid === 0 || invoice.billing_reason === "subscription_create") {
        console.log("Skipping $0 or initial subscription invoice");
        return c.json({ received: true });
      }

      console.log("üí≥ Subscription payment succeeded:", invoice.id, "Amount:", invoice.amount_paid / 100);

      // Find the parent order by subscription ID
      const allOrderIds = (await kv.get("orders:all")) || [];
      let parentOrder: any = null;
      
      for (const orderId of allOrderIds) {
        const order: any = await kv.get(`order:${orderId}`);
        if (order && order.subscriptionId === invoice.subscription) {
          parentOrder = order;
          break;
        }
      }

      if (parentOrder) {
        console.log("Found parent order:", parentOrder.orderId);
        
        // Increment successful charges
        parentOrder.successfulCharges = (parentOrder.successfulCharges || 0) + 1;
        parentOrder.subscriptionMonthsActive = parentOrder.successfulCharges;
        
        // Update next billing date
        const billingInterval = parentOrder.billingIntervalDays || 30;
        const nextBilling = new Date();
        nextBilling.setDate(nextBilling.getDate() + billingInterval);
        parentOrder.subscriptionNextBillingDate = nextBilling.toISOString();
        
        // Add activity log
        if (!parentOrder.activityLog) {
          parentOrder.activityLog = [];
        }
        parentOrder.activityLog.push({
          timestamp: new Date().toISOString(),
          action: 'Subscription Payment Received',
          details: `Charged ${(invoice.amount_paid / 100).toFixed(2)}. Month ${parentOrder.successfulCharges}. Next billing: ${nextBilling.toLocaleDateString()}. Invoice: ${invoice.id}`,
          user: 'Stripe Webhook',
          stripeUrl: `https://dashboard.stripe.com/invoices/${invoice.id}`
        });
        
        await kv.set(`order:${parentOrder.orderId}`, parentOrder);
        
        // Create a new order for this month's fulfillment
        console.log(`üì¶ [Webhook] Creating fulfillment order. Subscription letters count: ${(parentOrder.subscriptionLetters || []).length}`);
        console.log(`üì¶ [Webhook] Subscription letters data:`, JSON.stringify(parentOrder.subscriptionLetters));
        
        const newOrderId = `ord_${Date.now()}_${Math.random().toString(36).substring(7)}`;
        
        // Generate secure access token for this recurring order
        const recurringAccessToken = `oat_${Array.from(crypto.getRandomValues(new Uint8Array(32)))
          .map(b => b.toString(16).padStart(2, '0'))
          .join('')}`;
        
        const newOrder = {
          orderId: newOrderId,
          accessToken: recurringAccessToken, // Add access token for customer order lookup
          parentOrderId: parentOrder.orderId,
          subscriptionId: parentOrder.subscriptionId,
          sessionId: invoice.id,
          stripePaymentId: invoice.payment_intent,
          stripeCheckoutUrl: `https://dashboard.stripe.com/invoices/${invoice.id}`,
          orderDate: new Date().toISOString(),
          status: "pending",
          total: invoice.amount_paid / 100,
          customerInfo: parentOrder.customerInfo,
          letterPackages: parentOrder.letterPackages,
          numberOfPackages: parentOrder.numberOfPackages,
          letters: parentOrder.subscriptionLetters || [], // Copy subscription letter data for fulfillment
          shippingDate: "",
          monthlySubscription: false,
          subscriptionRecurringOrder: true,
          subscriptionMonth: parentOrder.successfulCharges,
          subscriptionProductName: parentOrder.subscriptionProductName || "Santa's Magical Journey",
          affiliateId: parentOrder.affiliateId,
          affiliateName: parentOrder.affiliateName,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          activityLog: [{
            timestamp: new Date().toISOString(),
            action: 'Order Created',
            details: `Recurring subscription order - Month ${parentOrder.successfulCharges}. Copied ${(parentOrder.subscriptionLetters || []).length} letter(s) from subscription.`,
            user: 'Stripe Webhook'
          }]
        };
        
        await kv.set(`order:${newOrderId}`, newOrder);
        allOrderIds.push(newOrderId);
        await kv.set("orders:all", allOrderIds);
        
        // Store token -> orderId mapping for quick lookup
        await kv.set(`token:${recurringAccessToken}`, newOrderId);
        
        console.log(`‚úÖ Created new order ${newOrderId} for subscription payment`);
        
        // Send email notification
        try {
          const resendApiKey = Deno.env.get("RESEND_API_KEY");
          if (resendApiKey && parentOrder.customerInfo?.email) {
            const emailResponse = await fetch("https://api.resend.com/emails", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${resendApiKey}`,
              },
              body: JSON.stringify({
                from: EMAIL_FROM,
                to: [parentOrder.customerInfo.email],
                subject: `üéÖ Your Month ${parentOrder.successfulCharges} Santa Letter is Coming!`,
                html: `
                  <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                    <h2 style="color: #dc2626;">üéÑ Ho Ho Ho!</h2>
                    <p>Dear ${parentOrder.customerInfo.name},</p>
                    <p>Great news! Your monthly Santa letter subscription payment has been processed successfully.</p>
                    <p><strong>Amount Charged:</strong> ${(invoice.amount_paid / 100).toFixed(2)}</p>
                    <p><strong>Subscription Month:</strong> ${parentOrder.successfulCharges}</p>
                    <p><strong>Product:</strong> ${parentOrder.subscriptionProductName || "Santa's Magical Journey"}</p>
                    <p>Your magical letter will be prepared and shipped soon!</p>
                    <p><strong>Next Billing Date:</strong> ${nextBilling.toLocaleDateString()}</p>
                    <p style="color: #059669;">Thank you for continuing this magical journey with us! üéÖ‚ú®</p>
                  </div>
                `,
              }),
            });
            
            if (emailResponse.ok) {
              const emailData = await emailResponse.json();
              console.log("‚úÖ Sent subscription payment notification email. Email ID:", emailData.id);
              
              // Log email activity
              await logEmailActivity(
                parentOrder.orderId,
                'subscription_payment',
                parentOrder.customerInfo.email,
                'Subscription Payment Confirmation',
                emailData.id
              );
            }
          }
        } catch (emailError) {
          console.error("Error sending subscription payment email:", emailError);
        }
      }
    }

    // Handle failed subscription payments
    if (event.type === "invoice.payment_failed") {
      const invoice = event.data.object as any;
      
      console.log("‚ùå Subscription payment failed:", invoice.id);

      // Find the parent order
      const allOrderIds = (await kv.get("orders:all")) || [];
      for (const orderId of allOrderIds) {
        const order: any = await kv.get(`order:${orderId}`);
        if (order && order.subscriptionId === invoice.subscription) {
          // Increment declined charges
          order.declinedCharges = (order.declinedCharges || 0) + 1;
          
          // Add activity log
          if (!order.activityLog) {
            order.activityLog = [];
          }
          order.activityLog.push({
            timestamp: new Date().toISOString(),
            action: 'Subscription Payment Failed',
            details: `Payment declined for ${(invoice.amount_due / 100).toFixed(2)}. Total declined: ${order.declinedCharges}. Invoice: ${invoice.id}`,
            user: 'Stripe Webhook',
            stripeUrl: `https://dashboard.stripe.com/invoices/${invoice.id}`
          });
          
          await kv.set(`order:${orderId}`, order);
          
          // Send email notification
          try {
            const resendApiKey = Deno.env.get("RESEND_API_KEY");
            if (resendApiKey && order.customerInfo?.email) {
              const emailResponse = await fetch("https://api.resend.com/emails", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  Authorization: `Bearer ${resendApiKey}`,
                },
                body: JSON.stringify({
                  from: EMAIL_FROM,
                  to: [order.customerInfo.email],
                  subject: "‚ö†Ô∏è Santa Letter Subscription - Payment Issue",
                  html: `
                    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                      <h2 style="color: #dc2626;">Payment Issue with Your Subscription</h2>
                      <p>Dear ${order.customerInfo.name},</p>
                      <p>We encountered an issue processing your monthly Santa letter subscription payment.</p>
                      <p><strong>Amount:</strong> ${(invoice.amount_due / 100).toFixed(2)}</p>
                      <p>Please update your payment method to continue receiving your magical letters.</p>
                      <p>If you have any questions, please contact us.</p>
                      <p style="color: #6b7280;">üéÑ Santa's Workshop</p>
                    </div>
                  `,
                }),
              });
              
              if (emailResponse.ok) {
                const emailData = await emailResponse.json();
                console.log("‚úÖ Sent payment failed email. Email ID:", emailData.id);
                
                // Log email activity
                await logEmailActivity(
                  orderId,
                  'payment_failed',
                  order.customerInfo.email,
                  'Payment Failed Notification',
                  emailData.id
                );
              }
            }
          } catch (emailError) {
            console.error("Error sending payment failed email:", emailError);
          }
          
          console.log(`‚úÖ Updated order ${orderId} with declined charge`);
          break;
        }
      }
    }

    console.log("‚úÖ Webhook processed successfully");
    console.log("========== WEBHOOK COMPLETE ==========\n");
    return c.json({ received: true });
  } catch (err: any) {
    console.error("‚ùå‚ùå‚ùå WEBHOOK ERROR ‚ùå‚ùå‚ùå");
    console.error("Error type:", err.constructor.name);
    console.error("Error message:", err.message);
    console.error("Error stack:", err.stack);
    console.error("Full error:", JSON.stringify(err, null, 2));
    console.error("========== WEBHOOK FAILED ==========\n");
    return c.json({ error: err.message }, 400);
  }
});

// TESTING: Simulate a webhook call (for debugging webhook handler)
app.post("/make-server-cf244566/test-webhook-simulation", async (c) => {
  console.log("üß™ WEBHOOK SIMULATION STARTED");
  
  try {
    const testSessionId = `cs_test_sim_${Date.now()}`;
    
    // Simulate what the webhook handler does
    const letterPackages = [{
      childFirstName: "Webhook",
      childLastName: "Test",
      friendName: "Test Friend",
      streetAddress: "123 Webhook St",
      unitApt: "",
      city: "Test City",
      state: "CA",
      zipCode: "12345",
    }];
    
    const order = {
      orderId: testSessionId,
      sessionId: testSessionId,
      stripePaymentId: `pi_webhook_test_${Date.now()}`,
      stripeCheckoutUrl: `https://dashboard.stripe.com/test/payments/pi_webhook_test_${Date.now()}`,
      orderDate: new Date().toISOString(),
      status: "pending",
      total: 17.95,
      customerInfo: {
        email: "webhook-test@test.com",
        name: "Webhook Test Customer",
        phone: "5555555555",
        address: {
          line1: "123 Webhook St",
          line2: "",
          city: "Test City",
          state: "CA",
          postal_code: "12345",
          country: "US",
        },
      },
      letterPackages,
      numberOfPackages: 1,
      shippingDate: "December 15th",
      monthlySubscription: false,
      subscriptionId: null,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    console.log("Simulating order save...");
    await kv.set(`order:${testSessionId}`, order);
    
    const allOrderIds = (await kv.get("orders:all")) || [];
    allOrderIds.push(testSessionId);
    await kv.set("orders:all", allOrderIds);
    
    console.log("‚úÖ Webhook simulation complete - order created:", testSessionId);
    
    return c.json({ 
      success: true, 
      message: "Webhook simulation successful",
      orderId: testSessionId,
      note: "This simulates what the Stripe webhook does. Check admin dashboard!"
    });
  } catch (error: any) {
    console.error("‚ùå Webhook simulation failed:", error);
    return c.json({ error: error.message }, 500);
  }
});

// TESTING: Create a test order manually (for debugging)
app.post("/make-server-cf244566/test-order", async (c) => {
  try {
    const testOrderId = `test_order_${Date.now()}`;
    
    const testOrder = {
      orderId: testOrderId,
      sessionId: testOrderId,
      stripePaymentId: `pi_test_${Date.now()}`,
      stripeCheckoutUrl: `https://dashboard.stripe.com/test/payments/pi_test_${Date.now()}`,
      orderDate: new Date().toISOString(),
      status: "pending",
      total: 17.95,
      customerInfo: {
        name: "Test Customer",
        email: "test@test.com",
        phone: "5555555555",
        address: {
          line1: "123 Test St",
          line2: "",
          city: "Test City",
          state: "CA",
          postal_code: "12345",
          country: "US",
        },
      },
      letterPackages: [{
        childFirstName: "Test",
        childLastName: "Child",
        friendName: "Best Friend",
        streetAddress: "123 Test St",
        unitApt: "",
        city: "Test City",
        state: "CA",
        zipCode: "12345",
      }],
      numberOfPackages: 1,
      shippingDate: "December 15th",
      monthlySubscription: false,
      subscriptionId: null,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    // Save the order
    await kv.set(`order:${testOrderId}`, testOrder);
    
    // Add to orders list
    const allOrderIds = (await kv.get("orders:all")) || [];
    allOrderIds.push(testOrderId);
    await kv.set("orders:all", allOrderIds);

    console.log("Test order created:", testOrderId);
    
    return c.json({ 
      success: true, 
      orderId: testOrderId,
      message: "Test order created successfully" 
    });
  } catch (error: any) {
    console.error("Error creating test order:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Get all orders (admin only)
app.get("/make-server-cf244566/orders", async (c) => {
  try {
    const allOrderIds = (await kv.get("orders:all")) || [];
    
    // Fetch all orders
    const orders = [];
    for (const orderId of allOrderIds) {
      const order = await kv.get(`order:${orderId}`);
      if (order) {
        orders.push(order);
      }
    }

    // Sort by date (newest first)
    orders.sort((a: any, b: any) => new Date(b.orderDate).getTime() - new Date(a.orderDate).getTime());

    return c.json({ orders });
  } catch (error: any) {
    console.error("Error fetching orders:", error);
    return c.json({ error: "Failed to fetch orders" }, 500);
  }
});

// Get admin alerts
app.get("/make-server-cf244566/admin/alerts", async (c) => {
  try {
    const alertIds = (await kv.getByPrefix("admin_alert:")) || [];
    
    const alerts = [];
    for (const item of alertIds) {
      if (item.value) {
        alerts.push(item.value);
      }
    }

    // Sort by date (newest first)
    alerts.sort((a: any, b: any) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());

    // Count unread
    const unreadCount = alerts.filter((a: any) => a.status === "unread").length;

    return c.json({ alerts, unreadCount });
  } catch (error: any) {
    console.error("Error fetching alerts:", error);
    return c.json({ error: "Failed to fetch alerts" }, 500);
  }
});

// Mark alert as read
app.patch("/make-server-cf244566/admin/alerts/:alertId/read", async (c) => {
  try {
    const alertId = c.req.param("alertId");
    const alert: any = await kv.get(`admin_alert:${alertId}`);
    
    if (!alert) {
      return c.json({ error: "Alert not found" }, 404);
    }

    alert.status = "read";
    alert.readAt = new Date().toISOString();
    
    await kv.set(`admin_alert:${alertId}`, alert);

    return c.json({ success: true, alert });
  } catch (error: any) {
    console.error("Error marking alert as read:", error);
    return c.json({ error: "Failed to mark alert as read" }, 500);
  }
});

// Mark all alerts as read
app.post("/make-server-cf244566/admin/alerts/read-all", async (c) => {
  try {
    const alertIds = (await kv.getByPrefix("admin_alert:")) || [];
    
    for (const item of alertIds) {
      if (item.value && item.value.status === "unread") {
        item.value.status = "read";
        item.value.readAt = new Date().toISOString();
        await kv.set(item.key, item.value);
      }
    }

    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error marking all alerts as read:", error);
    return c.json({ error: "Failed to mark alerts as read" }, 500);
  }
});

// Delete alert
app.delete("/make-server-cf244566/admin/alerts/:alertId", async (c) => {
  try {
    const alertId = c.req.param("alertId");
    await kv.del(`admin_alert:${alertId}`);

    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error deleting alert:", error);
    return c.json({ error: "Failed to delete alert" }, 500);
  }
});

// Get single order by ID
app.get("/make-server-cf244566/orders/:orderId", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const order = await kv.get(`order:${orderId}`);

    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    return c.json({ order });
  } catch (error: any) {
    console.error("Error fetching order:", error);
    return c.json({ error: "Failed to fetch order" }, 500);
  }
});

// Get order by access token (for success page)
app.get("/make-server-cf244566/order/:token", async (c) => {
  try {
    const token = c.req.param("token");
    console.log(`üîç Looking up order by token: ${token?.substring(0, 15)}...`);
    
    // Search for order by access token
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    // Legacy support: try direct order ID lookup first
    if (!token.startsWith("oat_")) {
      order = await kv.get(`order:${token}`);
      if (order) {
        console.log(`‚úÖ Found order by direct ID (legacy): ${order.orderId}`);
      }
    }
    
    // Try to find by access token
    if (!order) {
      for (const orderId of allOrderIds) {
        const orderData: any = await kv.get(`order:${orderId}`);
        if (orderData && orderData.accessToken === token) {
          order = orderData;
          console.log(`‚úÖ Found order by access token: ${order.orderId}`);
          break;
        }
      }
    }
    
    if (!order) {
      console.error("‚ùå Order not found for token");
      return c.json({ error: "Order not found" }, 404);
    }
    
    // AUTO-FIX: If customer ID is missing, try to retrieve or create it
    if (!order.stripeCustomerId && stripe) {
      console.log("üîß AUTO-FIXING: Missing customer ID for order:", order.orderId);
      try {
        let customerId = null;
        
        // Try to get customer from payment intent first
        if (order.stripePaymentId) {
          try {
            const paymentIntent = await stripe.paymentIntents.retrieve(order.stripePaymentId);
            if (paymentIntent.customer) {
              customerId = paymentIntent.customer as string;
              console.log("‚úÖ Found customer ID from payment intent:", customerId);
              
              // Also get payment method if available
              if (paymentIntent.payment_method && !order.stripePaymentMethodId) {
                order.stripePaymentMethodId = paymentIntent.payment_method as string;
              }
            }
          } catch (piError: any) {
            console.log("‚ö†Ô∏è Could not retrieve payment intent:", piError.message);
          }
        }
        
        // If still no customer, create a new one from order data
        if (!customerId && order.customerInfo?.email) {
          console.log("üÜï Creating new Stripe customer for order:", order.orderId);
          const customer = await stripe.customers.create({
            email: order.customerInfo.email,
            name: order.customerInfo.name || "Customer",
            phone: order.customerInfo.phone || undefined,
            address: order.customerInfo.address ? {
              line1: order.customerInfo.address.line1 || undefined,
              line2: order.customerInfo.address.line2 || undefined,
              city: order.customerInfo.address.city || undefined,
              state: order.customerInfo.address.state || undefined,
              postal_code: order.customerInfo.address.postal_code || undefined,
              country: order.customerInfo.address.country || "US"
            } : undefined,
            metadata: {
              orderId: order.orderId,
              source: "auto-fix-migration"
            }
          });
          customerId = customer.id;
          console.log("‚úÖ Created new Stripe customer:", customerId);
        }
        
        // Save customer ID to order
        if (customerId) {
          order.stripeCustomerId = customerId;
          await kv.set(`order:${order.orderId}`, order);
          console.log("‚úÖ AUTO-FIXED: Saved customer ID to order");
        } else {
          console.error("‚ùå Could not fix customer ID - no email address available");
        }
      } catch (error: any) {
        console.error("‚ùå Auto-fix failed:", error.message);
      }
    }
    
    return c.json({ order });
  } catch (error: any) {
    console.error("Error fetching order by token:", error);
    return c.json({ error: "Failed to fetch order" }, 500);
  }
});

// Update order status (POST /orders/:orderId/status - used by admin dashboard)
app.post("/make-server-cf244566/orders/:orderId/status", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const body = await c.req.json();
    const { status } = body;

    console.log(`üìù Updating order ${orderId} status to: ${status}`);

    const order: any = await kv.get(`order:${orderId}`);

    if (!order) {
      console.error(`‚ùå Order ${orderId} not found`);
      return c.json({ error: "Order not found" }, 404);
    }

    const oldStatus = order.status;
    
    // Add activity log entry
    if (!order.activityLog) order.activityLog = [];
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Status Changed',
      details: `Status changed from "${oldStatus}" to "${status}"`,
      user: 'Admin'
    });
    
    order.status = status;
    order.updatedAt = new Date().toISOString();

    await kv.set(`order:${orderId}`, order);
    console.log(`‚úÖ Order ${orderId} status updated successfully`);

    return c.json({ success: true, order });
  } catch (error: any) {
    console.error("Error updating order status:", error);
    return c.json({ error: error.message || "Failed to update status" }, 500);
  }
});

// Update order status (PATCH /orders/:orderId - legacy)
app.patch("/make-server-cf244566/orders/:orderId", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const body = await c.req.json();
    const { status } = body;

    const order: any = await kv.get(`order:${orderId}`);

    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    const oldStatus = order.status;
    order.status = status;
    order.updatedAt = new Date().toISOString();

    await kv.set(`order:${orderId}`, order);

    // Send canceled notification if order was canceled
    if (status === "canceled-refunded" && oldStatus !== "canceled-refunded") {
      try {
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        const customerEmail = order.customerInfo?.email;
        const customerName = order.customerInfo?.name || "Valued Customer";

        if (resendApiKey && customerEmail) {
          const emailHtml = `
            <!DOCTYPE html>
            <html>
            <body style="font-family: Arial, sans-serif;">
              <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <h1>Order Canceled</h1>
                <p>Dear ${customerName},</p>
                <p>Your order <strong>#${orderId.slice(-8)}</strong> has been canceled.</p>
                <p>If you have questions, please contact support@letterfromsanta.com</p>
              </div>
            </body>
            </html>
          `;

          const emailResponse = await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${resendApiKey}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
              to: [customerEmail],
              subject: `Order Canceled - #${orderId.slice(-8)}`,
              html: emailHtml,
            }),
          });
          
          if (emailResponse.ok) {
            const emailData = await emailResponse.json();
            console.log("‚úÖ Sent order canceled email. Email ID:", emailData.id);
            
            // Log email activity
            await logEmailActivity(
              orderId,
              'order_canceled',
              customerEmail,
              'Order Canceled Notification',
              emailData.id
            );
          }
        }
      } catch (error) {
        console.error("Error sending canceled notification:", error);
      }
    }

    return c.json({ order });
  } catch (error: any) {
    console.error("Error updating order:", error);
    return c.json({ error: "Failed to update order" }, 500);
  }
});

// Edit order letter data (admin only, unfulfilled orders)
app.patch("/make-server-cf244566/orders/:orderId/letter-data", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const body = await c.req.json();
    const { letterPackages } = body;

    const order: any = await kv.get(`order:${orderId}`);

    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    if (order.status === "fulfilled") {
      return c.json({ error: "Cannot edit fulfilled orders" }, 400);
    }

    // Track changes
    const changes: string[] = [];
    const oldPackages = order.letterPackages || [];

    letterPackages.forEach((newPkg: any, idx: number) => {
      const oldPkg = oldPackages[idx];
      if (oldPkg) {
        if (oldPkg.childFirstName !== newPkg.childFirstName || oldPkg.childLastName !== newPkg.childLastName) {
          changes.push(`Child name updated for package ${idx + 1}`);
        }
        if (oldPkg.friendName !== newPkg.friendName) {
          changes.push(`Friend name updated for package ${idx + 1}`);
        }
        if (oldPkg.streetAddress !== newPkg.streetAddress || oldPkg.city !== newPkg.city) {
          changes.push(`Address updated for package ${idx + 1}`);
        }
      }
    });

    order.letterPackages = letterPackages;
    order.numberOfPackages = letterPackages.length;
    order.updatedAt = new Date().toISOString();

    await kv.set(`order:${orderId}`, order);

    // Send change notification and create admin alert
    if (changes.length > 0) {
      // Create admin alert
      const alert = {
        id: `alert-${Date.now()}`,
        type: "order_edited",
        orderId: orderId,
        message: `Order edited by customer. Admin review required before shipping.`,
        details: {
          changes: changes,
          editedBy: "Customer",
          totalPackages: letterPackages.length,
        },
        status: "unread",
        priority: "medium",
        createdAt: new Date().toISOString(),
      };
      await kv.set(`admin_alert:${alert.id}`, alert);
      
      try {
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        const customerEmail = order.customerInfo?.email;
        const customerName = order.customerInfo?.name || "Valued Customer";

        if (resendApiKey && customerEmail) {
          const changesHtml = changes.map(c => `<li>${c}</li>`).join('');
          const emailHtml = `
            <!DOCTYPE html>
            <html>
            <body style="font-family: Arial, sans-serif;">
              <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <h1>‚úèÔ∏è Order Updated</h1>
                <p>Dear ${customerName},</p>
                <p>Your order <strong>#${orderId.slice(-8)}</strong> has been updated.</p>
                <h3>Changes Made:</h3>
                <ul>${changesHtml}</ul>
                <div style="background-color: #fef3c7; padding: 15px; border-radius: 5px; margin: 20px 0;">
                  <strong>‚ö†Ô∏è Important:</strong> Our team will review and confirm these changes before shipping your order.
                </div>
                <p>Questions? Contact support@letterfromsanta.com</p>
              </div>
            </body>
            </html>
          `;

          const emailResponse = await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${resendApiKey}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
              to: [customerEmail],
              subject: `‚úèÔ∏è Order Updated - #${orderId.slice(-8)}`,
              html: emailHtml,
            }),
          });
          
          if (emailResponse.ok) {
            const emailData = await emailResponse.json();
            console.log("‚úÖ Sent customer edit notification email. Email ID:", emailData.id);
            
            // Log email activity
            await logEmailActivity(
              orderId,
              'customer_edit',
              customerEmail,
              'Customer Edit Notification',
              emailData.id
            );
          }
        }
      } catch (error) {
        console.error("Error sending change notification:", error);
      }
    }

    return c.json({ order, changes });
  } catch (error: any) {
    console.error("Error editing order:", error);
    return c.json({ error: "Failed to edit order" }, 500);
  }
});

// Add child to existing order or create new order
app.post("/make-server-cf244566/order/add-child", async (c) => {
  try {
    const body = await c.req.json();
    const { orderToken, childrenData, numberOfPackages, addNorthPoleSnow, packagePrice, paymentMethodId, isFulfilled } = body;

    // Find the original order
    const order: any = await kv.get(`order:${orderToken}`);
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    const stripe = new Stripe(Deno.env.get("STRIPE_SECRET_KEY")!);
    const northPoleSnowPrice = 9.99;
    const packagesTotal = packagePrice * numberOfPackages;
    const snowTotal = addNorthPoleSnow ? northPoleSnowPrice : 0;
    const totalAmount = packagesTotal + snowTotal;

    // Create payment intent
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(totalAmount * 100),
      currency: "usd",
      payment_method: paymentMethodId,
      confirm: true,
      automatic_payment_methods: {
        enabled: true,
        allow_redirects: "never",
      },
      description: `Additional ${numberOfPackages} letter package(s)${addNorthPoleSnow ? ' + North Pole Snow' : ''}`,
      metadata: {
        originalOrderId: order.orderId,
        orderType: isFulfilled ? "new_order" : "order_update",
        numberOfPackages: numberOfPackages.toString(),
        includesNorthPoleSnow: addNorthPoleSnow.toString(),
      },
    });

    if (paymentIntent.status !== "succeeded") {
      return c.json({ error: "Payment failed" }, 400);
    }

    // Build child names list (used in both branches)
    const childNames = childrenData.map((c: any) => `${c.childFirstName} ${c.childLastName}`).join(', ');

    if (isFulfilled) {
      // CREATE NEW ORDER
      const newOrderId = `ORD-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      const newOrder = {
        orderId: newOrderId,
        orderDate: new Date().toISOString(),
        status: "pending",
        total: totalAmount,
        customerInfo: order.customerInfo,
        letterPackages: childrenData,
        numberOfPackages: numberOfPackages,
        shippingDate: order.shippingDate,
        monthlySubscription: false,
        includesNorthPoleSnow: addNorthPoleSnow,
        northPoleSnowPrice: addNorthPoleSnow ? northPoleSnowPrice : 0,
        stripePaymentIntentId: paymentIntent.id,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        relatedOrderId: order.orderId, // Link to original order
        orderSource: "add_child_fulfilled",
        activityLog: [{
          timestamp: new Date().toISOString(),
          action: "Order Created",
          details: `New order created from existing order ${order.orderId}. ${numberOfPackages} package(s)${addNorthPoleSnow ? ' + North Pole Snow' : ''}`,
          user: "Customer"
        }]
      };

      await kv.set(`order:${newOrderId}`, newOrder);
      
      // Add to orders list
      const allOrderIds = (await kv.get("orders:all")) || [];
      allOrderIds.push(newOrderId);
      await kv.set("orders:all", allOrderIds);

      // Create admin alert
      const alert = {
        id: `alert-${Date.now()}`,
        type: "new_order_from_existing",
        orderId: newOrderId,
        relatedOrderId: order.orderId,
        message: `New order created by customer. Original order ${order.orderId} was already fulfilled.`,
        details: {
          children: childNames,
          packages: numberOfPackages,
          includesNorthPoleSnow: addNorthPoleSnow,
          amount: totalAmount,
        },
        status: "unread",
        createdAt: new Date().toISOString(),
      };
      await kv.set(`admin_alert:${alert.id}`, alert);

      // Send confirmation email
      try {
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        if (resendApiKey && order.customerInfo?.email) {
          const emailResponse = await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              Authorization: `Bearer ${resendApiKey}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              from: "Santa's Letters <orders@santasletters.com>",
              to: order.customerInfo.email,
              subject: `New Order Confirmed! Order #${newOrderId.slice(-8)}`,
              html: `
                <h2>üéÖ New Letter Package Order Confirmed!</h2>
                <p>Dear ${order.customerInfo.name},</p>
                <p>We've created a new order for your additional letter ${numberOfPackages > 1 ? 'packages' : 'package'}!</p>
                <h3>Order Details:</h3>
                <ul>
                  <li><strong>Order Number:</strong> ${newOrderId.slice(-8)}</li>
                  <li><strong>Children:</strong> ${childNames}</li>
                  <li><strong>Packages:</strong> ${numberOfPackages}</li>
                  ${addNorthPoleSnow ? '<li><strong>North Pole Snow:</strong> Included ‚ùÑÔ∏è</li>' : ''}
                  <li><strong>Total:</strong> ${totalAmount.toFixed(2)}</li>
                </ul>
                <p>Your original order (#${order.orderId.slice(-8)}) has already been shipped, so this will be processed as a separate order.</p>
                <p>Thank you for spreading more Christmas magic! üéÑ</p>
              `,
            }),
          });
          
          if (emailResponse.ok) {
            const emailData = await emailResponse.json();
            console.log("‚úÖ Sent new order confirmation email. Email ID:", emailData.id);
            
            // Log email activity to the NEW order
            await logEmailActivity(
              newOrderId,
              'new_order_confirmation',
              order.customerInfo.email,
              'New Order Confirmation',
              emailData.id
            );
          }
        }
      } catch (emailError) {
        console.error("Error sending email:", emailError);
      }

      return c.json({ 
        success: true, 
        orderCreated: true,
        orderId: newOrderId,
        message: "New order created successfully" 
      });
    } else {
      // UPDATE EXISTING ORDER
      const updatedPackages = [...order.letterPackages, ...childrenData];

      const oldTotal = order.total || 0;
      const newTotal = oldTotal + totalAmount;
      
      // Update North Pole Snow if added
      if (addNorthPoleSnow) {
        order.includesNorthPoleSnow = true;
        order.northPoleSnowPrice = (order.northPoleSnowPrice || 0) + northPoleSnowPrice;
      }

      order.letterPackages = updatedPackages;
      order.numberOfPackages = updatedPackages.length;
      order.total = newTotal;
      order.updatedAt = new Date().toISOString();

      // Add to activity log
      if (!order.activityLog) order.activityLog = [];
      order.activityLog.push({
        timestamp: new Date().toISOString(),
        action: "Packages Added",
        details: `Customer added ${numberOfPackages} package(s) for ${childNames}${addNorthPoleSnow ? ' + North Pole Snow' : ''}. Payment: ${totalAmount.toFixed(2)}`,
        user: "Customer",
        stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntent.id}`
      });

      // Track additional payment
      if (!order.additionalPayments) order.additionalPayments = [];
      order.additionalPayments.push({
        amount: totalAmount,
        paymentIntentId: paymentIntent.id,
        timestamp: new Date().toISOString(),
        reason: "Additional letter package",
      });

      await kv.set(`order:${orderToken}`, order);

      // Create admin alert
      const alert = {
        id: `alert-${Date.now()}`,
        type: "order_updated",
        orderId: order.orderId,
        message: `Customer added ${numberOfPackages} package(s)${addNorthPoleSnow ? ' + North Pole Snow' : ''} to unfulfilled order. Please review changes before shipping.`,
        details: {
          children: childNames,
          packagesAdded: numberOfPackages,
          includesNorthPoleSnow: addNorthPoleSnow,
          additionalAmount: totalAmount,
          newTotal: newTotal,
          totalPackages: updatedPackages.length,
        },
        status: "unread",
        priority: "high",
        createdAt: new Date().toISOString(),
      };
      await kv.set(`admin_alert:${alert.id}`, alert);

      // Send confirmation email
      try {
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        if (resendApiKey && order.customerInfo?.email) {
          const emailResponse = await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              Authorization: `Bearer ${resendApiKey}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              from: "Santa's Letters <orders@santasletters.com>",
              to: order.customerInfo.email,
              subject: `Order Updated - Added Letter Package(s)`,
              html: `
                <h2>üéÖ Order Updated Successfully!</h2>
                <p>Dear ${order.customerInfo.name},</p>
                <p>We've added ${numberOfPackages} letter package(s)${addNorthPoleSnow ? ' + Certified North Pole Snow ‚ùÑÔ∏è' : ''} to your order!</p>
                <h3>Updated Order Details:</h3>
                <ul>
                  <li><strong>Order Number:</strong> ${order.orderId.slice(-8)}</li>
                  <li><strong>Children Added:</strong> ${childNames}</li>
                  <li><strong>Packages Added:</strong> ${numberOfPackages}</li>
                  ${addNorthPoleSnow ? '<li><strong>North Pole Snow:</strong> Included ‚ùÑÔ∏è</li>' : ''}
                  <li><strong>Additional Amount:</strong> ${totalAmount.toFixed(2)}</li>
                  <li><strong>New Total:</strong> ${newTotal.toFixed(2)}</li>
                  <li><strong>Total Packages:</strong> ${updatedPackages.length}</li>
                </ul>
                <div style="background-color: #fef3c7; padding: 15px; border-radius: 5px; margin: 20px 0;">
                  <strong>‚ö†Ô∏è Important:</strong> Our team will review and confirm these changes before shipping your order.
                </div>
                <p>Thank you for adding more Christmas magic! üéÑ</p>
              `,
            }),
          });
          
          if (emailResponse.ok) {
            const emailData = await emailResponse.json();
            console.log("‚úÖ Sent packages added confirmation email. Email ID:", emailData.id);
            
            // Log email activity
            await logEmailActivity(
              order.orderId,
              'packages_added',
              order.customerInfo.email,
              'Packages Added Confirmation',
              emailData.id
            );
          }
        }
      } catch (emailError) {
        console.error("Error sending email:", emailError);
      }

      return c.json({ 
        success: true, 
        orderUpdated: true,
        orderId: order.orderId,
        message: "Order updated successfully" 
      });
    }
  } catch (error: any) {
    console.error("Error adding child:", error);
    return c.json({ error: error.message || "Failed to add child" }, 500);
  }
});

// Archive order
app.post("/make-server-cf244566/orders/:orderId/archive", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const order: any = await kv.get(`order:${orderId}`);
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    order.archived = true;
    order.updatedAt = new Date().toISOString();
    
    // Add to activity log
    if (!order.activityLog) order.activityLog = [];
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: "Order Archived",
      details: "Order moved to archived section",
      user: "Admin"
    });

    await kv.set(`order:${orderId}`, order);
    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error archiving order:", error);
    return c.json({ error: "Failed to archive order" }, 500);
  }
});

// Unarchive order
app.post("/make-server-cf244566/orders/:orderId/unarchive", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const order: any = await kv.get(`order:${orderId}`);
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    order.archived = false;
    order.updatedAt = new Date().toISOString();
    
    // Add to activity log
    if (!order.activityLog) order.activityLog = [];
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: "Order Restored",
      details: "Order restored from archived section",
      user: "Admin"
    });

    await kv.set(`order:${orderId}`, order);
    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error unarchiving order:", error);
    return c.json({ error: "Failed to unarchive order" }, 500);
  }
});

// Resend email notification
app.post("/make-server-cf244566/order/:orderId/resend-email", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const { emailType } = await c.req.json();
    
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    const resendApiKey = Deno.env.get("RESEND_API_KEY");
    if (!resendApiKey) {
      return c.json({ error: "Email service not configured" }, 503);
    }

    const customerEmail = order.customerInfo?.email;
    const customerName = order.customerInfo?.name || "Valued Customer";

    if (!customerEmail) {
      return c.json({ error: "No customer email found" }, 400);
    }

    let emailHtml = "";
    let subject = "";

    // Generate email based on type
    switch (emailType) {
      case "order_confirmation":
        subject = "üéÖ Order Confirmation - Santa's Letters";
        const packageDetails = order.letterPackages?.map((pkg: any, idx: number) => `
          <div style="background: #fef2f2; border: 2px solid #fecaca; border-radius: 8px; padding: 15px; margin: 15px 0;">
            <p><strong>üì¶ Package ${idx + 1}</strong></p>
            <p><strong>Child:</strong> ${pkg.childFirstName} ${pkg.childLastName}</p>
            <p><strong>Friend:</strong> ${pkg.friendName || 'N/A'}</p>
            <p><strong>Shipping to:</strong> ${pkg.streetAddress}${pkg.unitApt ? ', ' + pkg.unitApt : ''}, ${pkg.city}, ${pkg.state} ${pkg.zipCode}</p>
          </div>
        `).join('') || '';

        emailHtml = `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
          </head>
          <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÖ Thank You!</h1>
              </div>
              <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                <p>Hi ${customerName},</p>
                <p style="font-size: 18px; color: #059669;"><strong>‚úÖ Your order has been received!</strong></p>
                <div style="background: #dbeafe; padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #3b82f6;">
                  <p style="margin: 0;"><strong>Order #:</strong> ${orderId.slice(-8)}</p>
                  <p style="margin: 5px 0 0 0;"><strong>Total:</strong> ${order.total?.toFixed(2)}</p>
                </div>
                <h3>Your Letter Packages:</h3>
                ${packageDetails}
                <p style="margin-top: 30px;">The North Pole elves are preparing your magical letters! üéÑ</p>
                <p>Questions? Reply to this email anytime.</p>
              </div>
            </div>
          </body>
          </html>
        `;
        break;

      case "tracking_notification":
        subject = "üì¶ Your Order Has Shipped - Tracking Information";
        const trackingUrl = order.trackingNumber?.startsWith('1Z') 
          ? `https://www.ups.com/track?tracknum=${order.trackingNumber}`
          : `https://tools.usps.com/go/TrackConfirmAction?tLabels=${order.trackingNumber}`;

        emailHtml = `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
          </head>
          <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center;">
                <h1 style="font-family: 'Pacifico', cursive;">üì¶ Your Order Has Shipped!</h1>
              </div>
              <div style="background: white; padding: 30px;">
                <p>Hi ${customerName},</p>
                <p>Great news! Your magical letters from Santa are on their way! üéÖ‚ú®</p>
                <div style="background: #dbeafe; padding: 20px; border-radius: 8px; margin: 20px 0;">
                  <p><strong>Tracking Number:</strong> ${order.trackingNumber}</p>
                  <p><strong>Carrier:</strong> ${order.carrier || 'USPS'}</p>
                </div>
                <div style="text-align: center; margin: 30px 0;">
                  <a href="${trackingUrl}" style="background: #dc2626; color: white; padding: 15px 30px; text-decoration: none; border-radius: 5px; display: inline-block;">
                    Track Your Package
                  </a>
                </div>
              </div>
            </div>
          </body>
          </html>
        `;
        break;

      case "order_update":
        subject = "üìù Order Updated - Changes Confirmed";
        emailHtml = `
          <!DOCTYPE html>
          <html>
          <body style="font-family: Arial, sans-serif;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <h1>Order Updated</h1>
              <p>Hi ${customerName},</p>
              <p>Your order has been successfully updated!</p>
              <p><strong>Order #:</strong> ${orderId.slice(-8)}</p>
              <p>Thank you for your updates. Our elves are working on it! üéÖ</p>
            </div>
          </body>
          </html>
        `;
        break;

      case "subscription_payment":
        subject = "üéÖ Monthly Subscription Payment Confirmed";
        emailHtml = `
          <!DOCTYPE html>
          <html>
          <body style="font-family: Arial, sans-serif;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <h2 style="color: #dc2626;">üéÑ Ho Ho Ho!</h2>
              <p>Dear ${customerName},</p>
              <p>Your monthly Santa letter subscription payment has been processed successfully.</p>
              <p>Your magical letter will be prepared and shipped soon!</p>
              <p style="color: #059669;">Thank you for continuing this magical journey with us! üéÖ‚ú®</p>
            </div>
          </body>
          </html>
        `;
        break;

      case "payment_failed":
        subject = "‚ö†Ô∏è Santa Letter Subscription - Payment Issue";
        emailHtml = `
          <!DOCTYPE html>
          <html>
          <body style="font-family: Arial, sans-serif;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <h2 style="color: #dc2626;">Payment Issue with Your Subscription</h2>
              <p>Dear ${customerName},</p>
              <p>We encountered an issue processing your monthly Santa letter subscription payment.</p>
              <p>Please update your payment method to continue receiving your magical letters.</p>
              <p>If you have any questions, please contact us.</p>
              <p style="color: #6b7280;">üéÑ Santa's Workshop</p>
            </div>
          </body>
          </html>
        `;
        break;

      case "order_canceled":
        subject = `Order Canceled - #${orderId.slice(-8)}`;
        emailHtml = `
          <!DOCTYPE html>
          <html>
          <body style="font-family: Arial, sans-serif;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <h1>Order Canceled</h1>
              <p>Dear ${customerName},</p>
              <p>Your order <strong>#${orderId.slice(-8)}</strong> has been canceled.</p>
              <p>If you have questions, please contact support@letterfromsanta.com</p>
            </div>
          </body>
          </html>
        `;
        break;

      case "customer_edit":
        subject = `‚úèÔ∏è Order Updated - #${orderId.slice(-8)}`;
        emailHtml = `
          <!DOCTYPE html>
          <html>
          <body style="font-family: Arial, sans-serif;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <h1>‚úèÔ∏è Order Updated</h1>
              <p>Dear ${customerName},</p>
              <p>Your order <strong>#${orderId.slice(-8)}</strong> has been updated.</p>
              <div style="background-color: #fef3c7; padding: 15px; border-radius: 5px; margin: 20px 0;">
                <strong>‚ö†Ô∏è Important:</strong> Our team will review and confirm these changes before shipping your order.
              </div>
              <p>Questions? Contact support@letterfromsanta.com</p>
            </div>
          </body>
          </html>
        `;
        break;

      case "new_order_confirmation":
      case "packages_added":
        subject = "üéÖ Order Confirmed - Additional Packages";
        emailHtml = `
          <!DOCTYPE html>
          <html>
          <body style="font-family: Arial, sans-serif;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <h2>üéÖ Order Updated Successfully!</h2>
              <p>Dear ${customerName},</p>
              <p>We've added letter package(s) to your order!</p>
              <p><strong>Order #:</strong> ${orderId.slice(-8)}</p>
              <div style="background-color: #fef3c7; padding: 15px; border-radius: 5px; margin: 20px 0;">
                <strong>‚ö†Ô∏è Important:</strong> Our team will review and confirm these changes before shipping your order.
              </div>
              <p>Thank you for adding more Christmas magic! üéÑ</p>
            </div>
          </body>
          </html>
        `;
        break;

      default:
        return c.json({ error: "Invalid email type" }, 400);
    }

    // Send email via Resend
    const emailResponse = await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${resendApiKey}`,
      },
      body: JSON.stringify({
        from: EMAIL_FROM,
        to: [customerEmail],
        subject: subject,
        html: emailHtml,
      }),
    });

    if (!emailResponse.ok) {
      const errorData = await emailResponse.json();
      throw new Error(errorData.message || "Failed to send email");
    }

    const emailResult = await emailResponse.json();

    // Log the resent email to activity log
    await logEmailActivity(orderId, emailType, customerEmail, subject, emailResult.id);

    return c.json({ 
      success: true, 
      recipient: customerEmail,
      emailId: emailResult.id,
      subject: subject
    });
  } catch (error: any) {
    console.error("Error resending email:", error);
    return c.json({ error: error.message || "Failed to resend email" }, 500);
  }
});

// Delete order (admin only)
app.delete("/make-server-cf244566/orders/:orderId", async (c) => {
  try {
    const orderId = c.req.param("orderId");

    // Remove from orders index
    const allOrderIds: any = (await kv.get("orders:all")) || [];
    const updatedOrderIds = allOrderIds.filter((id: string) => id !== orderId);
    await kv.set("orders:all", updatedOrderIds);

    // Delete order
    await kv.del(`order:${orderId}`);

    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error deleting order:", error);
    return c.json({ error: "Failed to delete order" }, 500);
  }
});

// Bulk import tracking numbers
app.post("/make-server-cf244566/orders/bulk-tracking", async (c) => {
  try {
    const body = await c.req.json();
    const { updates } = body; // Array of {orderId, trackingNumber}

    for (const update of updates) {
      const allOrderIds = (await kv.get("orders:all")) || [];
      const matchingOrderId = allOrderIds.find((id: string) => id.includes(update.orderId));
      
      if (matchingOrderId) {
        const order: any = await kv.get(`order:${matchingOrderId}`);
        if (order) {
          order.trackingNumber = update.trackingNumber;
          order.status = "fulfilled";
          order.updatedAt = new Date().toISOString();
          await kv.set(`order:${matchingOrderId}`, order);
        }
      }
    }

    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error bulk importing tracking:", error);
    return c.json({ error: "Failed to bulk import tracking" }, 500);
  }
});

// ========== DECLINED ORDERS ENDPOINTS ==========

// Get all declined orders (admin only)
app.get("/make-server-cf244566/declines", async (c) => {
  try {
    // Get all decline values from the key-value store (getByPrefix returns values directly)
    const declines = (await kv.getByPrefix("decline:")) || [];

    // Sort by timestamp (newest first)
    declines.sort((a: any, b: any) => {
      const dateA = new Date(a.timestamp || 0).getTime();
      const dateB = new Date(b.timestamp || 0).getTime();
      return dateB - dateA;
    });

    console.log(`üìä Fetched ${declines.length} declined orders`);
    return c.json({ declines });
  } catch (error: any) {
    console.error("Error fetching declined orders:", error);
    return c.json({ error: "Failed to fetch declined orders", details: error.message }, 500);
  }
});

// Get single declined order by ID
app.get("/make-server-cf244566/declines/:declineId", async (c) => {
  try {
    const declineId = c.req.param("declineId");
    const decline = await kv.get(`decline:${declineId}`);

    if (!decline) {
      return c.json({ error: "Declined order not found" }, 404);
    }

    return c.json({ decline });
  } catch (error: any) {
    console.error("Error fetching declined order:", error);
    return c.json({ error: "Failed to fetch declined order" }, 500);
  }
});

// ========== AFFILIATE MANAGEMENT ENDPOINTS ==========

// Helper function to fix tracking URLs (replace any domain with production domain)
function fixTrackingUrl(url: string): string {
  if (!url) return url;
  
  // Parse the URL
  const urlParts = url.split('?');
  if (urlParts.length === 0) return url;
  
  // Replace any domain with santascertifiedletter.com/offer (funnel page)
  const params = urlParts.length > 1 ? '?' + urlParts[1] : '';
  return `https://santascertifiedletter.com/offer${params}`;
}

// Get next affiliate ID
async function getNextAffiliateId(): Promise<string> {
  const counter = (await kv.get("affiliate:id_counter")) || 9003;
  const nextId = counter + 1;
  await kv.set("affiliate:id_counter", nextId);
  return nextId.toString();
}

// Create new affiliate account
app.post("/make-server-cf244566/admin/affiliates", async (c) => {
  try {
    const body = await c.req.json();
    const { name, email, payoutType, payoutAmount } = body;

    const affiliateId = await getNextAffiliateId();

    const affiliate = {
      affiliateId,
      affiliateName: name,
      email,
      status: "active",
      defaultPayoutType: payoutType,
      defaultPayoutAmount: payoutAmount,
      password: Math.random().toString(36).substring(2, 10), // Simple random password
      createdAt: new Date().toISOString(),
    };

    // Save affiliate
    await kv.set(`affiliate:${affiliateId}`, affiliate);

    // Add to affiliates index
    const allAffiliateIds = (await kv.get("affiliates:all")) || [];
    allAffiliateIds.push(affiliateId);
    await kv.set("affiliates:all", allAffiliateIds);

    // Create default tracking link
    const defaultLink = {
      linkId: `link_${affiliateId}_default`,
      affiliateId,
      linkName: "Default Link",
      payoutType,
      payoutAmount,
      isDefault: true,
      trackingUrl: `https://santascertifiedletter.com/offer?ref=${affiliateId}`,
      createdAt: new Date().toISOString(),
    };

    await kv.set(`link:${defaultLink.linkId}`, defaultLink);

    // Add to links index
    const allLinkIds = (await kv.get("links:all")) || [];
    allLinkIds.push(defaultLink.linkId);
    await kv.set("links:all", allLinkIds);

    return c.json({ affiliate, defaultLink });
  } catch (error: any) {
    console.error("Error creating affiliate:", error);
    return c.json({ error: "Failed to create affiliate" }, 500);
  }
});

// Get all affiliates
app.get("/make-server-cf244566/admin/affiliates", async (c) => {
  try {
    const allAffiliateIds = (await kv.get("affiliates:all")) || [];
    
    const affiliates = [];
    for (const affiliateId of allAffiliateIds) {
      const affiliate = await kv.get(`affiliate:${affiliateId}`);
      if (affiliate) {
        affiliates.push(affiliate);
      }
    }

    // Get all links and fix tracking URLs automatically
    const allLinkIds = (await kv.get("links:all")) || [];
    const links = [];
    for (const linkId of allLinkIds) {
      const link: any = await kv.get(`link:${linkId}`);
      if (link) {
        // Fix tracking URL to use production domain
        const fixedUrl = fixTrackingUrl(link.trackingUrl);
        
        // If URL was changed, update it in the database
        if (fixedUrl !== link.trackingUrl) {
          link.trackingUrl = fixedUrl;
          await kv.set(`link:${linkId}`, link);
          console.log(`‚úÖ Fixed tracking URL for link ${linkId}: ${fixedUrl}`);
        }
        
        links.push(link);
      }
    }

    return c.json({ affiliates, links });
  } catch (error: any) {
    console.error("Error fetching affiliates:", error);
    return c.json({ error: "Failed to fetch affiliates" }, 500);
  }
});

// Update affiliate account
app.patch("/make-server-cf244566/admin/affiliates/:affiliateId", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    const body = await c.req.json();

    const affiliate: any = await kv.get(`affiliate:${affiliateId}`);

    if (!affiliate) {
      return c.json({ error: "Affiliate not found" }, 404);
    }

    // Update fields
    if (body.status) affiliate.status = body.status;
    if (body.defaultPayoutType) affiliate.defaultPayoutType = body.defaultPayoutType;
    if (body.defaultPayoutAmount !== undefined) affiliate.defaultPayoutAmount = body.defaultPayoutAmount;

    await kv.set(`affiliate:${affiliateId}`, affiliate);

    return c.json({ affiliate });
  } catch (error: any) {
    console.error("Error updating affiliate:", error);
    return c.json({ error: "Failed to update affiliate" }, 500);
  }
});

// Create affiliate link
app.post("/make-server-cf244566/admin/affiliates/:affiliateId/links", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    const body = await c.req.json();
    const { linkName, payoutType, payoutAmount, customPrice } = body;

    const linkId = `link_${affiliateId}_${Date.now()}`;
    const campaignParam = linkName.toLowerCase().replace(/\s+/g, "-");

    let trackingUrl = `https://santascertifiedletter.com/offer?ref=${affiliateId}`;
    if (!linkName.toLowerCase().includes("default")) {
      trackingUrl += `&campaign=${campaignParam}`;
    }
    // Note: Custom price is stored in the link settings, not in the URL

    const link = {
      linkId,
      affiliateId,
      linkName,
      payoutType,
      payoutAmount,
      customPrice,
      isDefault: false,
      trackingUrl,
      createdAt: new Date().toISOString(),
    };

    await kv.set(`link:${linkId}`, link);

    // Add to links index
    const allLinkIds = (await kv.get("links:all")) || [];
    allLinkIds.push(linkId);
    await kv.set("links:all", allLinkIds);

    return c.json({ link });
  } catch (error: any) {
    console.error("Error creating link:", error);
    return c.json({ error: "Failed to create link" }, 500);
  }
});

// Update affiliate link (payout and price adjustments)
app.patch("/make-server-cf244566/admin/affiliates/links/:linkId", async (c) => {
  try {
    const linkId = c.req.param("linkId");
    const body = await c.req.json();

    const link: any = await kv.get(`link:${linkId}`);

    if (!link) {
      return c.json({ error: "Link not found" }, 404);
    }

    // Update fields
    if (body.payoutType) link.payoutType = body.payoutType;
    if (body.payoutAmount !== undefined) link.payoutAmount = body.payoutAmount;
    if (body.customPrice !== undefined) {
      link.customPrice = body.customPrice;
      
      // Update tracking URL with new price
      const baseUrl = link.trackingUrl.split('?')[0];
      const params = new URLSearchParams(link.trackingUrl.split('?')[1]);
      
      if (body.customPrice) {
        params.set('price', body.customPrice.toString());
      } else {
        params.delete('price');
      }
      
      link.trackingUrl = `${baseUrl}?${params.toString()}`;
    }

    await kv.set(`link:${linkId}`, link);

    return c.json({ link });
  } catch (error: any) {
    console.error("Error updating link:", error);
    return c.json({ error: "Failed to update link" }, 500);
  }
});

// Delete affiliate link
app.delete("/make-server-cf244566/admin/affiliates/links/:linkId", async (c) => {
  try {
    const linkId = c.req.param("linkId");

    // Remove from links index
    const allLinkIds: any = (await kv.get("links:all")) || [];
    const updatedLinkIds = allLinkIds.filter((id: string) => id !== linkId);
    await kv.set("links:all", updatedLinkIds);

    // Delete link
    await kv.del(`link:${linkId}`);

    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error deleting link:", error);
    return c.json({ error: "Failed to delete link" }, 500);
  }
});

// Get custom price for affiliate link (used by checkout page)
app.get("/make-server-cf244566/affiliate/link-price", async (c) => {
  try {
    const ref = c.req.query("ref"); // affiliate ID
    const campaign = c.req.query("campaign"); // optional campaign parameter
    
    if (!ref) {
      return c.json({ customPrice: null });
    }
    
    // Get all links for this affiliate
    const allLinkIds = (await kv.get("links:all")) || [];
    
    // Find the matching link
    for (const linkId of allLinkIds) {
      const link: any = await kv.get(`link:${linkId}`);
      
      if (link && link.affiliateId === ref) {
        // If campaign is specified, match it
        if (campaign) {
          const linkCampaign = link.linkName.toLowerCase().replace(/\s+/g, "-");
          if (linkCampaign === campaign.toLowerCase()) {
            return c.json({ 
              customPrice: link.customPrice || null,
              payoutType: link.payoutType,
              payoutAmount: link.payoutAmount
            });
          }
        } else if (link.isDefault) {
          // Return default link if no campaign specified
          return c.json({ 
            customPrice: link.customPrice || null,
            payoutType: link.payoutType,
            payoutAmount: link.payoutAmount
          });
        }
      }
    }
    
    // No matching link found, return null
    return c.json({ customPrice: null });
  } catch (error: any) {
    console.error("Error getting link price:", error);
    return c.json({ customPrice: null });
  }
});

// Affiliate login
app.post("/make-server-cf244566/affiliate/login", async (c) => {
  try {
    const body = await c.req.json();
    const { affiliateId, password } = body;

    const affiliate: any = await kv.get(`affiliate:${affiliateId}`);

    if (!affiliate || affiliate.password !== password) {
      return c.json({ error: "Invalid credentials" }, 401);
    }

    return c.json({
      affiliateId: affiliate.affiliateId,
      affiliateName: affiliate.affiliateName,
      email: affiliate.email,
    });
  } catch (error: any) {
    console.error("Error during login:", error);
    return c.json({ error: "Login failed" }, 500);
  }
});

// Get affiliate links (for affiliate dashboard)
app.get("/make-server-cf244566/affiliate/:affiliateId/links", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    const allLinkIds = (await kv.get("links:all")) || [];
    
    const links = [];
    for (const linkId of allLinkIds) {
      const link: any = await kv.get(`link:${linkId}`);
      if (link && link.affiliateId === affiliateId) {
        links.push(link);
      }
    }

    return c.json({ links });
  } catch (error: any) {
    console.error("Error fetching affiliate links:", error);
    return c.json({ error: "Failed to fetch links" }, 500);
  }
});

// Track affiliate event (page view, form fill, etc.)
app.post("/make-server-cf244566/affiliate/track-event", async (c) => {
  try {
    const body = await c.req.json();
    const { affiliateId, eventType, subIds } = body;
    // eventType: "page_view", "form_fill", "add_package", "payment_submit", "sale"

    const eventId = `event_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    const event = {
      eventId,
      affiliateId,
      eventType,
      subIds: subIds || {},
      timestamp: new Date().toISOString(),
    };

    await kv.set(`event:${eventId}`, event);

    // Add to events index
    const allEventIds = (await kv.get("events:all")) || [];
    allEventIds.push(eventId);
    await kv.set("events:all", allEventIds);

    // Fire postbacks if configured
    const postbacks = (await kv.get(`postbacks:${affiliateId}`)) || [];
    for (const postback of postbacks) {
      if (postback.enabledEvents.includes(eventType)) {
        // Fire postback
        try {
          // Skip if postback URL is empty or invalid
          if (!postback.postbackUrl || postback.postbackUrl.trim() === '') {
            console.log(`Skipping postback for ${affiliateId} - empty URL`);
            continue;
          }

          let url = postback.postbackUrl
            .replace('{affiliate_id}', affiliateId)
            .replace('{event_type}', eventType)
            .replace('{timestamp}', event.timestamp);

          // Add sub IDs to URL
          Object.entries(subIds || {}).forEach(([key, value]) => {
            url = url.replace(`{${key}}`, value as string);
          });

          const response = await fetch(url);
          
          // Log postback result
          const postbackLog = {
            postbackId: `pb_${Date.now()}`,
            affiliateId,
            eventId,
            eventType,
            url,
            status: response.ok ? "success" : "failed",
            statusCode: response.status,
            timestamp: new Date().toISOString(),
          };

          await kv.set(`postback_log:${postbackLog.postbackId}`, postbackLog);

          // Add to postback logs index
          const allPostbackLogs = (await kv.get("postback_logs:all")) || [];
          allPostbackLogs.push(postbackLog.postbackId);
          await kv.set("postback_logs:all", allPostbackLogs);
        } catch (err) {
          console.error("Error firing postback:", err);
          
          // Log failed postback
          const postbackLog = {
            postbackId: `pb_${Date.now()}`,
            affiliateId,
            eventId,
            eventType,
            url: postback.postbackUrl,
            status: "failed",
            error: err.message,
            timestamp: new Date().toISOString(),
          };

          await kv.set(`postback_log:${postbackLog.postbackId}`, postbackLog);

          const allPostbackLogs = (await kv.get("postback_logs:all")) || [];
          allPostbackLogs.push(postbackLog.postbackId);
          await kv.set("postback_logs:all", allPostbackLogs);
        }
      }
    }

    return c.json({ success: true, eventId });
  } catch (error: any) {
    console.error("Error tracking event:", error);
    return c.json({ error: "Failed to track event" }, 500);
  }
});

// Save postback settings for affiliate
app.post("/make-server-cf244566/admin/affiliates/:affiliateId/postbacks", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    const body = await c.req.json();
    const { postbackUrl, pixelCode, enabledEvents } = body;

    const postback = {
      postbackUrl,
      pixelCode,
      enabledEvents,
      updatedAt: new Date().toISOString(),
    };

    await kv.set(`postbacks:${affiliateId}`, [postback]);

    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error saving postbacks:", error);
    return c.json({ error: "Failed to save postbacks" }, 500);
  }
});

// Get postback settings for affiliate
app.get("/make-server-cf244566/admin/affiliates/:affiliateId/postbacks", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    const postbacks = (await kv.get(`postbacks:${affiliateId}`)) || [];

    return c.json({ postbacks: postbacks[0] || { postbackUrl: "", pixelCode: "", enabledEvents: [] } });
  } catch (error: any) {
    console.error("Error fetching postbacks:", error);
    return c.json({ error: "Failed to fetch postbacks" }, 500);
  }
});

// Get postback logs for affiliate
app.get("/make-server-cf244566/affiliate/:affiliateId/postback-logs", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    const allPostbackLogs = (await kv.get("postback_logs:all")) || [];
    
    const logs = [];
    for (const logId of allPostbackLogs) {
      const log: any = await kv.get(`postback_log:${logId}`);
      if (log && log.affiliateId === affiliateId) {
        logs.push(log);
      }
    }

    // Sort by timestamp (newest first)
    logs.sort((a: any, b: any) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());

    return c.json({ logs });
  } catch (error: any) {
    console.error("Error fetching postback logs:", error);
    return c.json({ error: "Failed to fetch postback logs" }, 500);
  }
});

// Get affiliate stats (orders, revenue, events)
app.get("/make-server-cf244566/affiliate/:affiliateId/stats", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    
    // Get all orders
    const allOrderIds = (await kv.get("orders:all")) || [];
    const affiliateOrders = [];
    
    for (const orderId of allOrderIds) {
      const order: any = await kv.get(`order:${orderId}`);
      if (order && order.affiliateId === affiliateId) {
        affiliateOrders.push(order);
      }
    }

    // Get all events
    const allEventIds = (await kv.get("events:all")) || [];
    const affiliateEvents = [];
    
    for (const eventId of allEventIds) {
      const event: any = await kv.get(`event:${eventId}`);
      if (event && event.affiliateId === affiliateId) {
        affiliateEvents.push(event);
      }
    }

    // Calculate stats
    const pageViews = affiliateEvents.filter((e: any) => e.eventType === "page_view").length;
    const formFills = affiliateEvents.filter((e: any) => e.eventType === "form_fill").length;
    const addPackageClicks = affiliateEvents.filter((e: any) => e.eventType === "add_package").length;
    const paymentSubmits = affiliateEvents.filter((e: any) => e.eventType === "payment_submit").length;
    
    const totalOrders = affiliateOrders.length;
    const totalRevenue = affiliateOrders.reduce((sum: number, order: any) => sum + order.total, 0);
    const totalCommission = affiliateOrders.reduce((sum: number, order: any) => sum + (order.affiliateCommission || 0), 0);

    return c.json({
      pageViews,
      formFills,
      addPackageClicks,
      paymentSubmits,
      sales: totalOrders,
      totalRevenue,
      totalCommission,
      orders: affiliateOrders,
    });
  } catch (error: any) {
    console.error("Error fetching affiliate stats:", error);
    return c.json({ error: "Failed to fetch stats" }, 500);
  }
});

// Export orders as CSV
app.get("/make-server-cf244566/orders/export/csv", async (c) => {
  try {
    const allOrderIds = (await kv.get("orders:all")) || [];
    
    // Fetch all orders
    const orders = [];
    for (const orderId of allOrderIds) {
      const order = await kv.get(`order:${orderId}`);
      if (order) {
        orders.push(order);
      }
    }

    // Sort by date (newest first)
    orders.sort((a: any, b: any) => new Date(b.orderDate).getTime() - new Date(a.orderDate).getTime());

    // Create CSV
    let csv = "Order ID,Order Date,Status,Customer Name,Customer Email,Customer Phone,Address,City,State,ZIP,Number of Packages,Letter Recipients,Shipping Date,Subscription,Total\n";

    for (const order of orders) {
      const recipients = order.letterPackages.map((pkg: any) => 
        `${pkg.childFirstName} ${pkg.childLastName}`
      ).join("; ");

      const address = `${order.customerInfo.address.line1} ${order.customerInfo.address.line2 || ""}`.trim();

      csv += `"${order.orderId}","${new Date(order.orderDate).toLocaleDateString()}","${order.status}","${order.customerInfo.name}","${order.customerInfo.email}","${order.customerInfo.phone}","${address}","${order.customerInfo.address.city}","${order.customerInfo.address.state}","${order.customerInfo.address.postal_code}","${order.numberOfPackages}","${recipients}","${order.shippingDate}","${order.monthlySubscription ? "Yes" : "No"}","${order.total.toFixed(2)}"\n`;
    }

    return new Response(csv, {
      headers: {
        "Content-Type": "text/csv",
        "Content-Disposition": "attachment; filename=santa-letters-orders.csv",
      },
    });
  } catch (error: any) {
    console.error("Error exporting orders:", error);
    return c.json({ error: "Failed to export orders" }, 500);
  }
});

// Add postback configuration for affiliate
app.post("/make-server-cf244566/affiliate/postback-configs", async (c) => {
  try {
    const body = await c.req.json();
    const { affiliateId, eventType, url } = body;

    if (!affiliateId || !eventType || !url) {
      return c.json({ error: "Missing required fields" }, 400);
    }

    const configId = `pbcfg_${Date.now()}`;
    const config = {
      id: configId,
      affiliateId,
      eventType,
      url,
      enabled: true,
      createdAt: new Date().toISOString(),
    };

    await kv.set(`postback_config:${configId}`, config);

    // Add to configs index
    const allConfigIds = (await kv.get("postback_configs:all")) || [];
    allConfigIds.push(configId);
    await kv.set("postback_configs:all", allConfigIds);

    return c.json({ config });
  } catch (error: any) {
    console.error("Error adding postback config:", error);
    return c.json({ error: "Failed to add postback config" }, 500);
  }
});

// Update postback configuration
app.patch("/make-server-cf244566/affiliate/postback-configs/:configId", async (c) => {
  try {
    const configId = c.req.param("configId");
    const body = await c.req.json();

    const config: any = await kv.get(`postback_config:${configId}`);
    if (!config) {
      return c.json({ error: "Config not found" }, 404);
    }

    // Update only the enabled field
    if (body.hasOwnProperty("enabled")) {
      config.enabled = body.enabled;
    }

    await kv.set(`postback_config:${configId}`, config);
    return c.json({ config });
  } catch (error: any) {
    console.error("Error updating postback config:", error);
    return c.json({ error: "Failed to update postback config" }, 500);
  }
});

// Delete postback configuration
app.delete("/make-server-cf244566/affiliate/postback-configs/:configId", async (c) => {
  try {
    const configId = c.req.param("configId");

    await kv.del(`postback_config:${configId}`);

    // Remove from configs index
    const allConfigIds = (await kv.get("postback_configs:all")) || [];
    const updatedConfigIds = allConfigIds.filter((id: string) => id !== configId);
    await kv.set("postback_configs:all", updatedConfigIds);

    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error deleting postback config:", error);
    return c.json({ error: "Failed to delete postback config" }, 500);
  }
});

// Get all postback configs for an affiliate
app.get("/make-server-cf244566/affiliate/postback-configs/:affiliateId", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    const allConfigIds = (await kv.get("postback_configs:all")) || [];
    
    const configs = [];
    for (const configId of allConfigIds) {
      const config: any = await kv.get(`postback_config:${configId}`);
      if (config && config.affiliateId === affiliateId) {
        configs.push(config);
      }
    }

    return c.json({ configs });
  } catch (error: any) {
    console.error("Error fetching postback configs:", error);
    return c.json({ error: "Failed to fetch postback configs" }, 500);
  }
});

// Get affiliate dashboard data
app.get("/make-server-cf244566/affiliate/dashboard", async (c) => {
  try {
    const range = c.req.query("range") || "7days";
    // For now, return empty data - in production, this would fetch real stats
    // This endpoint can be expanded later with real tracking data
    
    return c.json({
      affiliate: {
        affiliateId: "aff_unknown",
        affiliateName: "Affiliate",
        email: "affiliate@example.com",
        trackingUrl: "https://santascertifiedletter.com/?ref=aff_unknown",
        postbackUrl: "",
        pixelCode: "",
        commissionRate: 20,
        status: "active",
        createdAt: new Date().toISOString(),
      },
      stats: {
        totalClicks: 0,
        totalConversions: 0,
        totalRevenue: 0,
        conversionRate: 0,
        commission: 0,
      },
      dailyReports: [],
      hourlyReports: [],
      subIDReports: [],
      eventStats: [],
      invoices: [],
      openBalance: 0,
      prepaidCredit: 0,
      postbackConfigs: [],
    });
  } catch (error: any) {
    console.error("Error fetching dashboard data:", error);
    return c.json({ error: "Failed to fetch dashboard data" }, 500);
  }
});

// Create invoice for affiliate
app.post("/make-server-cf244566/affiliate/invoices", async (c) => {
  try {
    const body = await c.req.json();
    const { affiliateId, periodStart, periodEnd, totalCommission, status, dueDate } = body;

    if (!affiliateId || !periodStart || !periodEnd || totalCommission === undefined) {
      return c.json({ error: "Missing required fields" }, 400);
    }

    const invoiceId = `inv_${Date.now()}`;
    const invoiceNumber = `INV-${new Date().getFullYear()}-${String(Math.floor(Math.random() * 10000)).padStart(4, '0')}`;
    
    const invoice = {
      invoiceId,
      invoiceNumber,
      affiliateId,
      periodStart,
      periodEnd,
      totalCommission,
      amountPaid: 0,
      amountOwed: totalCommission,
      status: status || "pending",
      dueDate: dueDate || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),
      createdAt: new Date().toISOString(),
    };

    await kv.set(`invoice:${invoiceId}`, invoice);

    // Add to invoices index for this affiliate
    const affiliateInvoiceIds = (await kv.get(`affiliate_invoices:${affiliateId}`)) || [];
    affiliateInvoiceIds.push(invoiceId);
    await kv.set(`affiliate_invoices:${affiliateId}`, affiliateInvoiceIds);

    return c.json({ invoice });
  } catch (error: any) {
    console.error("Error creating invoice:", error);
    return c.json({ error: "Failed to create invoice" }, 500);
  }
});

// Update invoice payment status
app.patch("/make-server-cf244566/affiliate/invoices/:invoiceId", async (c) => {
  try {
    const invoiceId = c.req.param("invoiceId");
    const body = await c.req.json();

    const invoice: any = await kv.get(`invoice:${invoiceId}`);
    if (!invoice) {
      return c.json({ error: "Invoice not found" }, 404);
    }

    // Update payment fields
    if (body.amountPaid !== undefined) {
      const overpayment = Math.max(0, body.amountPaid - invoice.totalCommission);
      
      invoice.amountPaid = body.amountPaid;
      invoice.amountOwed = Math.max(0, invoice.totalCommission - body.amountPaid);
      
      // Update status based on payment
      if (invoice.amountOwed === 0) {
        invoice.status = "paid";
        invoice.paidDate = new Date().toISOString();
      } else if (invoice.amountPaid > 0) {
        invoice.status = "partial";
      }

      // Handle overpayment as prepaid credit
      if (overpayment > 0) {
        const affiliateId = invoice.affiliateId;
        const currentCredit = (await kv.get(`prepaid_credit:${affiliateId}`)) || 0;
        await kv.set(`prepaid_credit:${affiliateId}`, currentCredit + overpayment);
      }
    }

    await kv.set(`invoice:${invoiceId}`, invoice);
    return c.json({ invoice });
  } catch (error: any) {
    console.error("Error updating invoice:", error);
    return c.json({ error: "Failed to update invoice" }, 500);
  }
});

// Get invoices for affiliate
app.get("/make-server-cf244566/affiliate/invoices/:affiliateId", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    const invoiceIds = (await kv.get(`affiliate_invoices:${affiliateId}`)) || [];
    
    const invoices = [];
    for (const invoiceId of invoiceIds) {
      const invoice: any = await kv.get(`invoice:${invoiceId}`);
      if (invoice) {
        invoices.push(invoice);
      }
    }

    const openBalance = invoices.reduce((sum, inv) => sum + inv.amountOwed, 0);
    const prepaidCredit = (await kv.get(`prepaid_credit:${affiliateId}`)) || 0;

    return c.json({ invoices, openBalance, prepaidCredit });
  } catch (error: any) {
    console.error("Error fetching invoices:", error);
    return c.json({ error: "Failed to fetch invoices" }, 500);
  }
});

// Delete invoice
app.delete("/make-server-cf244566/affiliate/invoices/:invoiceId", async (c) => {
  try {
    const invoiceId = c.req.param("invoiceId");
    
    const invoice: any = await kv.get(`invoice:${invoiceId}`);
    if (!invoice) {
      return c.json({ error: "Invoice not found" }, 404);
    }

    const affiliateId = invoice.affiliateId;

    // Remove from invoice index
    const affiliateInvoiceIds = (await kv.get(`affiliate_invoices:${affiliateId}`)) || [];
    const updatedInvoiceIds = affiliateInvoiceIds.filter((id: string) => id !== invoiceId);
    await kv.set(`affiliate_invoices:${affiliateId}`, updatedInvoiceIds);

    // Delete the invoice
    await kv.del(`invoice:${invoiceId}`);

    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error deleting invoice:", error);
    return c.json({ error: "Failed to delete invoice" }, 500);
  }
});

// Send Email Notification
app.post("/make-server-cf244566/send-email", async (c) => {
  try {
    const body = await c.req.json();
    const { to, subject, html } = body;

    if (!to || !subject || !html) {
      return c.json({ error: "Missing required fields: to, subject, html" }, 400);
    }

    // Send email using Resend
    const { data, error } = await resend.emails.send({
      from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
      to: [to],
      subject: subject,
      html: html,
    });

    if (error) {
      console.error("Error sending email with Resend:", error);
      return c.json({ error: "Failed to send email", details: error }, 500);
    }

    console.log("Email sent successfully:", data);
    return c.json({ success: true, emailId: data?.id });
  } catch (error: any) {
    console.error("Error in send-email endpoint:", error);
    return c.json({ error: "Failed to send email", details: error.message }, 500);
  }
});

// Send SMS Notification
app.post("/make-server-cf244566/send-sms", async (c) => {
  try {
    const body = await c.req.json();
    const { to, message } = body;

    if (!to || !message) {
      return c.json({ error: "Missing required fields: to, message" }, 400);
    }

    // Twilio credentials
    const accountSid = Deno.env.get("TWILIO_ACCOUNT_SID");
    const authToken = Deno.env.get("TWILIO_AUTH_TOKEN");
    const fromNumber = Deno.env.get("TWILIO_PHONE_NUMBER");

    if (!accountSid || !authToken || !fromNumber) {
      console.error("Twilio credentials not configured");
      return c.json({ error: "SMS service not configured" }, 500);
    }

    // Send SMS using Twilio
    const twilioUrl = `https://api.twilio.com/2010-04-01/Accounts/${accountSid}/Messages.json`;
    const credentials = btoa(`${accountSid}:${authToken}`);

    const formData = new URLSearchParams();
    formData.append("To", to);
    formData.append("From", fromNumber);
    formData.append("Body", message);

    const response = await fetch(twilioUrl, {
      method: "POST",
      headers: {
        Authorization: `Basic ${credentials}`,
        "Content-Type": "application/x-www-form-urlencoded",
      },
      body: formData.toString(),
    });

    if (!response.ok) {
      const errorData = await response.json();
      console.error("Error sending SMS with Twilio:", errorData);
      return c.json({ error: "Failed to send SMS", details: errorData }, 500);
    }

    const data = await response.json();
    console.log("SMS sent successfully:", data);
    return c.json({ success: true, messageSid: data.sid });
  } catch (error: any) {
    console.error("Error in send-sms endpoint:", error);
    return c.json({ error: "Failed to send SMS", details: error.message }, 500);
  }
});

// Send Email Notification
app.post("/make-server-cf244566/send-email", async (c) => {
  try {
    const body = await c.req.json();
    const { to, subject, html } = body;

    if (!to || !subject || !html) {
      return c.json({ error: "Missing required fields: to, subject, html" }, 400);
    }

    const resendApiKey = Deno.env.get("RESEND_API_KEY");
    if (!resendApiKey) {
      console.error("RESEND_API_KEY not configured");
      return c.json({ error: "Email service not configured" }, 500);
    }

    // Send email using Resend API
    const response = await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${resendApiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
        to: [to],
        subject: subject,
        html: html,
      }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      console.error("Error sending email with Resend:", errorData);
      return c.json({ error: "Failed to send email", details: errorData }, 500);
    }

    const data = await response.json();
    console.log("Email sent successfully:", data);
    return c.json({ success: true, emailId: data.id });
  } catch (error: any) {
    console.error("Error in send-email endpoint:", error);
    return c.json({ error: "Failed to send email", details: error.message }, 500);
  }
});

// Send SMS Notification
app.post("/make-server-cf244566/send-sms", async (c) => {
  try {
    const body = await c.req.json();
    const { to, message } = body;

    if (!to || !message) {
      return c.json({ error: "Missing required fields: to, message" }, 400);
    }

    // Twilio credentials
    const accountSid = Deno.env.get("TWILIO_ACCOUNT_SID");
    const authToken = Deno.env.get("TWILIO_AUTH_TOKEN");
    const fromNumber = Deno.env.get("TWILIO_PHONE_NUMBER");

    if (!accountSid || !authToken || !fromNumber) {
      console.error("Twilio credentials not configured");
      return c.json({ error: "SMS service not configured" }, 500);
    }

    // Send SMS using Twilio
    const twilioUrl = `https://api.twilio.com/2010-04-01/Accounts/${accountSid}/Messages.json`;
    const credentials = btoa(`${accountSid}:${authToken}`);

    const formData = new URLSearchParams();
    formData.append("To", to);
    formData.append("From", fromNumber);
    formData.append("Body", message);

    const response = await fetch(twilioUrl, {
      method: "POST",
      headers: {
        Authorization: `Basic ${credentials}`,
        "Content-Type": "application/x-www-form-urlencoded",
      },
      body: formData.toString(),
    });

    if (!response.ok) {
      const errorData = await response.json();
      console.error("Error sending SMS with Twilio:", errorData);
      return c.json({ error: "Failed to send SMS", details: errorData }, 500);
    }

    const data = await response.json();
    console.log("SMS sent successfully:", data);
    return c.json({ success: true, messageSid: data.sid });
  } catch (error: any) {
    console.error("Error in send-sms endpoint:", error);
    return c.json({ error: "Failed to send SMS", details: error.message }, 500);
  }
});

// ========== ADMIN AFFILIATE REPORTING ENDPOINT ==========
app.get("/make-server-cf244566/admin/affiliate-reports", async (c) => {
  try {
    const dateRange = c.req.query("dateRange") || "7days";
    const affiliateId = c.req.query("affiliateId");

    // Helper function to convert UTC date to EST date string
    const toESTDateString = (date: Date): string => {
      return date.toLocaleString("en-US", {
        timeZone: "America/New_York",
        year: "numeric",
        month: "2-digit",
        day: "2-digit"
      }).split(',')[0].split('/').map((p: string) => p.padStart(2, '0')).reverse().join('-');
    };

    // Helper function to get EST hour (0-23)
    const getESTHour = (date: Date): number => {
      const estTime = date.toLocaleString("en-US", {
        timeZone: "America/New_York",
        hour: "2-digit",
        hour12: false
      });
      return parseInt(estTime.split(':')[0]);
    };

    // Get current time in EST
    const nowEST = new Date(new Date().toLocaleString("en-US", { timeZone: "America/New_York" }));
    let startDate: Date;
    
    switch (dateRange) {
      case "today":
        // Start of today in EST
        const todayEST = new Date(nowEST.getFullYear(), nowEST.getMonth(), nowEST.getDate());
        startDate = new Date(todayEST.toLocaleString("en-US", { timeZone: "UTC" }));
        break;
      case "yesterday":
        // Start of yesterday in EST
        const yesterdayEST = new Date(nowEST.getFullYear(), nowEST.getMonth(), nowEST.getDate() - 1);
        startDate = new Date(yesterdayEST.toLocaleString("en-US", { timeZone: "UTC" }));
        const endYesterday = new Date(nowEST.getFullYear(), nowEST.getMonth(), nowEST.getDate() - 1, 23, 59, 59, 999);
        nowEST.setTime(endYesterday.getTime());
        break;
      case "7days":
        startDate = new Date(nowEST.getTime() - 7 * 24 * 60 * 60 * 1000);
        break;
      case "30days":
        startDate = new Date(nowEST.getTime() - 30 * 24 * 60 * 60 * 1000);
        break;
      case "thismonth":
        // First day of current month in EST
        const thisMonthEST = new Date(nowEST.getFullYear(), nowEST.getMonth(), 1);
        startDate = new Date(thisMonthEST.toLocaleString("en-US", { timeZone: "UTC" }));
        break;
      case "lastmonth":
        // First day of last month in EST
        const lastMonthEST = new Date(nowEST.getFullYear(), nowEST.getMonth() - 1, 1);
        startDate = new Date(lastMonthEST.toLocaleString("en-US", { timeZone: "UTC" }));
        // Last day of last month
        const endLastMonth = new Date(nowEST.getFullYear(), nowEST.getMonth(), 0, 23, 59, 59, 999);
        nowEST.setTime(endLastMonth.getTime());
        break;
      default:
        startDate = new Date(nowEST.getTime() - 7 * 24 * 60 * 60 * 1000);
    }

    // Get all orders
    const allOrderIds = (await kv.get("orders:all")) || [];
    const orders = [];
    
    for (const orderId of allOrderIds) {
      const order: any = await kv.get(`order:${orderId}`);
      if (order) {
        const orderDate = new Date(order.orderDate);
        
        // Filter by date range
        if (orderDate >= startDate && orderDate <= nowEST) {
          // Filter by affiliate if specified
          if (!affiliateId || affiliateId === "all" || order.affiliateId === affiliateId) {
            orders.push(order);
          }
        }
      }
    }

    // Get chargebacks
    const allChargebacks = (await kv.get("chargebacks:all")) || [];
    const chargebacks = [];
    
    for (const chargebackId of allChargebacks) {
      const chargeback: any = await kv.get(`chargeback:${chargebackId}`);
      if (chargeback) {
        const cbDate = new Date(chargeback.chargebackDate);
        
        if (cbDate >= startDate && cbDate <= nowEST) {
          if (!affiliateId || affiliateId === "all" || chargeback.affiliateId === affiliateId) {
            chargebacks.push(chargeback);
          }
        }
      }
    }

    // Group data by date and hour (using EST)
    const dailyReportsMap: Record<string, any> = {};
    const hourlyReportsMap: Record<string, any> = {};
    
    // Get clicks from events
    const allEventIds = (await kv.get("events:all")) || [];
    
    for (const eventId of allEventIds) {
      const event: any = await kv.get(`event:${eventId}`);
      if (event) {
        const eventDate = new Date(event.timestamp);
        
        if (eventDate >= startDate && eventDate <= nowEST) {
          if (!affiliateId || affiliateId === "all" || event.affiliateId === affiliateId) {
            // Daily grouping (EST date string)
            const dateKey = toESTDateString(eventDate);
            
            if (!dailyReportsMap[dateKey]) {
              dailyReportsMap[dateKey] = {
                date: dateKey,
                clicks: 0,
                conversions: 0,
                revenue: 0,
                commission: 0,
                refunds: 0,
                chargebacks: 0,
                declines: 0,
              };
            }
            
            if (event.eventType === "page_view") {
              dailyReportsMap[dateKey].clicks++;
            }
            
            // Hourly grouping (EST - only for today)
            if (dateRange === "today") {
              const estHour = getESTHour(eventDate);
              const hourKey = `${estHour}:00`;
              
              if (!hourlyReportsMap[hourKey]) {
                hourlyReportsMap[hourKey] = {
                  hour: hourKey,
                  clicks: 0,
                  conversions: 0,
                  revenue: 0,
                  commission: 0,
                };
              }
              
              if (event.eventType === "page_view") {
                hourlyReportsMap[hourKey].clicks++;
              }
            }
          }
        }
      }
    }

    // Add order data to reports
    let totalRevenue = 0;
    let totalCommission = 0;
    let totalRefunds = 0;
    let totalChargebacks = 0;
    let totalDeclines = 0;

    const orderDetails = [];

    for (const order of orders) {
      const orderDate = new Date(order.orderDate);
      const dateKey = toESTDateString(orderDate);
      
      if (!dailyReportsMap[dateKey]) {
        dailyReportsMap[dateKey] = {
          date: dateKey,
          clicks: 0,
          conversions: 0,
          revenue: 0,
          commission: 0,
          refunds: 0,
          chargebacks: 0,
          declines: 0,
        };
      }

      const isRefunded = order.status === "refunded" || order.status === "canceled-refunded";
      const isChargeback = order.status === "chargeback";
      
      if (!isRefunded && !isChargeback) {
        dailyReportsMap[dateKey].conversions++;
        dailyReportsMap[dateKey].revenue += order.total || 0;
        dailyReportsMap[dateKey].commission += order.affiliateCommission || 0;
        
        totalRevenue += order.total || 0;
        totalCommission += order.affiliateCommission || 0;
      } else if (isRefunded) {
        dailyReportsMap[dateKey].refunds += order.total || 0;
        totalRefunds += order.total || 0;
      } else if (isChargeback) {
        dailyReportsMap[dateKey].chargebacks += order.total || 0;
        totalChargebacks += order.total || 0;
      }

      // Add to hourly if today
      if (dateRange === "today") {
        const estHour = getESTHour(orderDate);
        const hourKey = `${estHour}:00`;
        
        if (!hourlyReportsMap[hourKey]) {
          hourlyReportsMap[hourKey] = {
            hour: hourKey,
            clicks: 0,
            conversions: 0,
            revenue: 0,
            commission: 0,
          };
        }

        if (!isRefunded && !isChargeback) {
          hourlyReportsMap[hourKey].conversions++;
          hourlyReportsMap[hourKey].revenue += order.total || 0;
          hourlyReportsMap[hourKey].commission += order.affiliateCommission || 0;
        }
      }

      // Add to order details
      orderDetails.push({
        orderId: order.orderId,
        sessionId: order.orderId,
        affiliateId: order.affiliateId || "direct",
        affiliateName: order.affiliateName || "Direct Sale",
        customerEmail: order.customerInfo?.email || "",
        packageCount: order.numberOfPackages || 0,
        total: order.total || 0,
        commission: order.affiliateCommission || 0,
        status: isChargeback ? "chargeback" : isRefunded ? "refunded" : "completed",
        orderDate: order.orderDate,
        subIds: order.subIds || {},
      });
    }

    // Convert maps to arrays and sort
    const dailyReports = Object.values(dailyReportsMap).sort((a: any, b: any) => 
      new Date(b.date).getTime() - new Date(a.date).getTime()
    );
    
    const hourlyReports = Object.values(hourlyReportsMap).sort((a: any, b: any) => {
      const aHour = parseInt(a.hour.split(':')[0]);
      const bHour = parseInt(b.hour.split(':')[0]);
      return aHour - bHour;
    });

    // Calculate net revenue
    const netRevenue = totalRevenue - totalRefunds - totalChargebacks;

    return c.json({
      dailyReports,
      hourlyReports,
      orders: orderDetails,
      chargebacks: chargebacks.map((cb: any) => ({
        chargebackId: cb.chargebackId,
        orderId: cb.orderId,
        sessionId: cb.sessionId,
        affiliateId: cb.affiliateId,
        affiliateName: cb.affiliateName,
        amount: cb.amount,
        commission: cb.commission,
        reason: cb.reason,
        stripeChargeId: cb.stripeChargeId,
        chargebackDate: cb.chargebackDate,
        orderDate: cb.orderDate,
        status: cb.status,
      })),
      totalStats: {
        totalRevenue,
        totalCommission,
        totalRefunds,
        totalChargebacks,
        totalDeclines,
        netRevenue,
      },
    });
  } catch (error: any) {
    console.error("Error fetching affiliate reports:", error);
    return c.json({ error: "Failed to fetch reports" }, 500);
  }
});

// Update customer information
app.patch("/make-server-cf244566/orders/:orderId/customer-info", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const { customerInfo } = await c.req.json();

    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    // Update customer info
    order.customerInfo = customerInfo;
    order.updatedAt = new Date().toISOString();
    await kv.set(`order:${orderId}`, order);

    // Send notification email and SMS
    await sendCustomerInfoUpdateNotification(order);

    return c.json({ success: true, order });
  } catch (error: any) {
    console.error("Error updating customer info:", error);
    return c.json({ error: "Failed to update customer information" }, 500);
  }
});

// Cancel subscription
app.post("/make-server-cf244566/subscriptions/:subscriptionId/cancel", async (c) => {
  try {
    if (!stripe) {
      return c.json({ error: "Stripe not configured" }, 503);
    }

    const subscriptionId = c.req.param("subscriptionId");
    const { orderId } = await c.req.json();

    // Cancel in Stripe
    const subscription = await stripe.subscriptions.cancel(subscriptionId);

    // Update order status
    const order: any = await kv.get(`order:${orderId}`);
    if (order) {
      order.status = "canceled-refunded";
      order.updatedAt = new Date().toISOString();
      await kv.set(`order:${orderId}`, order);

      // Send cancellation notification
      await sendSubscriptionCanceledNotification(order);
    }

    return c.json({ success: true, subscription });
  } catch (error: any) {
    console.error("Error canceling subscription:", error);
    return c.json({ error: error.message || "Failed to cancel subscription" }, 500);
  }
});

// Process refund
app.post("/make-server-cf244566/orders/:orderId/refund", async (c) => {
  try {
    if (!stripe) {
      return c.json({ error: "Stripe not configured" }, 503);
    }

    const orderId = c.req.param("orderId");
    const { amount } = await c.req.json();

    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    // Check if order is already refunded
    if (order.status === "canceled-refunded" && order.refundAmount) {
      console.log(`‚ö†Ô∏è Order ${orderId} is already refunded: ${order.refundAmount}`);
      return c.json({ 
        error: "This order has already been refunded", 
        alreadyRefunded: true,
        refundAmount: order.refundAmount 
      }, 400);
    }

    // Process refund in Stripe
    let refund;
    try {
      refund = await stripe.refunds.create({
        payment_intent: order.stripePaymentId,
        amount: Math.round(amount * 100), // Convert to cents
      });
    } catch (stripeError: any) {
      // Handle already refunded error specifically
      if (stripeError.code === 'charge_already_refunded') {
        console.log(`‚ö†Ô∏è Stripe reports charge already refunded for order ${orderId}`);
        
        // Update our records to match Stripe's state
        order.status = "canceled-refunded";
        order.refundAmount = amount;
        order.updatedAt = new Date().toISOString();
        await kv.set(`order:${orderId}`, order);
        
        return c.json({ 
          error: "This charge has already been refunded in Stripe",
          alreadyRefunded: true,
          refundAmount: amount
        }, 400);
      }
      // Re-throw other Stripe errors
      throw stripeError;
    }

    // Add activity log entry
    if (!order.activityLog) order.activityLog = [];
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Refund Processed',
      details: `Refund of ${amount.toFixed(2)} issued via Stripe. Refund ID: ${refund.id}`,
      user: 'Admin',
      stripeUrl: `https://dashboard.stripe.com/payments/${order.stripePaymentId}`
    });
    
    // Update order status
    order.status = "canceled-refunded";
    order.refundAmount = amount;
    order.updatedAt = new Date().toISOString();
    await kv.set(`order:${orderId}`, order);

    // Send refund notification
    await sendRefundNotification(order, amount);

    console.log(`‚úÖ Refund processed successfully for order ${orderId}: ${amount}`);
    return c.json({ success: true, refund });
  } catch (error: any) {
    console.error("Error processing refund:", error);
    return c.json({ error: error.message || "Failed to process refund" }, 500);
  }
});

// Helper function to send customer info update notification
async function sendCustomerInfoUpdateNotification(order: any) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  const twilioAccountSid = Deno.env.get("TWILIO_ACCOUNT_SID");
  const twilioAuthToken = Deno.env.get("TWILIO_AUTH_TOKEN");
  const twilioPhoneNumber = Deno.env.get("TWILIO_PHONE_NUMBER");

  if (resendApiKey) {
    try {
      await fetch("https://api.resend.com/emails", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${resendApiKey}`,
        },
        body: JSON.stringify({
          from: "Santa's Workshop <noreply@updates.santascertifiedletter.com>",
          to: [order.customerInfo.email],
          subject: "Your Order Information Has Been Updated üìù",
          html: `<div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;"><h2 style="color: #dc2626;">üéÖ Order Information Updated</h2><p>Hello ${order.customerInfo.name},</p><p>Your order information has been updated.</p><div style="background-color: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0;"><p><strong>Order:</strong> #${order.orderId.slice(-8)}</p><p><strong>Updated:</strong> ${new Date().toLocaleDateString()}</p></div><p style="color: #dc2626;">üéÑ Keep the magic alive!</p></div>`,
        }),
      });
    } catch (error) {
      console.error("‚ùå Failed to send email:", error);
    }
  }

  if (twilioAccountSid && twilioAuthToken && twilioPhoneNumber && order.customerInfo.phone) {
    try {
      const auth = btoa(`${twilioAccountSid}:${twilioAuthToken}`);
      await fetch(`https://api.twilio.com/2010-04-01/Accounts/${twilioAccountSid}/Messages.json`, {
        method: "POST",
        headers: {
          "Authorization": `Basic ${auth}`,
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: new URLSearchParams({
          To: order.customerInfo.phone,
          From: twilioPhoneNumber,
          Body: `üéÖ Your Santa letter order info has been updated. Order #${order.orderId.slice(-8)}`,
        }),
      });
    } catch (error) {
      console.error("‚ùå Failed to send SMS:", error);
    }
  }
}

// Helper function to send subscription canceled notification
async function sendSubscriptionCanceledNotification(order: any) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  const twilioAccountSid = Deno.env.get("TWILIO_ACCOUNT_SID");
  const twilioAuthToken = Deno.env.get("TWILIO_AUTH_TOKEN");
  const twilioPhoneNumber = Deno.env.get("TWILIO_PHONE_NUMBER");

  if (resendApiKey) {
    try {
      await fetch("https://api.resend.com/emails", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${resendApiKey}`,
        },
        body: JSON.stringify({
          from: "Santa's Workshop <noreply@updates.santascertifiedletter.com>",
          to: [order.customerInfo.email],
          subject: "Your Subscription Has Been Canceled",
          html: `<div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;"><h2 style="color: #dc2626;">üéÖ Subscription Canceled</h2><p>Hello ${order.customerInfo.name},</p><p>Your Santa's Magical Adventures subscription has been canceled.</p><div style="background-color: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0;"><p><strong>Order:</strong> #${order.orderId.slice(-8)}</p><p><strong>Subscription ID:</strong> ${order.subscriptionId}</p></div><p>You will not be charged for any future months.</p><p style="color: #dc2626;">üéÑ We hope to see you again next year!</p></div>`,
        }),
      });
    } catch (error) {
      console.error("‚ùå Failed to send email:", error);
    }
  }

  if (twilioAccountSid && twilioAuthToken && twilioPhoneNumber && order.customerInfo.phone) {
    try {
      const auth = btoa(`${twilioAccountSid}:${twilioAuthToken}`);
      await fetch(`https://api.twilio.com/2010-04-01/Accounts/${twilioAccountSid}/Messages.json`, {
        method: "POST",
        headers: {
          "Authorization": `Basic ${auth}`,
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: new URLSearchParams({
          To: order.customerInfo.phone,
          From: twilioPhoneNumber,
          Body: `üéÖ Your Santa subscription has been canceled. No future charges will be made.`,
        }),
      });
    } catch (error) {
      console.error("‚ùå Failed to send SMS:", error);
    }
  }
}

// Helper function to send refund notification
async function sendRefundNotification(order: any, amount: number) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  const twilioAccountSid = Deno.env.get("TWILIO_ACCOUNT_SID");
  const twilioAuthToken = Deno.env.get("TWILIO_AUTH_TOKEN");
  const twilioPhoneNumber = Deno.env.get("TWILIO_PHONE_NUMBER");

  if (resendApiKey) {
    try {
      await fetch("https://api.resend.com/emails", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${resendApiKey}`,
        },
        body: JSON.stringify({
          from: "Santa's Workshop <noreply@updates.santascertifiedletter.com>",
          to: [order.customerInfo.email],
          subject: `Refund Processed: ${amount.toFixed(2)} üíµ`,
          html: `<div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;"><h2 style="color: #dc2626;">üíµ Refund Processed</h2><p>Hello ${order.customerInfo.name},</p><p>Your refund has been processed successfully.</p><div style="background-color: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; border: 2px solid #16a34a;"><p style="font-size: 24px; margin: 0; color: #16a34a;"><strong>${amount.toFixed(2)}</strong></p><p style="margin: 5px 0 0 0;">Refund Amount</p></div><div style="background-color: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0;"><p><strong>Order:</strong> #${order.orderId.slice(-8)}</p><p><strong>Refunded:</strong> ${new Date().toLocaleDateString()}</p></div><p>The refund will appear on your original payment method within 5-10 business days.</p><p style="color: #dc2626;">üéÑ Thank you!</p></div>`,
        }),
      });
    } catch (error) {
      console.error("‚ùå Failed to send refund email:", error);
    }
  }

  if (twilioAccountSid && twilioAuthToken && twilioPhoneNumber && order.customerInfo.phone) {
    try {
      const auth = btoa(`${twilioAccountSid}:${twilioAuthToken}`);
      await fetch(`https://api.twilio.com/2010-04-01/Accounts/${twilioAccountSid}/Messages.json`, {
        method: "POST",
        headers: {
          "Authorization": `Basic ${auth}`,
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: new URLSearchParams({
          To: order.customerInfo.phone,
          From: twilioPhoneNumber,
          Body: `üíµ Refund of ${amount.toFixed(2)} processed for order #${order.orderId.slice(-8)}. Funds will appear in 5-10 business days.`,
        }),
      });
    } catch (error) {
      console.error("‚ùå Failed to send SMS:", error);
    }
  }
}

// Update Next Billing Date (without charging)
app.post("/make-server-cf244566/admin/update-billing-date", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }

  try {
    const { orderId, nextBillingDate } = await c.req.json();
    
    console.log(`üìÖ Updating next billing date for order: ${orderId} to ${nextBillingDate}`);
    
    // Get order
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!order.subscriptionId) {
      return c.json({ error: "Order does not have a subscription" }, 400);
    }
    
    // Validate date
    if (!nextBillingDate) {
      return c.json({ error: "Next billing date is required" }, 400);
    }

    const nextBillingTimestamp = Math.floor(new Date(nextBillingDate).getTime() / 1000);
    const now = Math.floor(Date.now() / 1000);
    
    // Get subscription from Stripe
    const subscription = await stripe.subscriptions.retrieve(order.subscriptionId);
    
    if (subscription.status === "canceled") {
      return c.json({ error: "Subscription is already canceled" }, 400);
    }
    
    // If date is today or in the past, charge immediately
    if (nextBillingTimestamp <= now) {
      console.log(`üîî Billing date is today or past - charging immediately`);
      
      // Get subscription price from order (configurable per subscription)
      const subscriptionPrice = order.subscriptionPrice || 12.00;
      const subscriptionProductName = order.subscriptionProductName || "Santa's Magical Journey";
      
      // Create an invoice item for immediate billing
      await stripe.invoiceItems.create({
        customer: subscription.customer as string,
        amount: Math.round(subscriptionPrice * 100), // Convert to cents
        currency: 'usd',
        description: `${subscriptionProductName} - Monthly Letter`,
      });
      
      // Create and finalize the invoice
      const invoice = await stripe.invoices.create({
        customer: subscription.customer as string,
        auto_advance: true,
        description: `Immediate billing for subscription ${order.subscriptionId}`,
        metadata: {
          orderId: orderId,
          immediateCharge: 'true',
        },
      });
      
      // Finalize the invoice
      const finalizedInvoice = await stripe.invoices.finalizeInvoice(invoice.id);
      
      // Wait for payment to process
      await new Promise(resolve => setTimeout(resolve, 1500));
      
      // Retrieve the invoice to get final payment status
      const paidInvoice = await stripe.invoices.retrieve(finalizedInvoice.id);
      
      if (paidInvoice.status !== 'paid') {
        console.error(`‚ö†Ô∏è Invoice not paid. Status: ${paidInvoice.status}`);
        return c.json({ error: `Payment failed. Invoice status: ${paidInvoice.status}` }, 400);
      }
      
      console.log(`‚úÖ Immediate charge successful: ${(paidInvoice.amount_paid / 100).toFixed(2)}`);
      
      // Calculate next billing date based on billing interval
      const billingIntervalDays = order.billingIntervalDays || 30;
      const nextBilling = new Date();
      nextBilling.setDate(nextBilling.getDate() + billingIntervalDays);
      
      // Update subscription's next billing date
      const nextBillingTimestamp = Math.floor(nextBilling.getTime() / 1000);
      await stripe.subscriptions.update(order.subscriptionId, {
        trial_end: nextBillingTimestamp,
        proration_behavior: 'none',
      });
      
      // Update order in database
      order.subscriptionNextBillingDate = nextBilling.toISOString();
      order.successfulCharges = (order.successfulCharges || 0) + 1;
      order.subscriptionMonthsActive = order.successfulCharges;
      order.updatedAt = new Date().toISOString();
      
      // Add to activity log
      if (!order.activityLog) {
        order.activityLog = [];
      }
      order.activityLog.push({
        timestamp: new Date().toISOString(),
        action: 'Manual Charge - Immediate',
        details: `Charged ${(paidInvoice.amount_paid / 100).toFixed(2)}. Month ${order.successfulCharges}. Next billing: ${nextBilling.toLocaleDateString()}`,
        user: 'Admin',
        stripeUrl: `https://dashboard.stripe.com/invoices/${paidInvoice.id}`
      });
      
      await kv.set(`order:${orderId}`, order);
      
      // Create a new order for this month's fulfillment
      const allOrderIds = (await kv.get("orders:all")) || [];
      const newOrderId = `ord_${Date.now()}_${Math.random().toString(36).substring(7)}`;
      const newOrder = {
        orderId: newOrderId,
        parentOrderId: order.orderId,
        subscriptionId: order.subscriptionId,
        sessionId: paidInvoice.id,
        stripePaymentId: paidInvoice.payment_intent,
        stripeCheckoutUrl: `https://dashboard.stripe.com/invoices/${paidInvoice.id}`,
        orderDate: new Date().toISOString(),
        status: "pending",
        total: paidInvoice.amount_paid / 100,
        customerInfo: order.customerInfo,
        letterPackages: order.letterPackages,
        numberOfPackages: order.numberOfPackages,
        shippingDate: "",
        monthlySubscription: false,
        subscriptionRecurringOrder: true,
        subscriptionMonth: order.successfulCharges,
        subscriptionProductName: subscriptionProductName,
        affiliateId: order.affiliateId,
        affiliateName: order.affiliateName,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        activityLog: [{
          timestamp: new Date().toISOString(),
          action: 'Order Created',
          details: `Recurring subscription order - Month ${order.successfulCharges} (Manual Charge)`,
          user: 'Admin'
        }]
      };
      
      await kv.set(`order:${newOrderId}`, newOrder);
      allOrderIds.push(newOrderId);
      await kv.set("orders:all", allOrderIds);
      
      console.log(`‚úÖ Created new order ${newOrderId} for manual subscription charge`);
      
      // Send notification email
      if (order.customerInfo?.email) {
        try {
          const resendApiKey = Deno.env.get("RESEND_API_KEY");
          if (resendApiKey) {
            await fetch("https://api.resend.com/emails", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${resendApiKey}`,
              },
              body: JSON.stringify({
                from: "Santa's Workshop <noreply@updates.santascertifiedletter.com>",
                to: [order.customerInfo.email],
                subject: "üéÖ Your Monthly Santa Letter is On The Way!",
                html: `
                  <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                    <h2 style="color: #16a34a;">üéÖ Payment Received!</h2>
                    <p>Hello ${order.customerInfo.name},</p>
                    <p>Your monthly subscription payment has been processed successfully.</p>
                    <div style="background-color: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; border: 2px solid #16a34a;">
                      <p style="font-size: 24px; margin: 0; color: #16a34a;"><strong>$12.00</strong></p>
                      <p style="margin: 5px 0 0 0;">Monthly Subscription</p>
                    </div>
                    <p>Your monthly letter from Santa will be on its way soon!</p>
                    <p>Next billing date: <strong>${nextBilling.toLocaleDateString()}</strong></p>
                    <p style="color: #dc2626;">üéÑ Thank you for keeping the magic alive!</p>
                  </div>
                `,
              }),
            });
          }
        } catch (error) {
          console.error("‚ùå Failed to send notification email:", error);
        }
      }
      
      return c.json({ 
        success: true,
        invoiceId: paidInvoice.id,
        amountCharged: (paidInvoice.amount_paid / 100).toFixed(2),
        nextBillingDate: nextBilling.toISOString(),
        message: "Subscription charged successfully"
      });
    }

    // Date is in the future - just update the billing date without charging
    await stripe.subscriptions.update(order.subscriptionId, {
      trial_end: nextBillingTimestamp,
      proration_behavior: 'none',
    });

    console.log(`‚úÖ Updated Stripe subscription billing anchor to: ${nextBillingDate}`);

    // Update order in database
    order.subscriptionNextBillingDate = nextBillingDate;
    order.updatedAt = new Date().toISOString();
    
    // Add to activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Next Billing Date Updated',
      details: `Next billing date set to ${new Date(nextBillingDate).toLocaleDateString()}`,
      user: 'Admin'
    });

    await kv.set(`order:${orderId}`, order);
    
    console.log(`‚úÖ Updated order in database with new billing date: ${nextBillingDate}`);

    return c.json({ 
      success: true,
      nextBillingDate: nextBillingDate,
      amountCharged: "0.00",
      message: "Next billing date updated successfully (no charge)"
    });
  } catch (error: any) {
    console.error("Error updating billing date:", error);
    return c.json({ 
      error: error.message || "Failed to update billing date" 
    }, 500);
  }
});

// Manual Subscription Billing - Charge subscriber immediately
app.post("/make-server-cf244566/admin/charge-subscription", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }

  try {
    const { orderId, customBillingDate, skipRecentChargeCheck } = await c.req.json();
    
    console.log(`üîî Manual billing requested for order: ${orderId}`);
    
    // Get order
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!order.subscriptionId) {
      return c.json({ error: "Order does not have a subscription" }, 400);
    }
    
    // Check if charged in last 30 days (protection against double-charging)
    if (!skipRecentChargeCheck && order.lastChargeDate) {
      const daysSinceLastCharge = (Date.now() - new Date(order.lastChargeDate).getTime()) / (1000 * 60 * 60 * 24);
      if (daysSinceLastCharge < 30) {
        console.warn(`‚ö†Ô∏è Order was charged ${daysSinceLastCharge.toFixed(1)} days ago - within 30 days`);
        return c.json({ 
          error: "RECENT_CHARGE",
          recentCharge: true,
          lastChargeDate: order.lastChargeDate,
          daysSinceCharge: Math.floor(daysSinceLastCharge),
          message: `This subscription was charged ${Math.floor(daysSinceLastCharge)} days ago. Are you sure you want to charge again?`
        }, 400);
      }
    }
    
    // Get subscription from Stripe
    const subscription = await stripe.subscriptions.retrieve(order.subscriptionId);
    
    if (subscription.status === "canceled") {
      return c.json({ error: "Subscription is already canceled" }, 400);
    }
    
    // Get customer to verify default payment method
    const customer = await stripe.customers.retrieve(subscription.customer as string);
    
    // Ensure customer has a default payment method
    if (!subscription.default_payment_method && !customer.deleted && !customer.invoice_settings?.default_payment_method) {
      console.error(`‚ö†ÔøΩÔøΩ No default payment method found for customer ${subscription.customer}`);
      return c.json({ 
        error: "No payment method on file. Customer needs to update their payment information.",
        details: "Customer does not have a default payment method attached."
      }, 400);
    }
    
    // Get subscription price from order (configurable per subscription)
    const subscriptionPrice = order.subscriptionPrice || 12.00;
    const subscriptionProductName = order.subscriptionProductName || "Santa's Magical Journey";
    
    console.log(`üí≥ Charging subscription: ${subscriptionPrice.toFixed(2)}`);
    
    // Get the default payment method
    const defaultPaymentMethod = subscription.default_payment_method || 
                                  (!customer.deleted && customer.invoice_settings?.default_payment_method) || 
                                  null;
    
    if (!defaultPaymentMethod) {
      throw new Error("No default payment method found for customer");
    }
    
    console.log(`üí≥ Using payment method: ${defaultPaymentMethod}`);
    
    // APPROACH: Use PaymentIntent for immediate one-time charge
    // This ensures the exact amount is charged right away (not using invoices which can have $0 issues)
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(subscriptionPrice * 100), // Convert to cents
      currency: 'usd',
      customer: subscription.customer as string,
      payment_method: defaultPaymentMethod as string,
      off_session: true, // Allows charging without customer present
      confirm: true, // Automatically confirm and charge
      description: `${subscriptionProductName} - Manual Charge`,
      metadata: {
        orderId: orderId,
        manualCharge: 'true',
        subscriptionId: order.subscriptionId,
      },
    });
    
    console.log(`üí≥ Payment Intent created: ${paymentIntent.id}`);
    console.log(`üí∞ Payment status: ${paymentIntent.status}, Amount: ${(paymentIntent.amount / 100).toFixed(2)}`);
    
    // Check payment status
    if (paymentIntent.status !== 'succeeded') {
      console.error(`‚ö†Ô∏è Payment did not succeed. Status: ${paymentIntent.status}`);
      
      // Log the declined charge
      order.declinedCharges = (order.declinedCharges || 0) + 1;
      order.updatedAt = new Date().toISOString();
      
      if (!order.activityLog) {
        order.activityLog = [];
      }
      order.activityLog.push({
        timestamp: new Date().toISOString(),
        action: 'Subscription Charge Declined (Charge Now)',
        details: `Charge of ${subscriptionPrice.toFixed(2)} declined. Status: ${paymentIntent.status}. PaymentIntent: ${paymentIntent.id}`,
        user: 'Admin',
        stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntent.id}`
      });
      
      await kv.set(`order:${orderId}`, order);
      
      return c.json({ 
        error: `Payment failed. Status: ${paymentIntent.status}`,
        paymentIntentId: paymentIntent.id,
        stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntent.id}`
      }, 400);
    }
    
    // Create a mock invoice object for the rest of the code
    const paidInvoice = { 
      id: paymentIntent.id, 
      status: 'paid',
      amount_paid: paymentIntent.amount 
    };
    
    // Calculate next billing date
    let nextBillingDate;
    if (customBillingDate) {
      nextBillingDate = customBillingDate;
    } else {
      // Use billing interval to calculate next date
      const billingIntervalDays = order.billingIntervalDays || 30;
      const nextBilling = new Date();
      nextBilling.setDate(nextBilling.getDate() + billingIntervalDays);
      nextBillingDate = nextBilling.toISOString();
    }
    
    const billingTimestamp = Math.floor(new Date(nextBillingDate).getTime() / 1000);
    const now = Math.floor(Date.now() / 1000);
    
    if (billingTimestamp > now) {
      // Set trial_end to update next billing date
      await stripe.subscriptions.update(order.subscriptionId, {
        trial_end: billingTimestamp,
        proration_behavior: 'none',
      });
      
      console.log(`‚úÖ Updated next billing date to: ${nextBillingDate}`);
    }
    
    // Update order with new billing date and increment counters
    order.subscriptionNextBillingDate = nextBillingDate;
    order.successfulCharges = (order.successfulCharges || 0) + 1;
    order.subscriptionMonthsActive = order.successfulCharges;
    order.lastChargeDate = new Date().toISOString(); // Track when last charged for 30-day protection
    order.updatedAt = new Date().toISOString();
    
    // Add to activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Subscription Charged (Charge Now)',
      details: `Charged ${subscriptionPrice.toFixed(2)}. Month ${order.successfulCharges}. Next billing: ${new Date(nextBillingDate).toLocaleDateString()}. PaymentIntent: ${paidInvoice.id}`,
      user: 'Admin',
      stripeUrl: `https://dashboard.stripe.com/payments/${paidInvoice.id}`
    });
    
    await kv.set(`order:${orderId}`, order);
    
    // Create a new order for this month's fulfillment
    console.log(`üì¶ Creating fulfillment order. Subscription letters count: ${(order.subscriptionLetters || []).length}`);
    console.log(`üì¶ Subscription letters data:`, JSON.stringify(order.subscriptionLetters));
    
    const allOrderIds = (await kv.get("orders:all")) || [];
    const newOrderId = `ord_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    const newOrder = {
      orderId: newOrderId,
      parentOrderId: order.orderId,
      subscriptionId: order.subscriptionId,
      sessionId: paidInvoice.id,
      stripePaymentId: paidInvoice.id,
      stripeCheckoutUrl: `https://dashboard.stripe.com/payments/${paidInvoice.id}`,
      orderDate: new Date().toISOString(),
      status: "pending",
      total: paidInvoice.amount_paid / 100,
      customerInfo: order.customerInfo,
      letterPackages: order.letterPackages,
      numberOfPackages: order.numberOfPackages,
      letters: order.subscriptionLetters || [], // Copy subscription letter data for fulfillment
      shippingDate: "",
      monthlySubscription: false,
      subscriptionRecurringOrder: true,
      subscriptionMonth: order.successfulCharges,
      subscriptionProductName: subscriptionProductName,
      affiliateId: order.affiliateId,
      affiliateName: order.affiliateName,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      activityLog: [{
        timestamp: new Date().toISOString(),
        action: 'Order Created',
        details: `Recurring subscription order - Month ${order.successfulCharges} (Charge Now). Copied ${(order.subscriptionLetters || []).length} letter(s) from subscription.`,
        user: 'Admin'
      }]
    };
    
    await kv.set(`order:${newOrderId}`, newOrder);
    allOrderIds.push(newOrderId);
    await kv.set("orders:all", allOrderIds);
    
    console.log(`‚úÖ Created new order ${newOrderId} for "Charge Now"`);
    
    console.log(`‚úÖ Manual charge successful: ${paidInvoice.id}, Amount: ${(paidInvoice.amount_paid / 100).toFixed(2)}`);
    
    // Send notification email
    if (order.customerInfo?.email) {
      try {
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        if (resendApiKey) {
          await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${resendApiKey}`,
            },
            body: JSON.stringify({
              from: "Santa's Workshop <noreply@updates.santascertifiedletter.com>",
              to: [order.customerInfo.email],
              subject: "üéÖ Your Monthly Santa Letter is On The Way!",
              html: `
                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                  <h2 style="color: #16a34a;">üéÖ Payment Received!</h2>
                  <p>Hello ${order.customerInfo.name},</p>
                  <p>Your monthly subscription payment has been processed successfully.</p>
                  <div style="background-color: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; border: 2px solid #16a34a;">
                    <p style="font-size: 24px; margin: 0; color: #16a34a;"><strong>$12.00</strong></p>
                    <p style="margin: 5px 0 0 0;">Monthly Subscription</p>
                  </div>
                  <p>Your monthly letter from Santa will be on its way soon!</p>
                  ${customBillingDate ? `<p>Next billing date: <strong>${new Date(customBillingDate).toLocaleDateString()}</strong></p>` : ''}
                  <p style="color: #dc2626;">üéÑ Thank you for keeping the magic alive!</p>
                </div>
              `,
            }),
          });
        }
      } catch (error) {
        console.error("‚ùå Failed to send notification email:", error);
      }
    }
    
    return c.json({ 
      success: true, 
      paymentIntentId: paidInvoice.id,
      amountCharged: (paidInvoice.amount_paid / 100).toFixed(2),
      nextBillingDate: customBillingDate || order.subscriptionNextBillingDate,
      stripeUrl: `https://dashboard.stripe.com/payments/${paidInvoice.id}`
    });
  } catch (error: any) {
    console.error("ÔøΩÔøΩ Error charging subscription:", error);
    return c.json({ 
      error: error.message || "Failed to charge subscription",
      details: error.toString(),
    }, 500);
  }
});

// Update Billing Interval for Subscription
app.post("/make-server-cf244566/admin/update-billing-interval", async (c) => {
  try {
    const { orderId, billingIntervalDays } = await c.req.json();
    
    console.log(`üîÑ Updating billing interval for order: ${orderId} to ${billingIntervalDays} days`);
    
    // Get order
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!order.subscriptionId) {
      return c.json({ error: "Order does not have a subscription" }, 400);
    }
    
    // Validate interval
    if (!billingIntervalDays || billingIntervalDays < 1 || billingIntervalDays > 365) {
      return c.json({ error: "Billing interval must be between 1 and 365 days" }, 400);
    }
    
    // Update order
    order.billingIntervalDays = billingIntervalDays;
    order.updatedAt = new Date().toISOString();
    
    // Add to activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Billing Interval Updated',
      details: `Billing interval set to ${billingIntervalDays} days`,
      user: 'Admin'
    });
    
    await kv.set(`order:${orderId}`, order);
    
    console.log(`‚úÖ Billing interval updated to ${billingIntervalDays} days`);
    
    return c.json({ 
      success: true,
      billingIntervalDays: billingIntervalDays,
      message: "Billing interval updated successfully"
    });
  } catch (error: any) {
    console.error("Error updating billing interval:", error);
    return c.json({ 
      error: error.message || "Failed to update billing interval" 
    }, 500);
  }
});

// Update Subscription Price
app.post("/make-server-cf244566/admin/update-subscription-price", async (c) => {
  try {
    const { orderId, subscriptionPrice } = await c.req.json();
    
    console.log(`üí∞ Updating subscription price for order: ${orderId} to ${subscriptionPrice}`);
    
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!order.subscriptionId) {
      return c.json({ error: "Order does not have a subscription" }, 400);
    }
    
    if (!subscriptionPrice || subscriptionPrice < 0.50 || subscriptionPrice > 999.99) {
      return c.json({ error: "Subscription price must be between $0.50 and $999.99" }, 400);
    }
    
    const oldPrice = order.subscriptionPrice || 12.00;
    order.subscriptionPrice = parseFloat(subscriptionPrice);
    order.updatedAt = new Date().toISOString();
    
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Subscription Price Updated',
      details: `Price changed from ${oldPrice.toFixed(2)} to ${parseFloat(subscriptionPrice).toFixed(2)}`,
      user: 'Admin'
    });
    
    await kv.set(`order:${orderId}`, order);
    
    console.log(`‚úÖ Subscription price updated to ${subscriptionPrice}`);
    
    return c.json({ 
      success: true,
      subscriptionPrice: parseFloat(subscriptionPrice),
      message: "Subscription price updated successfully"
    });
  } catch (error: any) {
    console.error("Error updating subscription price:", error);
    return c.json({ 
      error: error.message || "Failed to update subscription price" 
    }, 500);
  }
});

// Update Subscription Product Name
app.post("/make-server-cf244566/admin/update-subscription-product", async (c) => {
  try {
    const { orderId, subscriptionProductName } = await c.req.json();
    
    console.log(`üì¶ Updating subscription product name for order: ${orderId}`);
    
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!order.subscriptionId) {
      return c.json({ error: "Order does not have a subscription" }, 400);
    }
    
    if (!subscriptionProductName || subscriptionProductName.trim().length === 0) {
      return c.json({ error: "Product name cannot be empty" }, 400);
    }
    
    if (subscriptionProductName.length > 100) {
      return c.json({ error: "Product name must be 100 characters or less" }, 400);
    }
    
    const oldProductName = order.subscriptionProductName || "Santa's Magical Journey";
    order.subscriptionProductName = subscriptionProductName.trim();
    order.updatedAt = new Date().toISOString();
    
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Subscription Product Updated',
      details: `Product changed from "${oldProductName}" to "${subscriptionProductName.trim()}"`,
      user: 'Admin'
    });
    
    await kv.set(`order:${orderId}`, order);
    
    console.log(`‚úÖ Subscription product name updated`);
    
    return c.json({ 
      success: true,
      subscriptionProductName: subscriptionProductName.trim(),
      message: "Subscription product name updated successfully"
    });
  } catch (error: any) {
    console.error("Error updating subscription product name:", error);
    return c.json({ 
      error: error.message || "Failed to update subscription product name" 
    }, 500);
  }
});

// Admin Affiliate Reporting Endpoint
app.get("/make-server-cf244566/admin/affiliate-reports", async (c) => {
  try {
    const dateRange = c.req.query("dateRange") || "7days";
    const affiliateId = c.req.query("affiliateId");

    // Calculate date range
    const now = new Date();
    let startDate = new Date();
    
    switch (dateRange) {
      case "today":
        startDate.setHours(0, 0, 0, 0);
        break;
      case "yesterday":
        startDate.setDate(startDate.getDate() - 1);
        startDate.setHours(0, 0, 0, 0);
        now.setDate(now.getDate() - 1);
        now.setHours(23, 59, 59, 999);
        break;
      case "7days":
        startDate.setDate(startDate.getDate() - 7);
        break;
      case "30days":
        startDate.setDate(startDate.getDate() - 30);
        break;
      case "thismonth":
        startDate.setDate(1);
        startDate.setHours(0, 0, 0, 0);
        break;
      case "lastmonth":
        const lastMonth = new Date();
        lastMonth.setMonth(lastMonth.getMonth() - 1);
        startDate = new Date(lastMonth.getFullYear(), lastMonth.getMonth(), 1);
        now.setMonth(now.getMonth() - 1);
        now.setDate(1);
        now.setMonth(now.getMonth() + 1);
        now.setDate(0);
        now.setHours(23, 59, 59, 999);
        break;
    }

    // Fetch all orders
    const allOrderIds = (await kv.get("orders:all")) || [];
    const allOrders: any[] = [];
    
    for (const orderId of allOrderIds) {
      const order: any = await kv.get(`order:${orderId}`);
      if (order) {
        allOrders.push(order);
      }
    }

    // Filter orders by date range and affiliate
    const filteredOrders = allOrders.filter((order: any) => {
      const orderDate = new Date(order.orderDate);
      const inDateRange = orderDate >= startDate && orderDate <= now;
      const matchesAffiliate = !affiliateId || affiliateId === "all" || order.affiliateId === affiliateId;
      return inDateRange && matchesAffiliate;
    });

    // Fetch all events
    const allEventIds = (await kv.get("events:all")) || [];
    const allEvents: any[] = [];
    
    for (const eventId of allEventIds) {
      const event: any = await kv.get(`event:${eventId}`);
      if (event) {
        allEvents.push(event);
      }
    }

    // Filter events by date range and affiliate
    const filteredEvents = allEvents.filter((event: any) => {
      const eventDate = new Date(event.timestamp);
      const inDateRange = eventDate >= startDate && eventDate <= now;
      const matchesAffiliate = !affiliateId || affiliateId === "all" || event.affiliateId === affiliateId;
      return inDateRange && matchesAffiliate;
    });

    // Get affiliate names
    const affiliateNames: Record<string, string> = {};
    const allAffiliateIds = (await kv.get("affiliates:all")) || [];
    for (const affId of allAffiliateIds) {
      const affiliate: any = await kv.get(`affiliate:${affId}`);
      if (affiliate) {
        affiliateNames[affId] = affiliate.affiliateName;
      }
    }

    // Fetch chargebacks
    const allChargebacks = (await kv.get("chargebacks:all")) || [];
    const chargebackDetails: any[] = [];
    
    for (const chargebackId of allChargebacks) {
      const chargeback: any = await kv.get(`chargeback:${chargebackId}`);
      if (chargeback) {
        const chargebackDate = new Date(chargeback.chargebackDate);
        const inDateRange = chargebackDate >= startDate && chargebackDate <= now;
        const matchesAffiliate = !affiliateId || affiliateId === "all" || chargeback.affiliateId === affiliateId;
        
        if (inDateRange && matchesAffiliate) {
          chargebackDetails.push(chargeback);
        }
      }
    }

    // Calculate daily reports
    const dailyMap: Record<string, any> = {};
    
    // Process clicks from events
    filteredEvents.forEach((event: any) => {
      const date = new Date(event.timestamp).toISOString().split('T')[0];
      if (!dailyMap[date]) {
        dailyMap[date] = { date, clicks: 0, conversions: 0, revenue: 0, commission: 0, refunds: 0, chargebacks: 0, declines: 0 };
      }
      
      if (event.eventType === "page_view") {
        dailyMap[date].clicks++;
      }
      if (event.eventType === "sale") {
        dailyMap[date].conversions++;
        dailyMap[date].revenue += event.revenue || 0;
        dailyMap[date].commission += event.commission || 0;
      }
    });

    // Process orders
    filteredOrders.forEach((order: any) => {
      const date = new Date(order.orderDate).toISOString().split('T')[0];
      if (!dailyMap[date]) {
        dailyMap[date] = { date, clicks: 0, conversions: 0, revenue: 0, commission: 0, refunds: 0, chargebacks: 0, declines: 0 };
      }
      
      if (order.status === "canceled-refunded") {
        dailyMap[date].refunds++;
      }
      if (order.status === "chargeback") {
        dailyMap[date].chargebacks++;
      }
    });

    const dailyReports = Object.values(dailyMap).sort((a: any, b: any) => 
      new Date(b.date).getTime() - new Date(a.date).getTime()
    );

    // Calculate hourly reports (last 24 hours only)
    const hourlyMap: Record<string, any> = {};
    const last24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);
    
    filteredEvents.forEach((event: any) => {
      const eventDate = new Date(event.timestamp);
      if (eventDate >= last24Hours) {
        const hour = eventDate.getHours().toString().padStart(2, '0') + ':00';
        if (!hourlyMap[hour]) {
          hourlyMap[hour] = { hour, clicks: 0, conversions: 0, revenue: 0, commission: 0 };
        }
        
        if (event.eventType === "page_view") {
          hourlyMap[hour].clicks++;
        }
        if (event.eventType === "sale") {
          hourlyMap[hour].conversions++;
          hourlyMap[hour].revenue += event.revenue || 0;
          hourlyMap[hour].commission += event.commission || 0;
        }
      }
    });

    // Fill in missing hours with zeros
    for (let i = 0; i < 24; i++) {
      const hour = i.toString().padStart(2, '0') + ':00';
      if (!hourlyMap[hour]) {
        hourlyMap[hour] = { hour, clicks: 0, conversions: 0, revenue: 0, commission: 0 };
      }
    }

    const hourlyReports = Object.values(hourlyMap).sort((a: any, b: any) => 
      a.hour.localeCompare(b.hour)
    );

    // Prepare order details
    const orderDetails = filteredOrders.map((order: any) => ({
      orderId: order.orderId,
      sessionId: order.sessionId,
      affiliateId: order.affiliateId || "direct",
      affiliateName: order.affiliateName || affiliateNames[order.affiliateId] || "Direct Sale",
      customerEmail: order.customerInfo?.email || "",
      packageCount: order.numberOfPackages || 0,
      total: order.total || 0,
      commission: order.affiliateCommission || 0,
      status: order.status || "completed",
      orderDate: order.orderDate,
      subIds: order.subIds || {},
    }));

    // Calculate total stats
    const totalStats = {
      totalRevenue: filteredOrders.reduce((sum: number, o: any) => 
        o.status !== "canceled-refunded" && o.status !== "chargeback" ? sum + (o.total || 0) : sum, 0),
      totalCommission: filteredOrders.reduce((sum: number, o: any) => 
        o.status !== "canceled-refunded" && o.status !== "chargeback" ? sum + (o.affiliateCommission || 0) : sum, 0),
      totalRefunds: filteredOrders.filter((o: any) => o.status === "canceled-refunded").reduce((sum: number, o: any) => 
        sum + (o.total || 0), 0),
      totalChargebacks: chargebackDetails.reduce((sum: number, cb: any) => sum + (cb.amount || 0), 0),
      totalDeclines: 0, // Would need to track payment failures
      netRevenue: 0,
    };

    totalStats.netRevenue = totalStats.totalRevenue - totalStats.totalRefunds - totalStats.totalChargebacks;

    return c.json({
      dailyReports,
      hourlyReports,
      orders: orderDetails,
      chargebacks: chargebackDetails,
      totalStats,
    });
  } catch (error: any) {
    console.error("Error generating affiliate reports:", error);
    return c.json({ error: "Failed to generate reports" }, 500);
  }
});

// ========== DECLINED ORDERS ENDPOINTS ==========

// Get all declined orders
app.get("/make-server-cf244566/declined-orders", async (c) => {
  try {
    console.log("üìã Fetching all declined orders...");
    
    // Get all decline IDs
    const allDeclines = (await kv.get("all_declines")) || [];
    
    // Fetch all decline records
    const declines = [];
    for (const declineId of allDeclines) {
      const decline = await kv.get(`decline:${declineId}`);
      if (decline) {
        declines.push(decline);
      }
    }
    
    // Sort by timestamp (newest first)
    declines.sort((a: any, b: any) => {
      return new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime();
    });
    
    console.log(`‚úÖ Found ${declines.length} declined orders`);
    
    return c.json({ declines });
  } catch (error: any) {
    console.error("‚ùå Error fetching declined orders:", error);
    return c.json({ error: "Failed to fetch declined orders" }, 500);
  }
});

// Log a declined payment attempt
app.post("/make-server-cf244566/log-decline", async (c) => {
  try {
    const body = await c.req.json();
    const {
      timestamp,
      paymentIntentId,
      status,
      declineReason,
      declineCode,
      amount,
      customerInfo,
      letterPackages,
      numberOfPackages,
      affiliateId,
      subIds
    } = body;

    console.log("üìù Logging declined payment:", paymentIntentId);

    // Generate unique decline ID
    const declineId = `decline_${Date.now()}_${Math.random().toString(36).substring(7)}`;

    // Create decline record
    const declineRecord = {
      declineId,
      timestamp: timestamp || new Date().toISOString(),
      paymentIntentId: paymentIntentId || 'unknown',
      status: status || 'declined',
      declineReason: declineReason || 'Unknown error',
      declineCode: declineCode || 'unknown',
      amount: amount || 0,
      customerInfo: customerInfo || {},
      letterPackages: letterPackages || [],
      numberOfPackages: numberOfPackages || 0,
      affiliateId: affiliateId || null,
      subIds: subIds || {},
      
      // Email sequence tracking (initialized)
      emailSequence: {
        emailsSent: 0,
        lastEmailSent: null,
        emailDates: []
      },
      
      // Status flags
      unsubscribed: false,
      unsubscribedAt: null,
      converted: false,
      convertedAt: null
    };

    // Initialize activity log
    declineRecord.activityLog = [];

    // Save to database
    await kv.set(`decline:${declineId}`, declineRecord);

    // Add to all declines index
    const allDeclines = (await kv.get("all_declines")) || [];
    allDeclines.push(declineId);
    await kv.set("all_declines", allDeclines);

    console.log("‚úÖ Decline logged successfully:", declineId);

    return c.json({
      success: true,
      declineId: declineId
    });
  } catch (error: any) {
    console.error("‚ùå Error logging decline:", error);
    return c.json({ error: "Failed to log decline" }, 500);
  }
});

// Track email open (via tracking pixel)
app.get("/make-server-cf244566/decline/track/open/:declineId/:emailNumber", async (c) => {
  try {
    const declineId = c.req.param("declineId");
    const emailNumber = parseInt(c.req.param("emailNumber"));
    
    console.log(`ÔøΩÔøΩÔøΩ Email opened: ${declineId}, email #${emailNumber}`);
    
    // Get decline record
    const decline: any = await kv.get(`decline:${declineId}`);
    if (!decline) {
      return c.text("Not found", 404);
    }
    
    // Add to activity log
    if (!decline.activityLog) {
      decline.activityLog = [];
    }
    
    // Check if already logged (prevent duplicate opens)
    const alreadyLogged = decline.activityLog.some(
      (activity: any) => activity.type === 'email_opened' && activity.emailNumber === emailNumber
    );
    
    if (!alreadyLogged) {
      decline.activityLog.push({
        timestamp: new Date().toISOString(),
        type: 'email_opened',
        emailNumber: emailNumber
      });
      
      await kv.set(`decline:${declineId}`, decline);
      console.log(`‚úÖ Logged email open for decline ${declineId}`);
    }
    
    // Return 1x1 transparent pixel
    const pixel = Buffer.from(
      'R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
      'base64'
    );
    
    return c.body(pixel, 200, {
      'Content-Type': 'image/gif',
      'Cache-Control': 'no-store, no-cache, must-revalidate, proxy-revalidate',
      'Pragma': 'no-cache',
      'Expires': '0'
    });
  } catch (error: any) {
    console.error("‚ùå Error tracking email open:", error);
    // Return pixel anyway to avoid broken images
    const pixel = Buffer.from(
      'R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
      'base64'
    );
    return c.body(pixel, 200, { 'Content-Type': 'image/gif' });
  }
});

// Track email open (fallback without email number)
app.get("/make-server-cf244566/decline/track/open/:declineId", async (c) => {
  try {
    const declineId = c.req.param("declineId");
    
    console.log(`üìß Email opened (no email number): ${declineId}`);
    
    // Get decline record
    const decline: any = await kv.get(`decline:${declineId}`);
    if (decline) {
      // Add to activity log
      if (!decline.activityLog) {
        decline.activityLog = [];
      }
      
      decline.activityLog.push({
        timestamp: new Date().toISOString(),
        type: 'email_opened',
        emailNumber: 0,
        details: 'Email opened (unknown email number)'
      });
      
      await kv.set(`decline:${declineId}`, decline);
      console.log(`‚úÖ Logged email open for decline ${declineId}`);
    }
    
    // Return 1x1 transparent pixel
    const pixel = Buffer.from(
      'R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
      'base64'
    );
    
    return c.body(pixel, 200, {
      'Content-Type': 'image/gif',
      'Cache-Control': 'no-store, no-cache, must-revalidate, proxy-revalidate',
      'Pragma': 'no-cache',
      'Expires': '0'
    });
  } catch (error: any) {
    console.error("‚ùå Error tracking email open:", error);
    // Return pixel anyway to avoid broken images
    const pixel = Buffer.from(
      'R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
      'base64'
    );
    return c.body(pixel, 200, { 'Content-Type': 'image/gif' });
  }
});

// Track email click (with email number)
app.get("/make-server-cf244566/decline/track/click/:declineId/:emailNumber", async (c) => {
  try {
    const declineId = c.req.param("declineId");
    const emailNumber = parseInt(c.req.param("emailNumber"));
    
    console.log(`üñ±Ô∏è Email clicked: ${declineId}, email #${emailNumber}`);
    
    // Get decline record
    const decline: any = await kv.get(`decline:${declineId}`);
    if (decline) {
      // Add to activity log
      if (!decline.activityLog) {
        decline.activityLog = [];
      }
      
      decline.activityLog.push({
        timestamp: new Date().toISOString(),
        type: 'email_clicked',
        emailNumber: emailNumber,
        details: 'Recovery link clicked'
      });
      
      await kv.set(`decline:${declineId}`, decline);
      console.log(`‚úÖ Logged email click for decline ${declineId}`);
    }
    
    // Redirect to checkout with special recovery parameter
    // This allows us to track conversions
    const recoveryUrl = `https://santascertifiedletter.com/?recovery=${declineId}`;
    
    return c.redirect(recoveryUrl);
  } catch (error: any) {
    console.error("‚ùå Error tracking email click:", error);
    // Redirect anyway
    return c.redirect('https://santascertifiedletter.com/?recovery=error');
  }
});

// Track email click (fallback without email number for robustness)
app.get("/make-server-cf244566/decline/track/click/:declineId", async (c) => {
  try {
    const declineId = c.req.param("declineId");
    
    console.log(`üñ±Ô∏è Email clicked (no email number): ${declineId}`);
    
    // Get decline record
    const decline: any = await kv.get(`decline:${declineId}`);
    if (decline) {
      // Add to activity log
      if (!decline.activityLog) {
        decline.activityLog = [];
      }
      
      decline.activityLog.push({
        timestamp: new Date().toISOString(),
        type: 'email_clicked',
        emailNumber: 0,
        details: 'Recovery link clicked (unknown email number)'
      });
      
      await kv.set(`decline:${declineId}`, decline);
      console.log(`ÔøΩÔøΩÔøΩ Logged email click for decline ${declineId}`);
    }
    
    // Redirect to checkout with special recovery parameter
    const recoveryUrl = `https://santascertifiedletter.com/?recovery=${declineId}`;
    
    return c.redirect(recoveryUrl);
  } catch (error: any) {
    console.error("‚ùå Error tracking email click:", error);
    // Redirect anyway
    return c.redirect('https://santascertifiedletter.com/?recovery=error');
  }
});

// Unsubscribe from decline emails
app.get("/make-server-cf244566/decline/unsubscribe/:declineId", async (c) => {
  try {
    const declineId = c.req.param("declineId");
    
    console.log(`üö´ Unsubscribe request for: ${declineId}`);
    
    // Get decline record
    const decline: any = await kv.get(`decline:${declineId}`);
    if (!decline) {
      return c.html(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>Unsubscribe</title>
          <style>
            body { font-family: Arial, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; text-align: center; }
            h1 { color: #dc2626; }
          </style>
        </head>
        <body>
          <h1>‚ùå Not Found</h1>
          <p>We couldn't find this unsubscribe link.</p>
        </body>
        </html>
      `);
    }
    
    // Mark as unsubscribed
    decline.unsubscribed = true;
    decline.unsubscribedAt = new Date().toISOString();
    
    // Add to activity log
    if (!decline.activityLog) {
      decline.activityLog = [];
    }
    decline.activityLog.push({
      timestamp: new Date().toISOString(),
      type: 'unsubscribed',
      details: 'Customer unsubscribed from recovery emails'
    });
    
    await kv.set(`decline:${declineId}`, decline);
    
    console.log(`ÔøΩÔøΩÔøΩ Unsubscribed: ${declineId}`);
    
    // Return confirmation page
    return c.html(`
      <!DOCTYPE html>
      <html>
      <head>
        <title>Unsubscribed</title>
        <style>
          body { font-family: Arial, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; text-align: center; }
          h1 { color: #10b981; }
          p { font-size: 16px; line-height: 1.6; color: #666; }
          .button { display: inline-block; background: #dc2626; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; margin-top: 20px; }
        </style>
      </head>
      <body>
        <h1>‚úÖ You've been unsubscribed</h1>
        <p>You will no longer receive recovery emails for this order.</p>
        <p>If you change your mind and want to complete your order, you can still do so:</p>
        <a href="https://santascertifiedletter.com/?recovery=${declineId}" class="button">Complete My Order</a>
      </body>
      </html>
    `);
  } catch (error: any) {
    console.error("‚ùå Error unsubscribing:", error);
    return c.html(`
      <!DOCTYPE html>
      <html>
      <head>
        <title>Error</title>
        <style>
          body { font-family: Arial, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; text-align: center; }
          h1 { color: #dc2626; }
        </style>
      </head>
      <body>
        <h1>‚ùå Error</h1>
        <p>There was an error processing your request. Please try again later.</p>
      </body>
      </html>
    `);
  }
});

// Mark decline as converted
app.post("/make-server-cf244566/decline/mark-converted", async (c) => {
  try {
    const { declineId, orderId } = await c.req.json();
    
    console.log(`ÔøΩÔøΩÔøΩ Marking decline as converted: ${declineId} -> ${orderId}`);
    
    // Get decline record
    const decline: any = await kv.get(`decline:${declineId}`);
    if (!decline) {
      return c.json({ error: "Decline not found" }, 404);
    }
    
    // Update decline record
    decline.converted = true;
    decline.convertedAt = new Date().toISOString();
    decline.convertedOrderId = orderId;
    
    // Add to activity log
    if (!decline.activityLog) {
      decline.activityLog = [];
    }
    decline.activityLog.push({
      timestamp: new Date().toISOString(),
      type: 'converted',
      details: orderId
    });
    
    await kv.set(`decline:${declineId}`, decline);
    
    console.log(`‚úÖ Decline marked as converted: ${declineId}`);
    
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error marking decline as converted:", error);
    return c.json({ error: "Failed to mark as converted" }, 500);
  }
});

// Send manual recovery email
app.post("/make-server-cf244566/decline/send-recovery", async (c) => {
  try {
    const { declineId } = await c.req.json();
    
    console.log(`üìß Sending manual recovery email for: ${declineId}`);
    
    // Get decline record
    const decline: any = await kv.get(`decline:${declineId}`);
    if (!decline) {
      return c.json({ error: "Decline not found" }, 404);
    }
    
    if (decline.unsubscribed) {
      return c.json({ error: "Customer has unsubscribed" }, 400);
    }
    
    if (decline.converted) {
      return c.json({ error: "Customer has already converted" }, 400);
    }
    
    // Send recovery email
    const emailNumber = Math.max(1, (decline.emailSequence?.emailsSent || 0) + 1);
    const baseUrl = 'https://santascertifiedletter.com';
    
    // Create tracking URLs with validated email number
    const supabaseUrl = Deno.env.get('SUPABASE_URL');
    const trackingPixelUrl = `${supabaseUrl}/functions/v1/make-server-cf244566/decline/track/open/${declineId}/${emailNumber}`;
    const trackingClickUrl = `${supabaseUrl}/functions/v1/make-server-cf244566/decline/track/click/${declineId}/${emailNumber}`;
    const unsubscribeUrl = `${supabaseUrl}/functions/v1/make-server-cf244566/decline/unsubscribe/${declineId}`;
    
    console.log(`üìß Tracking URLs - Pixel: ${trackingPixelUrl}, Click: ${trackingClickUrl}`);
    
    // Send email via Resend
    const resendApiKey = Deno.env.get('RESEND_API_KEY');
    if (!resendApiKey) {
      return c.json({ error: "Resend API key not configured" }, 500);
    }
    
    // Direct link to update payment page (using query parameter)
    const updatePaymentUrl = `${baseUrl}/?page=updatepayment&token=${declineId}`;
    
    const emailHtml = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
        <style>
          body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0; }
          .container { max-width: 600px; margin: 0 auto; padding: 20px; }
          .header { background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
          .header h1 { margin: 0; font-family: 'Pacifico', cursive; font-size: 32px; }
          .content { background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none; }
          .button { display: inline-block; background: #dc2626; color: white !important; padding: 15px 30px; text-decoration: none; border-radius: 8px; font-weight: bold; margin: 20px 0; font-size: 18px; }
          .button:hover { background: #b91c1c; }
          .footer { background: #f9fafb; padding: 20px; text-align: center; color: #6b7280; font-size: 12px; border-radius: 0 0 10px 10px; }
          ul { background: #f3f4f6; padding: 20px; border-radius: 8px; }
          li { margin: 10px 0; }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="header">
            <h1>üéÖ Your Letter From Santa is Waiting!</h1>
          </div>
          <div class="content">
            <p>Hi ${decline.customerInfo.name},</p>
            
            <p>We noticed there was a small issue with your recent order for ${decline.numberOfPackages} Santa Letter${decline.numberOfPackages > 1 ? 's' : ''}.</p>
            
            <p style="font-size: 18px; color: #059669;"><strong>Don't worry - we've reserved your spot!</strong> üéÑ</p>
            
            <p>Simply click the button below to complete your order and give ${decline.letterPackages.map((pkg: any) => pkg.childFirstName).join(' and ')} the magical Christmas experience they deserve!</p>
            
            <div style="text-align: center;">
              <a href="${updatePaymentUrl}" class="button">
                ‚ú® Complete Your Order Now
              </a>
            </div>
            
            <p><strong>Your reserved order includes:</strong></p>
            <ul>
              <li>${decline.numberOfPackages} Personalized Letter${decline.numberOfPackages > 1 ? 's' : ''} from Santa</li>
              <li>North Pole postmark</li>
              <li>Official Nice List Certificate</li>
              <li>Activity sheet and stickers</li>
            </ul>
            
            <p>This is a limited-time offer - complete your order today!</p>
            
            <p>Ho Ho Ho! üéÖ</p>
            <p>Santa's Workshop Team</p>
          </div>
          <div class="footer">
            <p><a href="${unsubscribeUrl}" style="color: #6b7280; text-decoration: underline;">Unsubscribe</a> from these emails</p>
            <p style="margin-top: 10px; color: #9ca3af;">¬© 2025 Letters From Santa. All rights reserved.</p>
          </div>
        </div>
        <img src="${trackingPixelUrl}" width="1" height="1" alt="" style="display:none;" />
      </body>
      </html>
    `;
    
    const emailResponse = await fetch('https://api.resend.com/emails', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${resendApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        from: 'Santa\'s Workshop <noreply@updates.santascertifiedletter.com>',
        to: [decline.customerInfo.email],
        subject: `üéÖ ${decline.customerInfo.name}, Your Santa Letters Are Reserved!`,
        html: emailHtml
      }),
    });
    
    if (!emailResponse.ok) {
      const errorData = await emailResponse.json();
      console.error("‚ùå Resend error:", errorData);
      return c.json({ error: "Failed to send email" }, 500);
    }
    
    // Update decline record
    if (!decline.emailSequence) {
      decline.emailSequence = { emailsSent: 0, lastEmailSent: null, emailDates: [] };
    }
    decline.emailSequence.emailsSent++;
    decline.emailSequence.lastEmailSent = new Date().toISOString();
    decline.emailSequence.emailDates.push(new Date().toISOString());
    
    // Add to activity log
    if (!decline.activityLog) {
      decline.activityLog = [];
    }
    decline.activityLog.push({
      timestamp: new Date().toISOString(),
      type: 'email_sent',
      emailNumber: emailNumber
    });
    
    await kv.set(`decline:${declineId}`, decline);
    
    console.log(`‚úÖ Recovery email sent for decline ${declineId}`);
    
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error sending recovery email:", error);
    return c.json({ error: "Failed to send recovery email" }, 500);
  }
});

// ========== DECLINED ORDERS EMAIL SEQUENCE SYSTEM ==========

// Unsubscribe from decline emails
app.get("/make-server-cf244566/decline/unsubscribe/:declineId", async (c) => {
  try {
    const declineId = c.req.param("declineId");
    
    // Get the decline record
    const decline: any = await kv.get(`decline:${declineId}`);
    
    if (!decline) {
      return c.text("Decline record not found", 404);
    }
    
    // Mark as unsubscribed
    decline.unsubscribed = true;
    decline.unsubscribedAt = new Date().toISOString();
    
    // Add to activity log
    if (!decline.activityLog) {
      decline.activityLog = [];
    }
    decline.activityLog.push({
      timestamp: new Date().toISOString(),
      type: 'unsubscribed'
    });
    
    await kv.set(`decline:${declineId}`, decline);
    
    console.log(`‚úÖ Unsubscribed from decline emails: ${declineId}`);
    
    // Return HTML page
    return c.html(`
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Unsubscribed</title>
        <style>
          body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 50px auto;
            padding: 20px;
            text-align: center;
          }
          .success {
            background: #ecfdf5;
            border: 2px solid #6ee7b7;
            border-radius: 8px;
            padding: 30px;
            margin: 20px 0;
          }
          h1 {
            color: #059669;
            margin: 0 0 15px 0;
          }
          p {
            color: #374151;
            line-height: 1.6;
          }
        </style>
      </head>
      <body>
        <div class="success">
          <h1>‚úÖ Successfully Unsubscribed</h1>
          <p>You will no longer receive follow-up emails about your declined payment.</p>
          <p>If you change your mind and would like to complete your order, you can always visit our website directly.</p>
        </div>
        <p style="color: #6b7280; font-size: 14px; margin-top: 30px;">
          Thank you for your interest in Letters From Santa! üéÖ
        </p>
      </body>
      </html>
    `);
  } catch (error: any) {
    console.error("Error unsubscribing:", error);
    return c.text("Error processing unsubscribe request", 500);
  }
});

// Process declined orders email sequence (to be called daily via cron or manual trigger)
app.post("/make-server-cf244566/decline/process-sequence", async (c) => {
  try {
    console.log("üîÑ Processing declined orders email sequence...");
    
    const resendApiKey = Deno.env.get("RESEND_API_KEY");
    if (!resendApiKey) {
      console.error("RESEND_API_KEY not configured");
      return c.json({ error: "Email service not configured" }, 500);
    }
    
    // Get all declined orders
    const declines = await kv.getByPrefix("decline:");
    const today = new Date();
    
    let emailsSent = 0;
    let emailsSkipped = 0;
    
    for (const decline of declines) {
      // Skip if unsubscribed
      if (decline.unsubscribed) {
        emailsSkipped++;
        continue;
      }
      
      // Skip if converted (check if order with same email exists)
      const orders = await kv.getByPrefix("order:");
      const hasConverted = orders.some((order: any) => 
        order.customerInfo?.email?.toLowerCase() === decline.customerInfo?.email?.toLowerCase()
      );
      
      if (hasConverted) {
        // Mark as converted so we don't check again
        decline.converted = true;
        decline.convertedAt = new Date().toISOString();
        await kv.set(`decline:${decline.declineId}`, decline);
        emailsSkipped++;
        continue;
      }
      
      // Calculate days since decline
      const declineDate = new Date(decline.timestamp);
      const daysSinceDecline = Math.floor((today.getTime() - declineDate.getTime()) / (1000 * 60 * 60 * 24));
      
      // Initialize email tracking if not exists
      if (!decline.emailSequence) {
        decline.emailSequence = {
          emailsSent: 0,
          lastEmailSent: null,
          emailDates: []
        };
      }
      
      // Check if we should send email today
      const lastEmailDate = decline.emailSequence.lastEmailSent ? new Date(decline.emailSequence.lastEmailSent) : null;
      const hoursSinceLastEmail = lastEmailDate ? (today.getTime() - lastEmailDate.getTime()) / (1000 * 60 * 60) : 999;
      
      // Send one email per day (24 hours between emails)
      if (hoursSinceLastEmail < 23) {
        emailsSkipped++;
        continue;
      }
      
      // Limit to 7 emails total
      if (decline.emailSequence.emailsSent >= 7) {
        emailsSkipped++;
        continue;
      }
      
      // Prepare email content based on day number
      const dayNumber = decline.emailSequence.emailsSent + 1;
      const baseUrl = 'https://santascertifiedletter.com';
      const supabaseUrl = Deno.env.get('SUPABASE_URL');
      const trackingPixelUrl = `${supabaseUrl}/functions/v1/make-server-cf244566/decline/track/open/${decline.declineId}/${dayNumber}`;
      const trackingClickUrl = `${supabaseUrl}/functions/v1/make-server-cf244566/decline/track/click/${decline.declineId}/${dayNumber}`;
      const unsubscribeUrl = `${supabaseUrl}/functions/v1/make-server-cf244566/decline/unsubscribe/${decline.declineId}`;
      
      let subject = "";
      let message = "";
      
      switch (dayNumber) {
        case 1:
          subject = "üéÖ Complete Your Santa Letter Order";
          message = `We noticed there was an issue processing your payment for your Santa Letter order. We'd love to help you complete it!`;
          break;
        case 2:
          subject = "Still interested in your Santa Letter? üéÑ";
          message = `Your Santa Letter order is still waiting for you! Let's get those magical letters on their way to the North Pole.`;
          break;
        case 3:
          subject = "Don't miss out on the Christmas magic! ‚ú®";
          message = `Time is running out to get your personalized Letters From Santa delivered before Christmas!`;
          break;
        case 4:
          subject = "Your kids are going to love this! üéÅ";
          message = `Imagine the look on their faces when they receive a personalized letter from Santa himself!`;
          break;
        case 5:
          subject = "Last chance for Christmas delivery üöö";
          message = `We want to make sure your Santa Letters arrive in time for Christmas magic!`;
          break;
        case 6:
          subject = "We're here to help! ü§ù";
          message = `If you had any issues with payment, we're here to assist. Let's make this Christmas special!`;
          break;
        case 7:
          subject = "Final reminder: Santa Letters are waiting üéÖ";
          message = `This is our last reminder about your Santa Letter order. We'd hate for you to miss out!`;
          break;
      }
      
      const emailHtml = `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
        </head>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
          <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
            <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
              <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÖ Letters From Santa</h1>
              <p style="margin: 10px 0 0 0; font-size: 18px;">${subject}</p>
            </div>
            <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
              <p>Hi ${decline.customerInfo.name || 'there'},</p>
              
              <p style="font-size: 18px; color: #059669;"><strong>${message}</strong></p>
              
              <div style="background: #fef2f2; border-left: 4px solid #dc2626; padding: 15px; margin: 20px 0;">
                <p style="margin: 0; font-size: 16px;"><strong>üí≥ What happened:</strong></p>
                <p style="margin: 5px 0 0 0; color: #dc2626;">${decline.declineReason}</p>
              </div>
              
              <p><strong>Your order details:</strong></p>
              <ul style="background: #f3f4f6; padding: 20px; border-radius: 8px;">
                ${decline.letterPackages.map((pkg: any) => `
                  <li style="margin: 10px 0;">
                    Letter for <strong>${pkg.childFirstName} ${pkg.childLastName}</strong><br>
                    <span style="font-size: 14px; color: #6b7280;">to ${pkg.city}, ${pkg.state}</span>
                  </li>
                `).join('')}
              </ul>
              
              <p style="margin-top: 30px; font-size: 16px;"><strong>Total: ${decline.amount.toFixed(2)}</strong></p>
              
              <div style="text-align: center; margin: 30px 0;">
                <a href="${baseUrl}/?page=updatepayment&token=${decline.declineId}" 
                   style="display: inline-block; background: #dc2626; color: white; padding: 15px 40px; text-decoration: none; border-radius: 8px; font-weight: bold; font-size: 18px;">
                  üí≥ Update Payment Method
                </a>
              </div>
              
              <p style="margin-top: 30px; padding: 15px; background: #fef3c7; border-radius: 8px; border-left: 4px solid #f59e0b;">
                <strong>üí° Tip:</strong> Click "Update Payment Method" above to securely add a new card. Your order will be processed automatically once updated.
              </p>
              
              <p style="margin-top: 30px; color: #6b7280; font-size: 14px;">
                Need help? Reply to this email or contact our support team.
              </p>
            </div>
            <div style="background: #f9fafb; padding: 20px; text-align: center; color: #6b7280; font-size: 12px; border-radius: 0 0 10px 10px;">
              <p>Questions? Contact us at support@letterfromsanta.com</p>
              <p style="margin-top: 10px;">
                <a href="${unsubscribeUrl}" style="color: #6b7280; text-decoration: underline;">
                  Unsubscribe from these emails
                </a>
              </p>
              <p style="margin-top: 10px; color: #9ca3af;">¬© 2025 Letters From Santa. All rights reserved.</p>
            </div>
          </div>
        </body>
        </html>
      `;
      
      // Send email
      try {
        const emailResponse = await fetch("https://api.resend.com/emails", {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${resendApiKey}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
            to: decline.customerInfo.email,
            subject: subject,
            html: emailHtml,
          }),
        });
        
        if (emailResponse.ok) {
          // Update email sequence tracking
          decline.emailSequence.emailsSent++;
          decline.emailSequence.lastEmailSent = today.toISOString();
          decline.emailSequence.emailDates.push(today.toISOString());
          
          // Add to activity log
          if (!decline.activityLog) {
            decline.activityLog = [];
          }
          decline.activityLog.push({
            timestamp: today.toISOString(),
            type: 'email_sent',
            emailNumber: dayNumber
          });
          
          await kv.set(`decline:${decline.declineId}`, decline);
          
          emailsSent++;
          console.log(`‚úÖ Sent decline follow-up email #${dayNumber} to ${decline.customerInfo.email}`);
        } else {
          console.error(`‚ùå Failed to send decline email to ${decline.customerInfo.email}`);
        }
      } catch (emailError) {
        console.error(`Error sending decline email:`, emailError);
      }
    }
    
    console.log(`üìß Email sequence complete: ${emailsSent} sent, ${emailsSkipped} skipped`);
    
    return c.json({
      success: true,
      emailsSent,
      emailsSkipped,
      totalDeclines: declines.length
    });
  } catch (error: any) {
    console.error("Error processing decline email sequence:", error);
    return c.json({ error: "Failed to process email sequence" }, 500);
  }
});

// Manual trigger endpoint (for testing)
app.get("/make-server-cf244566/decline/send-test-sequence", async (c) => {
  console.log("üß™ Manually triggering decline email sequence...");
  
  // Call the main sequence endpoint
  const response = await app.request("/make-server-cf244566/decline/process-sequence", {
    method: "POST",
  });
  
  const data = await response.json();
  return c.json(data);
});

// ========== SUBSCRIPTION MANAGEMENT ENDPOINTS ==========

// Cancel a subscription
app.post("/make-server-cf244566/subscriptions/:subscriptionId/cancel", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }

  try {
    const subscriptionId = c.req.param("subscriptionId");
    
    console.log(`üö´ Canceling subscription: ${subscriptionId}`);
    
    // Cancel the subscription in Stripe
    const canceledSubscription = await stripe.subscriptions.cancel(subscriptionId);
    
    console.log(`‚úÖ Subscription canceled: ${subscriptionId}`);
    
    // Find and update the order
    const allOrderIds = (await kv.get("orders:all")) || [];
    for (const orderId of allOrderIds) {
      const order: any = await kv.get(`order:${orderId}`);
      if (order && order.subscriptionId === subscriptionId) {
        order.status = "canceled-refunded";
        order.subscriptionId = null;
        order.updatedAt = new Date().toISOString();
        await kv.set(`order:${orderId}`, order);
        
        // Send notification email
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        if (resendApiKey && order.customerInfo?.email) {
          try {
            await fetch("https://api.resend.com/emails", {
              method: "POST",
              headers: {
                "Authorization": `Bearer ${resendApiKey}`,
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                from: "Santa's Workshop <noreply@updates.santascertifiedletter.com>",
                to: [order.customerInfo.email],
                subject: "Subscription Canceled",
                html: `<div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;"><h2 style="color: #dc2626;">Subscription Canceled</h2><p>Hello ${order.customerInfo.name},</p><p>Your monthly Santa letter subscription has been canceled as requested.</p><p>You will not be charged again.</p><p>If this was done in error, please contact us.</p><p style="color: #dc2626;">üéÑ Thank you!</p></div>`,
              }),
            });
          } catch (error) {
            console.error("Failed to send cancellation email:", error);
          }
        }
        
        // Send SMS notification
        const twilioAccountSid = Deno.env.get("TWILIO_ACCOUNT_SID");
        const twilioAuthToken = Deno.env.get("TWILIO_AUTH_TOKEN");
        const twilioPhoneNumber = Deno.env.get("TWILIO_PHONE_NUMBER");
        
        if (twilioAccountSid && twilioAuthToken && twilioPhoneNumber && order.customerInfo?.phone) {
          try {
            const auth = btoa(`${twilioAccountSid}:${twilioAuthToken}`);
            await fetch(`https://api.twilio.com/2010-04-01/Accounts/${twilioAccountSid}/Messages.json`, {
              method: "POST",
              headers: {
                "Authorization": `Basic ${auth}`,
                "Content-Type": "application/x-www-form-urlencoded",
              },
              body: new URLSearchParams({
                To: order.customerInfo.phone,
                From: twilioPhoneNumber,
                Body: `Your Santa letter subscription has been canceled. You will not be charged again.`,
              }),
            });
          } catch (error) {
            console.error("Failed to send SMS:", error);
          }
        }
        
        break;
      }
    }
    
    return c.json({ 
      success: true,
      subscriptionId: canceledSubscription.id,
      status: canceledSubscription.status
    });
  } catch (error: any) {
    console.error("‚ùå Error canceling subscription:", error);
    return c.json({ error: "Failed to cancel subscription", details: error.message }, 500);
  }
});

// Create a new monthly order for a subscription (for testing/manual creation)
app.post("/make-server-cf244566/subscriptions/:subscriptionId/create-order", async (c) => {
  try {
    const subscriptionId = c.req.param("subscriptionId");
    
    console.log(`üì¶ Creating manual monthly order for subscription: ${subscriptionId}`);
    
    // Find the parent order with this subscription ID
    const allOrderIds = (await kv.get("orders:all")) || [];
    let parentOrder: any = null;
    
    for (const orderId of allOrderIds) {
      const order: any = await kv.get(`order:${orderId}`);
      if (order && order.subscriptionId === subscriptionId && order.monthlySubscription) {
        parentOrder = order;
        break;
      }
    }
    
    if (!parentOrder) {
      return c.json({ error: "Parent subscription order not found" }, 404);
    }
    
    // Increment successful charges on parent order
    parentOrder.successfulCharges = (parentOrder.successfulCharges || 0) + 1;
    parentOrder.subscriptionMonthsActive = parentOrder.successfulCharges;
    parentOrder.updatedAt = new Date().toISOString();
    
    // Add activity log
    if (!parentOrder.activityLog) {
      parentOrder.activityLog = [];
    }
    parentOrder.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Manual Order Created',
      details: `Created manual fulfillment order for month ${parentOrder.successfulCharges}`,
      user: 'Admin'
    });
    
    await kv.set(`order:${parentOrder.orderId}`, parentOrder);
    
    // Create new order ID
    const newOrderId = `ord_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    
    // Get subscription price from parent order
    const subscriptionPrice = parentOrder.subscriptionPrice || 12.00;
    const subscriptionProductName = parentOrder.subscriptionProductName || "Santa's Magical Journey";
    
    // Create new order for fulfillment
    const newOrder = {
      orderId: newOrderId,
      parentOrderId: parentOrder.orderId,
      subscriptionId: parentOrder.subscriptionId,
      sessionId: `manual_${newOrderId}`,
      stripePaymentId: null,
      stripeCheckoutUrl: null,
      orderDate: new Date().toISOString(),
      status: "pending",
      total: subscriptionPrice,
      customerInfo: parentOrder.customerInfo,
      letterPackages: parentOrder.letterPackages,
      numberOfPackages: parentOrder.numberOfPackages,
      shippingDate: "",
      monthlySubscription: false,
      subscriptionRecurringOrder: true,
      subscriptionMonth: parentOrder.successfulCharges,
      subscriptionProductName: subscriptionProductName,
      affiliateId: parentOrder.affiliateId,
      affiliateName: parentOrder.affiliateName,
      trackingNumber: null,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      activityLog: [{
        timestamp: new Date().toISOString(),
        action: 'Order Created',
        details: `Recurring subscription order - Month ${parentOrder.successfulCharges} (Manual)`,
        user: 'Admin'
      }]
    };
    
    // Save new order
    await kv.set(`order:${newOrderId}`, newOrder);
    
    // Add to orders index
    allOrderIds.push(newOrderId);
    await kv.set("orders:all", allOrderIds);
    
    console.log(`‚úÖ Created manual monthly order: ${newOrderId} for ${subscriptionProductName} at ${subscriptionPrice}`);
    
    return c.json({ 
      success: true,
      newOrderId,
      monthsActive: parentOrder.successfulCharges,
      productName: subscriptionProductName,
      price: subscriptionPrice
    });
  } catch (error: any) {
    console.error("‚ùå Error creating monthly order:", error);
    return c.json({ error: "Failed to create monthly order", details: error.message }, 500);
  }
});

// Alias endpoint for admin declined orders (matches frontend expectation)
app.get("/make-server-cf244566/admin/declined-orders", async (c) => {
  try {
    console.log("üìã Fetching declined orders (admin alias)...");
    
    const allDeclines = (await kv.get("all_declines")) || [];
    const declinedOrders = [];
    
    for (const declineId of allDeclines) {
      const decline = await kv.get(`decline:${declineId}`);
      if (decline) {
        declinedOrders.push(decline);
      }
    }
    
    declinedOrders.sort((a: any, b: any) => {
      return new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime();
    });
    
    console.log(`‚úÖ Found ${declinedOrders.length} declined orders`);
    
    return c.json({ declinedOrders });
  } catch (error: any) {
    console.error("‚ùå Error fetching declined orders:", error);
    return c.json({ error: "Failed to fetch declined orders", details: error.message }, 500);
  }
});

// ========== SUBSCRIPTION MANAGEMENT ENDPOINTS ==========

// Cancel subscription
app.post("/make-server-cf244566/subscriptions/:subscriptionId/cancel", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 500);
  }

  try {
    const subscriptionId = c.req.param("subscriptionId");
    const { orderId } = await c.req.json();
    
    console.log(`üö´ Canceling subscription: ${subscriptionId}`);
    
    // Get the order
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!order.subscriptionId) {
      return c.json({ error: "Order does not have a subscription" }, 400);
    }
    
    // Cancel subscription in Stripe
    const canceledSubscription = await stripe.subscriptions.cancel(subscriptionId);
    
    console.log(`‚úÖ Subscription canceled in Stripe: ${canceledSubscription.id}`);
    
    // Update order status but don't mark as canceled-refunded (only cancel future billing)
    order.subscriptionId = null; // Remove subscription ID
    order.subscriptionNextBillingDate = null;
    order.updatedAt = new Date().toISOString();
    
    // Add to activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Subscription Canceled',
      details: `Monthly subscription canceled by admin. Subscription ID: ${subscriptionId}`,
      user: 'Admin'
    });
    
    await kv.set(`order:${orderId}`, order);
    
    // Send notification
    await sendCancelSubscriptionNotification(order);
    
    return c.json({ 
      success: true,
      message: "Subscription canceled successfully",
      subscriptionId: canceledSubscription.id,
      status: canceledSubscription.status
    });
  } catch (error: any) {
    console.error("‚ùå Error canceling subscription:", error);
    return c.json({ 
      error: error.message || "Failed to cancel subscription",
      details: error.toString(),
    }, 500);
  }
});

// ========== DECLINED CHARGE RETRY AND DOWNSELL SYSTEM ==========

// Process declined charge retries (to be called daily via cron)
app.post("/make-server-cf244566/admin/process-retries", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 500);
  }

  try {
    console.log("üîÑ Processing declined charge retries...");
    
    const now = new Date();
    const allOrderIds = (await kv.get("orders:all")) || [];
    let retriesAttempted = 0;
    let retriesSucceeded = 0;
    let retriesFailed = 0;
    let downsellOffersSent = 0;
    
    for (const orderId of allOrderIds) {
      const order: any = await kv.get(`order:${orderId}`);
      
      // Skip if no subscription or no retry needed
      if (!order || !order.subscriptionId || !order.nextRetryDate) continue;
      
      // Skip if already offered downsell
      if (order.downsellOffered) continue;
      
      // Check if it's time to retry
      const nextRetry = new Date(order.nextRetryDate);
      if (nextRetry > now) continue;
      
      retriesAttempted++;
      
      console.log(`üîÅ Retrying charge for order ${orderId} (Attempt ${order.retryAttempts + 1})`);
      
      try {
        // Get subscription from Stripe
        const subscription = await stripe.subscriptions.retrieve(order.subscriptionId);
        
        if (subscription.status === "canceled") {
          console.log(`‚è≠Ô∏è Subscription canceled, skipping retry`);
          continue;
        }
        
        // Get payment method
        const defaultPaymentMethod = subscription.default_payment_method || 
                                      subscription.default_source;
        
        if (!defaultPaymentMethod) {
          console.log(`‚ö†Ô∏è No payment method on file`);
          retriesFailed++;
          continue;
        }
        
        const subscriptionPrice = order.subscriptionPrice || 12.00;
        
        // Attempt to charge
        const paymentIntent = await stripe.paymentIntents.create({
          amount: Math.round(subscriptionPrice * 100),
          currency: 'usd',
          customer: subscription.customer as string,
          payment_method: defaultPaymentMethod as string,
          off_session: true,
          confirm: true,
          description: `${order.subscriptionProductName || "Santa's Magical Journey"} - Retry Attempt ${order.retryAttempts + 1}`,
          metadata: {
            orderId: orderId,
            retryAttempt: String(order.retryAttempts + 1),
            subscriptionId: order.subscriptionId,
          },
        });
        
        if (paymentIntent.status === 'succeeded') {
          // Success! Reset retry counters
          retriesSucceeded++;
          order.retryAttempts = 0;
          order.firstFailureDate = null;
          order.lastFailureDate = null;
          order.nextRetryDate = null;
          order.lastChargeDate = new Date().toISOString();
          order.successfulCharges = (order.successfulCharges || 0) + 1;
          
          // Calculate next billing date
          const billingIntervalDays = order.billingIntervalDays || 30;
          const nextBilling = new Date();
          nextBilling.setDate(nextBilling.getDate() + billingIntervalDays);
          order.subscriptionNextBillingDate = nextBilling.toISOString();
          
          if (!order.activityLog) order.activityLog = [];
          order.activityLog.push({
            timestamp: new Date().toISOString(),
            action: 'Retry Charge Successful',
            details: `Retry attempt ${order.retryAttempts + 1} succeeded. Charged ${subscriptionPrice.toFixed(2)}`,
            user: 'System - Auto Retry'
          });
          
          await kv.set(`order:${orderId}`, order);
          
          // Send success email
          if (order.customerInfo?.email) {
            const childNames = order.letterPackages?.map((pkg: any) => pkg.childFirstName).join(' and ') || 'your child';
            await sendRetrySuccessEmail(order, childNames);
          }
          
          console.log(`‚úÖ Retry successful for order ${orderId}`);
        } else {
          // Failed again
          retriesFailed++;
          order.retryAttempts++;
          order.lastFailureDate = new Date().toISOString();
          
          // Check if we've hit 3 failures - send downsell offer
          if (order.retryAttempts >= 3 && !order.downsellOffered) {
            order.downsellOffered = true;
            order.downsellOfferedDate = new Date().toISOString();
            
            if (!order.activityLog) order.activityLog = [];
            order.activityLog.push({
              timestamp: new Date().toISOString(),
              action: 'Downsell Offer Sent',
              details: `After 3 failed attempts, sent downsell offer email`,
              user: 'System - Auto Retry'
            });
            
            await kv.set(`order:${orderId}`, order);
            
            // Send downsell offer email
            if (order.customerInfo?.email) {
              const childNames = order.letterPackages?.map((pkg: any) => pkg.childFirstName).join(' and ') || 'your child';
              await sendDownsellOfferEmail(order, childNames);
              downsellOffersSent++;
            }
            
            console.log(`üìß Downsell offer sent for order ${orderId}`);
          } else {
            // Schedule next retry in 2 days
            order.nextRetryDate = new Date(Date.now() + (48 * 60 * 60 * 1000)).toISOString();
            
            if (!order.activityLog) order.activityLog = [];
            order.activityLog.push({
              timestamp: new Date().toISOString(),
              action: 'Retry Charge Failed',
              details: `Retry attempt ${order.retryAttempts} failed. Next retry: ${new Date(order.nextRetryDate).toLocaleDateString()}`,
              user: 'System - Auto Retry'
            });
            
            await kv.set(`order:${orderId}`, order);
            
            // Send retry email
            if (order.customerInfo?.email) {
              const childNames = order.letterPackages?.map((pkg: any) => pkg.childFirstName).join(' and ') || 'your child';
              await sendRetryEmail(order, childNames, order.retryAttempts);
            }
            
            console.log(`‚ùå Retry failed for order ${orderId}, will retry again in 2 days`);
          }
        }
      } catch (error: any) {
        console.error(`‚ùå Error retrying charge for order ${orderId}:`, error);
        retriesFailed++;
        
        // Don't give up - schedule another retry
        order.nextRetryDate = new Date(Date.now() + (48 * 60 * 60 * 1000)).toISOString();
        await kv.set(`order:${orderId}`, order);
      }
    }
    
    console.log(`‚úÖ Retry processing complete: ${retriesAttempted} attempted, ${retriesSucceeded} succeeded, ${retriesFailed} failed, ${downsellOffersSent} downsell offers sent`);
    
    return c.json({
      success: true,
      retriesAttempted,
      retriesSucceeded,
      retriesFailed,
      downsellOffersSent
    });
  } catch (error: any) {
    console.error("‚ùå Error processing retries:", error);
    return c.json({ error: "Failed to process retries" }, 500);
  }
});

// Accept downsell offer
app.post("/make-server-cf244566/accept-downsell/:orderId", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 500);
  }

  try {
    const orderId = c.req.param("orderId");
    const { newPrice } = await c.req.json();
    
    console.log(`üí∞ Processing downsell acceptance for order ${orderId}: ${newPrice}`);
    
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!order.subscriptionId) {
      return c.json({ error: "No active subscription" }, 400);
    }
    
    // Validate price (must be between $8 and $12)
    const price = parseFloat(newPrice);
    if (isNaN(price) || price < 8 || price > 12) {
      return c.json({ error: "Invalid price. Must be between $8 and $12" }, 400);
    }
    
    // Update the order's subscription price
    const oldPrice = order.subscriptionPrice || 12.00;
    order.subscriptionPrice = price;
    order.downsellAccepted = true;
    order.downsellAcceptedDate = new Date().toISOString();
    order.downsellAcceptedPrice = price;
    order.retryAttempts = 0; // Reset retry counter
    order.nextRetryDate = null;
    
    if (!order.activityLog) order.activityLog = [];
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Downsell Accepted',
      details: `Customer accepted downsell from ${oldPrice.toFixed(2)} to ${price.toFixed(2)}/month`,
      user: 'Customer'
    });
    
    await kv.set(`order:${orderId}`, order);
    
    // Now try to charge the new lower price
    try {
      const subscription = await stripe.subscriptions.retrieve(order.subscriptionId);
      const defaultPaymentMethod = subscription.default_payment_method || subscription.default_source;
      
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(price * 100),
        currency: 'usd',
        customer: subscription.customer as string,
        payment_method: defaultPaymentMethod as string,
        off_session: true,
        confirm: true,
        description: `${order.subscriptionProductName || "Santa's Magical Journey"} - Downsell Accepted at ${price}`,
        metadata: {
          orderId: orderId,
          downsellPrice: String(price),
          subscriptionId: order.subscriptionId,
        },
      });
      
      if (paymentIntent.status === 'succeeded') {
        order.lastChargeDate = new Date().toISOString();
        order.successfulCharges = (order.successfulCharges || 0) + 1;
        
        // Calculate next billing
        const billingIntervalDays = order.billingIntervalDays || 30;
        const nextBilling = new Date();
        nextBilling.setDate(nextBilling.getDate() + billingIntervalDays);
        order.subscriptionNextBillingDate = nextBilling.toISOString();
        
        order.activityLog.push({
          timestamp: new Date().toISOString(),
          action: 'Downsell Payment Successful',
          details: `Charged ${price.toFixed(2)} after downsell acceptance`,
          user: 'System'
        });
        
        await kv.set(`order:${orderId}`, order);
        
        console.log(`‚úÖ Downsell payment successful for order ${orderId}`);
        
        return c.json({
          success: true,
          message: `Subscription updated to ${price.toFixed(2)}/month`,
          nextBillingDate: nextBilling.toISOString()
        });
      } else {
        return c.json({
          error: "Payment failed. Please update your payment method and try again.",
          paymentStatus: paymentIntent.status
        }, 400);
      }
    } catch (error: any) {
      console.error("‚ùå Error charging downsell price:", error);
      return c.json({
        error: "Failed to process payment. Please try again or contact support.",
        details: error.message
      }, 500);
    }
  } catch (error: any) {
    console.error("‚ùå Error accepting downsell:", error);
    return c.json({ error: "Failed to accept downsell offer" }, 500);
  }
});

// Helper function to send retry email
async function sendRetryEmail(order: any, childNames: string, attemptNumber: number) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  if (!resendApiKey) return;
  
  const emailHtml = `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
      <div style="background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
        <h1 style="margin: 0;">üéÖ Payment Issue - Action Needed</h1>
      </div>
      <div style="background: #ffffff; padding: 30px; border-radius: 0 0 10px 10px;">
        <p>Hi ${order.customerInfo.name},</p>
        
        <p>We tried to process your monthly subscription for <strong>${childNames}'s</strong> Letters from Santa, but we encountered a payment issue.</p>
        
        <div style="background: #fef3c7; padding: 20px; border-radius: 8px; border-left: 4px solid #f59e0b; margin: 20px 0;">
          <p style="margin: 0;"><strong>‚ö†Ô∏è We want to ship ${childNames}'s package!</strong></p>
          <p style="margin: 10px 0 0 0;">Please update your payment method so we can send this month's magical letter.</p>
        </div>
        
        <p>What to do:</p>
        <ul>
          <li>Check that your card hasn't expired</li>
          <li>Verify there are sufficient funds available</li>
          <li>Try a different payment method if needed</li>
        </ul>
        
        <div style="text-align: center; margin: 30px 0;">
          <a href="https://billing.stripe.com/p/login/${order.stripeCustomerId || ''}" 
             style="display: inline-block; background: #16a34a; color: white; padding: 15px 40px; text-decoration: none; border-radius: 8px; font-weight: bold; font-size: 18px;">
            üéÑ Update Payment Method
          </a>
        </div>
        
        <p style="color: #dc2626;"><strong>Don't let ${childNames} miss out on the magic!</strong></p>
        
        <p style="margin-top: 30px; color: #6b7280; font-size: 14px;">
          Need help? Reply to this email or contact our support team.
        </p>
      </div>
    </div>
  `;
  
  try {
    await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${resendApiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
        to: [order.customerInfo.email],
        subject: `üéÖ Payment Issue - ${childNames}'s Letter is Waiting!`,
        html: emailHtml,
      }),
    });
    console.log(`üìß Retry email sent to ${order.customerInfo.email}`);
  } catch (error) {
    console.error("‚ùå Failed to send retry email:", error);
  }
}

// Helper function to send retry success email
async function sendRetrySuccessEmail(order: any, childNames: string) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  if (!resendApiKey) return;
  
  const emailHtml = `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
      <div style="background: linear-gradient(135deg, #16a34a 0%, #15803d 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
        <h1 style="margin: 0;">‚úÖ Payment Successful!</h1>
      </div>
      <div style="background: #ffffff; padding: 30px; border-radius: 0 0 10px 10px;">
        <p>Hi ${order.customerInfo.name},</p>
        
        <p>Great news! Your payment has been processed successfully and <strong>${childNames}'s</strong> monthly letter from Santa is being prepared! üéÖ</p>
        
        <div style="background: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: center;">
          <p style="font-size: 24px; margin: 0; color: #16a34a;"><strong>${(order.subscriptionPrice || 12).toFixed(2)}</strong></p>
          <p style="margin: 5px 0 0 0;">Monthly Subscription</p>
        </div>
        
        <p>The magic continues! Your letter will be shipped soon.</p>
        
        <p style="color: #16a34a;"><strong>üéÑ Thank you for keeping the Christmas spirit alive!</strong></p>
      </div>
    </div>
  `;
  
  try {
    await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${resendApiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
        to: [order.customerInfo.email],
        subject: `üéÖ Payment Received - ${childNames}'s Letter is On The Way!`,
        html: emailHtml,
      }),
    });
    console.log(`üìß Success email sent to ${order.customerInfo.email}`);
  } catch (error) {
    console.error("‚ùå Failed to send success email:", error);
  }
}

// Helper function to send downsell offer email
async function sendDownsellOfferEmail(order: any, childNames: string) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  if (!resendApiKey) return;
  
  const currentPrice = order.subscriptionPrice || 12;
  const option1Price = 10;
  const option2Price = 8;
  
  const emailHtml = `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
      <div style="background: linear-gradient(135deg, #7c3aed 0%, #5b21b6 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
        <h1 style="margin: 0;">üéÅ Special Offer Just For You!</h1>
      </div>
      <div style="background: #ffffff; padding: 30px; border-radius: 0 0 10px 10px;">
        <p>Hi ${order.customerInfo.name},</p>
        
        <p>We really want ${childNames} to continue receiving magical letters from Santa! üéÖ</p>
        
        <p>We've noticed you've had some payment issues. We understand that sometimes budgets are tight, especially during the holidays.</p>
        
        <div style="background: #ede9fe; padding: 20px; border-radius: 8px; border-left: 4px solid #7c3aed; margin: 20px 0;">
          <p style="margin: 0;"><strong>üíú We'd like to offer you a special discount!</strong></p>
        </div>
        
        <p><strong>Choose the price that works best for you:</strong></p>
        
        <div style="background: #f9fafb; border: 2px solid #e5e7eb; border-radius: 8px; padding: 20px; margin: 15px 0;">
          <div style="text-align: center; margin-bottom: 15px;">
            <p style="font-size: 28px; color: #16a34a; margin: 0;"><strong>${option1Price}/month</strong></p>
            <p style="margin: 5px 0; color: #6b7280;">Save ${currentPrice - option1Price}/month</p>
          </div>
          <div style="text-align: center;">
            <a href="https://santascertifiedletter.com/accept-downsell/${order.orderId}?price=${option1Price}" 
               style="display: inline-block; background: #16a34a; color: white; padding: 12px 30px; text-decoration: none; border-radius: 8px; font-weight: bold;">
              Choose ${option1Price}/month
            </a>
          </div>
        </div>
        
        <div style="background: #f9fafb; border: 2px solid #e5e7eb; border-radius: 8px; padding: 20px; margin: 15px 0;">
          <div style="text-align: center; margin-bottom: 15px;">
            <p style="font-size: 28px; color: #dc2626; margin: 0;"><strong>${option2Price}/month</strong></p>
            <p style="margin: 5px 0; color: #6b7280;">Save ${currentPrice - option2Price}/month (Best Deal!)</p>
          </div>
          <div style="text-align: center;">
            <a href="https://santascertifiedletter.com/accept-downsell/${order.orderId}?price=${option2Price}" 
               style="display: inline-block; background: #dc2626; color: white; padding: 12px 30px; text-decoration: none; border-radius: 8px; font-weight: bold;">
              Choose ${option2Price}/month
            </a>
          </div>
        </div>
        
        <p style="text-align: center; margin-top: 30px; color: #6b7280; font-size: 14px;">
          <em>This special offer is only available for a limited time.</em>
        </p>
        
        <p style="color: #7c3aed;"><strong>üéÑ Keep the magic alive for ${childNames}!</strong></p>
        
        <p style="margin-top: 30px; color: #6b7280; font-size: 14px;">
          Questions? Reply to this email - we're here to help!
        </p>
      </div>
    </div>
  `;
  
  try {
    await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${resendApiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
        to: [order.customerInfo.email],
        subject: `üéÅ Special Offer: Discounted Letters from Santa for ${childNames}!`,
        html: emailHtml,
      }),
    });
    console.log(`üìß Downsell offer email sent to ${order.customerInfo.email}`);
  } catch (error) {
    console.error("‚ùå Failed to send downsell offer email:", error);
  }
}

// ========== STRIPE WEBHOOK FOR AUTO-BILLING ==========

// Webhook endpoint for Stripe events (handles automatic monthly billing)
app.post("/make-server-cf244566/stripe-webhook", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 500);
  }

  try {
    const body = await c.req.text();
    const signature = c.req.header("stripe-signature");
    const webhookSecret = Deno.env.get("STRIPE_WEBHOOK_SECRET");

    if (!webhookSecret) {
      console.error("‚ùå STRIPE_WEBHOOK_SECRET not configured");
      return c.json({ error: "Webhook secret not configured" }, 400);
    }

    // Verify webhook signature
    let event;
    try {
      event = stripe.webhooks.constructEvent(body, signature!, webhookSecret);
    } catch (err) {
      console.error("‚ùå Webhook signature verification failed:", err);
      return c.json({ error: "Invalid signature" }, 400);
    }

    console.log(`üîî Stripe webhook received: ${event.type}`);

    // Handle successful subscription invoice payment (monthly billing)
    if (event.type === "invoice.payment_succeeded") {
      const invoice = event.data.object as any;
      
      // Only process subscription invoices (not one-time payments)
      if (invoice.subscription) {
        console.log(`üí≥ Processing subscription payment: ${invoice.subscription}`);
        
        // Find the order with this subscription
        const allOrderIds = (await kv.get("orders:all")) || [];
        let subscriptionOrder = null;
        
        for (const orderId of allOrderIds) {
          const order: any = await kv.get(`order:${orderId}`);
          if (order && order.subscriptionId === invoice.subscription) {
            subscriptionOrder = order;
            break;
          }
        }
        
        if (subscriptionOrder) {
          // Create a new monthly order (copy of original but for this month)
          console.log(`üì¶ [Auto-Billing Webhook] Creating fulfillment order. Subscription letters count: ${(subscriptionOrder.subscriptionLetters || []).length}`);
          console.log(`üì¶ [Auto-Billing Webhook] Subscription letters data:`, JSON.stringify(subscriptionOrder.subscriptionLetters));
          
          const newOrderId = `order_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          const currentDate = new Date().toISOString();
          
          // Generate new secure access token
          const accessToken = `oat_${Array.from(crypto.getRandomValues(new Uint8Array(32)))
            .map(b => b.toString(16).padStart(2, '0'))
            .join('')}`;
          
          const monthlyOrder = {
            ...subscriptionOrder,
            orderId: newOrderId,
            orderDate: currentDate,
            accessToken: accessToken,
            status: 'pending',
            total: 12.00, // Monthly subscription amount
            letters: subscriptionOrder.subscriptionLetters || [], // Copy subscription letter data for fulfillment
            stripePaymentId: invoice.payment_intent,
            stripeCheckoutUrl: `https://dashboard.stripe.com/${invoice.payment_intent?.startsWith('pi_test') ? 'test' : 'live'}/payments/${invoice.payment_intent}`,
            subscriptionMonthsActive: (subscriptionOrder.subscriptionMonthsActive || 0) + 1,
            activityLog: [{
              timestamp: currentDate,
              action: 'Monthly Order Created',
              details: `Automatic monthly billing processed. Amount: $12.00. Copied ${(subscriptionOrder.subscriptionLetters || []).length} letter(s) from subscription.`,
              user: 'System'
            }],
            createdAt: currentDate,
            updatedAt: currentDate
          };
          
          // Save new monthly order
          await kv.set(`order:${newOrderId}`, monthlyOrder);
          await kv.set(`token:${accessToken}`, newOrderId);
          
          // Add to orders index
          const allOrderIds = (await kv.get("orders:all")) || [];
          allOrderIds.push(newOrderId);
          await kv.set("orders:all", allOrderIds);
          
          // Update original subscription order
          subscriptionOrder.subscriptionMonthsActive = (subscriptionOrder.subscriptionMonthsActive || 0) + 1;
          subscriptionOrder.updatedAt = currentDate;
          await kv.set(`order:${subscriptionOrder.orderId}`, subscriptionOrder);
          
          console.log(`‚úÖ Created automatic monthly order: ${newOrderId}`);
          
          // Send customer notification about their monthly letter
          await sendMonthlyLetterNotification(monthlyOrder);
        }
      }
    }
    
    // Handle failed subscription invoice payment (declined charges)
    if (event.type === "invoice.payment_failed") {
      const invoice = event.data.object as any;
      
      // Only process subscription invoices
      if (invoice.subscription) {
        console.log(`‚ùå Subscription payment failed: ${invoice.subscription}`);
        
        // Find the order with this subscription
        const allOrderIds = (await kv.get("orders:all")) || [];
        let subscriptionOrder = null;
        
        for (const orderId of allOrderIds) {
          const order: any = await kv.get(`order:${orderId}`);
          if (order && order.subscriptionId === invoice.subscription) {
            subscriptionOrder = order;
            break;
          }
        }
        
        if (subscriptionOrder) {
          // Initialize retry tracking if not exists
          if (!subscriptionOrder.retryAttempts) {
            subscriptionOrder.retryAttempts = 0;
            subscriptionOrder.firstFailureDate = new Date().toISOString();
          }
          
          subscriptionOrder.retryAttempts++;
          subscriptionOrder.lastFailureDate = new Date().toISOString();
          subscriptionOrder.nextRetryDate = new Date(Date.now() + (48 * 60 * 60 * 1000)).toISOString(); // Retry in 2 days
          
          // Add to activity log
          if (!subscriptionOrder.activityLog) {
            subscriptionOrder.activityLog = [];
          }
          subscriptionOrder.activityLog.push({
            timestamp: new Date().toISOString(),
            action: 'Payment Failed',
            details: `Subscription payment declined. Attempt ${subscriptionOrder.retryAttempts}. Next retry: ${new Date(subscriptionOrder.nextRetryDate).toLocaleDateString()}`,
            user: 'System - Webhook'
          });
          
          await kv.set(`order:${subscriptionOrder.orderId}`, subscriptionOrder);
          
          console.log(`üìù Tracked failed payment for order ${subscriptionOrder.orderId} - Attempt ${subscriptionOrder.retryAttempts}`);
          
          // Schedule retry email (will be sent by cron job)
        }
      }
    }

    return c.json({ received: true });
  } catch (error: any) {
    console.error("‚ùå Error processing webhook:", error);
    return c.json({ error: "Webhook processing failed" }, 500);
  }
});

// Helper function to send monthly letter notification
async function sendMonthlyLetterNotification(order: any) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  const twilioAccountSid = Deno.env.get("TWILIO_ACCOUNT_SID");
  const twilioAuthToken = Deno.env.get("TWILIO_AUTH_TOKEN");
  const twilioPhoneNumber = Deno.env.get("TWILIO_PHONE_NUMBER");

  if (resendApiKey) {
    try {
      await fetch("https://api.resend.com/emails", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${resendApiKey}`,
        },
        body: JSON.stringify({
          from: "Santa's Workshop <noreply@updates.santascertifiedletter.com>",
          to: [order.customerInfo.email],
          subject: "üéÖ Your Monthly Letter from Santa is Coming!",
          html: `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
              <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÖ Santa's Magical Adventures</h1>
                <p style="margin: 10px 0 0 0; font-size: 18px;">Your Monthly Letter is On Its Way!</p>
              </div>
              <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                <p>Ho ho ho! ${order.customerInfo.name},</p>
                
                <p style="font-size: 18px;"><span style="font-size: 24px;">üéâ</span> Your monthly subscription has been renewed and your Santa letter is being prepared!</p>
                
                <div style="background-color: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0;">
                  <p><strong>Order:</strong> #${order.orderId.slice(-8)}</p>
                  <p><strong>Date:</strong> ${new Date(order.orderDate).toLocaleDateString()}</p>
                  <p><strong>Amount:</strong> ${order.total.toFixed(2)}</p>
                  <p><strong>Month:</strong> ${order.subscriptionMonthsActive}</p>
                </div>
                
                <p><strong>What's happening next?</strong></p>
                <ul style="line-height: 1.8;">
                  <li>‚ú® Santa is writing your personalized letter</li>
                  <li>üìù It will include updates on your good behavior and special activities</li>
                  <li>üìÆ Your letter will be mailed within the next few days</li>
                  <li>üìß You'll get tracking information once it ships</li>
                </ul>
                
                <p style="margin-top: 30px; text-align: center;">
                  <span style="font-size: 24px;">üéÑ</span> <strong>Keep up the great work!</strong> <span style="font-size: 24px;">üéÑ</span>
                </p>
              </div>
            </div>
          `,
        }),
      });
    } catch (error) {
      console.error("‚ùå Failed to send monthly notification email:", error);
    }
  }

  if (twilioAccountSid && twilioAuthToken && twilioPhoneNumber && order.customerInfo.phone) {
    try {
      const auth = btoa(`${twilioAccountSid}:${twilioAuthToken}`);
      await fetch(`https://api.twilio.com/2010-04-01/Accounts/${twilioAccountSid}/Messages.json`, {
        method: "POST",
        headers: {
          "Authorization": `Basic ${auth}`,
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: new URLSearchParams({
          To: order.customerInfo.phone,
          From: twilioPhoneNumber,
          Body: `üéÖ Ho ho ho! Your monthly Santa letter has been renewed and is being prepared. Order #${order.orderId.slice(-8)} - Month ${order.subscriptionMonthsActive}`,
        }),
      });
    } catch (error) {
      console.error("‚ùå Failed to send monthly notification SMS:", error);
    }
  }
}

// ========== PAYMENT METHOD UPDATE ENDPOINTS ==========

// Get order/subscription details for payment update (by encrypted token)
app.get("/make-server-cf244566/get-order-for-update/:token", async (c) => {
  try {
    const token = c.req.param("token");
    console.log(`üîç Looking up order for payment update with token: ${token}`);
    
    // Token could be either:
    // 1. A decline ID (starts with "decline_")
    // 2. An order access token (starts with "oat_")
    // 3. A special update token (starts with "upt_")
    
    let orderData: any = null;
    let declineData: any = null;
    
    // Try to find by decline ID
    if (token.startsWith("decline_")) {
      declineData = await kv.get(`decline:${token}`);
      if (declineData) {
        console.log(`‚úÖ Found decline record: ${token}`);
        
        // Return order details from decline data
        const packageCount = declineData.letterPackages?.length || 1;
        const totalAmount = declineData.amount || 0;
        const pricePerPackage = packageCount > 0 ? (totalAmount / packageCount) : 17.95;
        
        return c.json({
          success: true,
          order: {
            orderId: token,
            customerInfo: {
              name: declineData.customerInfo?.name || "",
              email: declineData.customerInfo?.email || "",
              phone: declineData.customerInfo?.phone || "",
              address: declineData.customerInfo?.address || "",
              city: declineData.customerInfo?.city || "",
              state: declineData.customerInfo?.state || "",
              zip: declineData.customerInfo?.zip || "",
            },
            letterPackages: declineData.letterPackages || [],
            total: totalAmount,
            packagePrice: pricePerPackage,
            monthlySubscription: declineData.monthlySubscription || false,
            subscriptionId: declineData.subscriptionId || null,
            stripeCustomerId: declineData.stripeCustomerId || null,
            lastFourCard: declineData.lastFourCard || null,
            declineReason: declineData.declineReason || "Payment failed",
          }
        });
      }
    }
    
    // Try to find by order access token
    if (token.startsWith("oat_")) {
      const allOrderIds = (await kv.get("orders:all")) || [];
      for (const orderId of allOrderIds) {
        const order: any = await kv.get(`order:${orderId}`);
        if (order && order.accessToken === token) {
          orderData = order;
          break;
        }
      }
    }
    
    // Try to find by custom update token
    if (token.startsWith("upt_")) {
      const updateTokenData = await kv.get(`update_token:${token}`);
      if (updateTokenData) {
        const orderId = (updateTokenData as any).orderId;
        orderData = await kv.get(`order:${orderId}`);
      }
    }
    
    if (!orderData) {
      console.log(`‚ùå Order not found for token: ${token}`);
      return c.json({ error: "Order not found or link expired" }, 404);
    }
    
    console.log(`‚úÖ Found order: ${orderData.orderId}`);
    
    // Return sanitized order details
    const packageCount = orderData.letterPackages?.length || 1;
    const totalAmount = orderData.subscriptionPrice || orderData.total || 0;
    const pricePerPackage = packageCount > 0 ? (totalAmount / packageCount) : 17.95;
    
    return c.json({
      success: true,
      order: {
        orderId: orderData.orderId,
        customerInfo: {
          name: orderData.customerInfo?.name || "",
          email: orderData.customerInfo?.email || "",
          phone: orderData.customerInfo?.phone || "",
          address: orderData.customerInfo?.address || "",
          city: orderData.customerInfo?.city || "",
          state: orderData.customerInfo?.state || "",
          zip: orderData.customerInfo?.zip || "",
        },
        letterPackages: orderData.letterPackages || [],
        total: totalAmount,
        packagePrice: pricePerPackage,
        monthlySubscription: orderData.monthlySubscription || false,
        subscriptionId: orderData.subscriptionId || null,
        stripeCustomerId: orderData.stripeCustomerId || null,
        lastFourCard: orderData.lastFourCard || null,
        nextBillingDate: orderData.subscriptionNextBillingDate || null,
      }
    });
  } catch (error: any) {
    console.error("‚ùå Error fetching order for update:", error);
    return c.json({ error: "Failed to load order details" }, 500);
  }
});

// Update payment method and charge
app.post("/make-server-cf244566/update-payment-method", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }
  
  try {
    const { token, paymentMethodId, updatedOrderData } = await c.req.json();
    
    console.log(`üí≥ Updating payment method for token: ${token}`);
    console.log(`üìù Updated order data received:`, updatedOrderData ? 'Yes' : 'No');
    
    // Get order/decline details
    let orderData: any = null;
    let declineData: any = null;
    let isDecline = false;
    
    // Check if it's a decline
    if (token.startsWith("decline_")) {
      declineData = await kv.get(`decline:${token}`);
      isDecline = true;
      
      if (!declineData) {
        return c.json({ error: "Decline record not found" }, 404);
      }
      
      // Find associated order if exists
      const allOrderIds = (await kv.get("orders:all")) || [];
      for (const orderId of allOrderIds) {
        const order: any = await kv.get(`order:${orderId}`);
        if (order && order.customerInfo?.email === declineData.customerInfo?.email && 
            order.subscriptionId === declineData.subscriptionId) {
          orderData = order;
          break;
        }
      }
    } else {
      // Get order by token
      if (token.startsWith("oat_")) {
        const allOrderIds = (await kv.get("orders:all")) || [];
        for (const orderId of allOrderIds) {
          const order: any = await kv.get(`order:${orderId}`);
          if (order && order.accessToken === token) {
            orderData = order;
            break;
          }
        }
      } else if (token.startsWith("upt_")) {
        const updateTokenData = await kv.get(`update_token:${token}`);
        if (updateTokenData) {
          const orderId = (updateTokenData as any).orderId;
          orderData = await kv.get(`order:${orderId}`);
        }
      }
      
      if (!orderData) {
        return c.json({ error: "Order not found" }, 404);
      }
    }
    
    // Apply updates to order/decline data if provided
    if (updatedOrderData) {
      console.log(`üìù Applying order updates...`);
      
      if (updatedOrderData.letterPackages) {
        if (orderData) {
          orderData.letterPackages = updatedOrderData.letterPackages;
          // Use provided total or keep existing price per package calculation
          if (updatedOrderData.total) {
            orderData.total = updatedOrderData.total;
            orderData.subscriptionPrice = updatedOrderData.total;
          }
        }
        if (declineData) {
          declineData.letterPackages = updatedOrderData.letterPackages;
          if (updatedOrderData.total) {
            declineData.amount = updatedOrderData.total;
          }
        }
      }
      
      if (updatedOrderData.customerInfo) {
        if (orderData) {
          orderData.customerInfo = { ...orderData.customerInfo, ...updatedOrderData.customerInfo };
        }
        if (declineData) {
          declineData.customerInfo = { ...declineData.customerInfo, ...updatedOrderData.customerInfo };
        }
      }
      
      // Save updated data
      if (orderData) {
        await kv.set(`order:${orderData.orderId}`, orderData);
        console.log(`‚úÖ Updated order data saved with total: ${orderData.total}`);
      }
      if (declineData && isDecline) {
        await kv.set(`decline:${token}`, declineData);
        console.log(`‚úÖ Updated decline data saved with amount: ${declineData.amount}`);
      }
    }
    
    // Get customer ID
    let customerId = orderData?.stripeCustomerId || declineData?.stripeCustomerId;
    const customerEmail = orderData?.customerInfo?.email || declineData?.customerInfo?.email;
    const customerName = orderData?.customerInfo?.name || declineData?.customerInfo?.name;
    
    // If no customer exists, create one
    if (!customerId) {
      console.log(`üÜï Creating new Stripe customer for: ${customerEmail}`);
      const customer = await stripe.customers.create({
        email: customerEmail,
        name: customerName,
        payment_method: paymentMethodId,
        invoice_settings: {
          default_payment_method: paymentMethodId,
        },
      });
      customerId = customer.id;
      
      // Update order with customer ID
      if (orderData) {
        orderData.stripeCustomerId = customerId;
        await kv.set(`order:${orderData.orderId}`, orderData);
      }
    } else {
      // Attach payment method to existing customer
      console.log(`üîó Attaching payment method to customer: ${customerId}`);
      await stripe.paymentMethods.attach(paymentMethodId, {
        customer: customerId,
      });
      
      // Set as default payment method
      await stripe.customers.update(customerId, {
        invoice_settings: {
          default_payment_method: paymentMethodId,
        },
      });
    }
    
    // Get payment method details for last 4
    const paymentMethod = await stripe.paymentMethods.retrieve(paymentMethodId);
    const lastFourCard = paymentMethod.card?.last4 || null;
    
    // Determine amount to charge
    const amount = isDecline ? (declineData.amount || 12) : (orderData.subscriptionPrice || orderData.total || 12);
    
    console.log(`üí∞ Creating payment intent for ${amount}`);
    
    // Create payment intent
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(amount * 100),
      currency: "usd",
      customer: customerId,
      payment_method: paymentMethodId,
      off_session: false,
      confirm: true,
      description: isDecline ? 
        `Recovery payment for declined order` : 
        `Subscription payment - Payment method update`,
      metadata: {
        orderId: orderData?.orderId || token,
        paymentUpdate: "true",
        declineId: isDecline ? token : undefined,
      },
      return_url: `https://santascertifiedletter.com/?page=updatepayment&token=${token}`,
    });
    
    // Check if requires additional action
    if (paymentIntent.status === "requires_action" && paymentIntent.client_secret) {
      console.log(`‚ö†Ô∏è Payment requires additional authentication`);
      return c.json({
        success: false,
        requiresAction: true,
        clientSecret: paymentIntent.client_secret,
        paymentIntentId: paymentIntent.id,
      });
    }
    
    // If payment succeeded immediately
    if (paymentIntent.status === "succeeded") {
      console.log(`‚úÖ Payment succeeded immediately`);
      
      // Create new order or update existing
      const newOrderId = await createOrderFromPaymentUpdate(
        orderData,
        declineData,
        paymentIntent,
        customerId,
        lastFourCard,
        amount
      );
      
      // Update decline record if applicable
      if (isDecline && declineData) {
        declineData.status = "converted";
        declineData.convertedDate = new Date().toISOString();
        declineData.convertedOrderId = newOrderId;
        await kv.set(`decline:${token}`, declineData);
      }
      
      // Update order if applicable
      if (orderData) {
        orderData.lastFourCard = lastFourCard;
        orderData.updatedAt = new Date().toISOString();
        
        // Reset retry counters
        orderData.retryAttempts = 0;
        orderData.firstFailureDate = null;
        orderData.lastFailureDate = null;
        orderData.nextRetryDate = null;
        
        if (!orderData.activityLog) orderData.activityLog = [];
        orderData.activityLog.push({
          timestamp: new Date().toISOString(),
          action: "Payment Method Updated",
          details: `Customer updated payment method. New card: ****${lastFourCard}. Charged ${amount.toFixed(2)}`,
          user: "Customer"
        });
        
        await kv.set(`order:${orderData.orderId}`, orderData);
      }
      
      // Send payment method update confirmation email
      try {
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        const emailTo = customerEmail || orderData?.customerInfo?.email;
        
        if (resendApiKey && emailTo) {
          const emailHtml = `
            <!DOCTYPE html>
            <html>
            <head>
              <meta charset="utf-8">
              <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
            </head>
            <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
              <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                  <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">‚úÖ Payment Method Updated!</h1>
                </div>
                <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                  <p>Hi ${customerName || 'there'},</p>
                  
                  <p style="font-size: 18px; color: #059669;"><strong>‚úÖ Your payment method has been successfully updated!</strong></p>
                  
                  <div style="background: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #16a34a;">
                    <p style="margin: 0 0 10px 0;"><strong>üí≥ New Payment Method:</strong></p>
                    <p style="font-size: 18px; margin: 0; color: #16a34a;">Card ending in ****${lastFourCard}</p>
                    <p style="margin: 10px 0 0 0; font-size: 14px; color: #166534;">
                      Amount charged: ${amount.toFixed(2)}
                    </p>
                  </div>
                  
                  ${orderData?.monthlySubscription || declineData?.subscriptionId ? `
                    <div style="background: #dbeafe; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #3b82f6;">
                      <p style="margin: 0 0 10px 0;"><strong>üéÖ Subscription Active</strong></p>
                      <p style="margin: 5px 0; font-size: 14px;">Your monthly subscription is now active and will be charged to your new payment method.</p>
                      ${orderData?.subscriptionNextBillingDate ? `
                        <p style="margin: 10px 0 0 0; font-size: 13px; color: #1e40af;">
                          Next billing date: ${new Date(orderData.subscriptionNextBillingDate).toLocaleDateString()}
                        </p>
                      ` : ''}
                    </div>
                  ` : ''}
                  
                  <div style="background: #f9fafb; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <p style="margin: 0 0 10px 0;"><strong>üìã What This Means:</strong></p>
                    <ul style="margin: 10px 0; padding-left: 20px; font-size: 14px;">
                      <li>Your new card is now saved and set as default</li>
                      <li>All future charges will use this payment method</li>
                      <li>You're all set - no further action needed!</li>
                    </ul>
                  </div>
                  
                  <div style="background: #fef2f2; padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #dc2626;">
                    <p style="margin: 0; font-size: 13px;">
                      <strong>üîí Security:</strong> For your protection, we never store your full card number. Only the last 4 digits are kept for reference.
                    </p>
                  </div>
                  
                  <p style="margin-top: 30px;">Thank you for keeping your payment information up to date!</p>
                  
                  <p style="margin-top: 20px;">Questions? Contact us at support@letterfromsanta.com</p>
                  
                  <p style="margin-top: 30px;">Merry Christmas! ‚ú®<br>The Santa Letters Team</p>
                </div>
                <div style="background: #f9fafb; padding: 20px; text-align: center; color: #6b7280; font-size: 14px; border-radius: 0 0 10px 10px;">
                  <p style="margin: 0;">¬© ${new Date().getFullYear()} Letter From Santa. All rights reserved.</p>
                </div>
              </div>
            </body>
            </html>
          `;

          const response = await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${resendApiKey}`,
            },
            body: JSON.stringify({
              from: "Santa's Workshop <noreply@letterfromsanta.com>",
              to: [emailTo],
              subject: "‚úÖ Payment Method Updated Successfully",
              html: emailHtml,
            }),
          });

          if (response.ok) {
            console.log("‚úÖ Payment method update email sent to:", emailTo);
          } else {
            const errorText = await response.text();
            console.error("‚ùå Failed to send payment update email:", errorText);
          }
        }
      } catch (emailError) {
        console.error("‚ùå Error sending payment method update email:", emailError);
      }
      
      return c.json({
        success: true,
        orderId: newOrderId,
        message: "Payment method updated and charged successfully"
      });
    }
    
    // If payment failed
    if (paymentIntent.status === "requires_payment_method" || paymentIntent.status === "canceled") {
      console.log(`‚ùå Payment failed: ${paymentIntent.status}`);
      
      // Get detailed error message
      const errorMessage = paymentIntent.last_payment_error?.message || 
                          paymentIntent.last_payment_error?.decline_code || 
                          "Your payment was declined. Please try a different card.";
      
      const declineCode = paymentIntent.last_payment_error?.decline_code;
      
      console.log(`‚ùå Decline reason: ${errorMessage}`);
      console.log(`‚ùå Decline code: ${declineCode}`);
      
      return c.json({
        success: false,
        error: errorMessage,
        declineCode: declineCode,
        paymentIntentId: paymentIntent.id
      }, 402);
    }
    
    // If payment is still processing
    return c.json({
      success: false,
      error: "Payment is processing. Please wait...",
      paymentIntentId: paymentIntent.id
    }, 202);
    
  } catch (error: any) {
    console.error("‚ùå Error updating payment method:", error);
    return c.json({ 
      error: error.message || "Failed to update payment method",
      details: error.raw?.message 
    }, 500);
  }
});

// Confirm payment after 3D Secure
app.post("/make-server-cf244566/confirm-payment-update", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }
  
  try {
    const { token, paymentIntentId } = await c.req.json();
    
    console.log(`‚úÖ Confirming payment update: ${paymentIntentId}`);
    
    // Retrieve payment intent
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
    
    if (paymentIntent.status !== "succeeded") {
      return c.json({ error: "Payment not completed" }, 400);
    }
    
    // Get order/decline details
    let orderData: any = null;
    let declineData: any = null;
    let isDecline = false;
    
    if (token.startsWith("decline_")) {
      declineData = await kv.get(`decline:${token}`);
      isDecline = true;
    } else {
      const allOrderIds = (await kv.get("orders:all")) || [];
      for (const orderId of allOrderIds) {
        const order: any = await kv.get(`order:${orderId}`);
        if (order && order.accessToken === token) {
          orderData = order;
          break;
        }
      }
    }
    
    // Get payment method details
    const paymentMethod = await stripe.paymentMethods.retrieve(paymentIntent.payment_method as string);
    const lastFourCard = paymentMethod.card?.last4 || null;
    const customerId = paymentIntent.customer as string;
    const amount = paymentIntent.amount / 100;
    
    // Create order
    const newOrderId = await createOrderFromPaymentUpdate(
      orderData,
      declineData,
      paymentIntent,
      customerId,
      lastFourCard,
      amount
    );
    
    // Update records
    if (isDecline && declineData) {
      declineData.status = "converted";
      declineData.convertedDate = new Date().toISOString();
      declineData.convertedOrderId = newOrderId;
      await kv.set(`decline:${token}`, declineData);
    }
    
    if (orderData) {
      orderData.lastFourCard = lastFourCard;
      orderData.updatedAt = new Date().toISOString();
      orderData.retryAttempts = 0;
      orderData.firstFailureDate = null;
      orderData.lastFailureDate = null;
      orderData.nextRetryDate = null;
      
      if (!orderData.activityLog) orderData.activityLog = [];
      orderData.activityLog.push({
        timestamp: new Date().toISOString(),
        action: "Payment Method Updated",
        details: `Customer updated payment method after 3DS. New card: ****${lastFourCard}. Charged ${amount.toFixed(2)}`,
        user: "Customer"
      });
      
      await kv.set(`order:${orderData.orderId}`, orderData);
    }
    
    return c.json({
      success: true,
      orderId: newOrderId,
      message: "Payment confirmed and order created"
    });
    
  } catch (error: any) {
    console.error("‚ùå Error confirming payment update:", error);
    return c.json({ error: error.message || "Failed to confirm payment" }, 500);
  }
});

// Helper function to create order from payment update
async function createOrderFromPaymentUpdate(
  existingOrder: any,
  declineData: any,
  paymentIntent: any,
  customerId: string,
  lastFourCard: string | null,
  amount: number
): Promise<string> {
  const orderId = `order_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const orderDate = new Date().toISOString();
  
  // Generate access token
  const accessToken = `oat_${Array.from(crypto.getRandomValues(new Uint8Array(32)))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('')}`;
  
  // Use existing order data or decline data
  const sourceData = existingOrder || declineData;
  
  const orderData = {
    orderId,
    orderDate,
    accessToken,
    stripePaymentId: paymentIntent.id,
    stripeCheckoutUrl: `https://dashboard.stripe.com/${paymentIntent.id.startsWith('pi_test') ? 'test' : 'live'}/payments/${paymentIntent.id}`,
    status: "unfulfilled",
    total: amount,
    customerInfo: sourceData.customerInfo,
    letterPackages: sourceData.letterPackages || [],
    numberOfPackages: sourceData.letterPackages?.length || 0,
    shippingDate: sourceData.shippingDate || "",
    monthlySubscription: sourceData.monthlySubscription || false,
    subscriptionId: sourceData.subscriptionId || null,
    stripeCustomerId: customerId,
    subscriptionMonthsActive: existingOrder ? (existingOrder.subscriptionMonthsActive || 0) + 1 : 0,
    subscriptionStartDate: existingOrder?.subscriptionStartDate || orderDate,
    subscriptionNextBillingDate: existingOrder ? calculateNextBillingDate(existingOrder.billingIntervalDays || 30) : undefined,
    billingIntervalDays: existingOrder?.billingIntervalDays || 30,
    affiliateId: existingOrder?.affiliateId || null,
    affiliateName: existingOrder?.affiliateName || null,
    affiliateCommission: existingOrder?.affiliateId ? amount * 0.10 : null,
    lastFourCard: lastFourCard,
    trafficSource: existingOrder?.trafficSource || "direct",
    parentOrderId: existingOrder?.orderId || null,
    activityLog: [{
      timestamp: orderDate,
      action: "Order Created",
      details: `Payment method updated and charged ${amount.toFixed(2)}`,
      user: "Customer"
    }],
    archived: false,
    createdAt: orderDate,
    updatedAt: orderDate
  };
  
  await kv.set(`order:${orderId}`, orderData);
  
  // Add to orders list
  const allOrderIds = (await kv.get("orders:all")) || [];
  allOrderIds.push(orderId);
  await kv.set("orders:all", allOrderIds);
  
  // Send confirmation email
  await sendPaymentUpdateConfirmationEmail(orderData);
  
  console.log(`‚úÖ Created order from payment update: ${orderId}`);
  
  return orderId;
}

// Helper to calculate next billing date
function calculateNextBillingDate(intervalDays: number): string {
  const nextDate = new Date();
  nextDate.setDate(nextDate.getDate() + intervalDays);
  return nextDate.toISOString();
}

// Helper to send payment update confirmation email
async function sendPaymentUpdateConfirmationEmail(order: any) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  if (!resendApiKey) return;
  
  const emailHtml = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
    </head>
    <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
      <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
          <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÖ Payment Updated Successfully!</h1>
        </div>
        <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
          <p>Hi ${order.customerInfo.name},</p>
          
          <p style="font-size: 18px; color: #059669;"><strong>‚úÖ Your payment method has been updated and your order is being processed!</strong></p>
          
          <div style="background: #f0fdf4; border-left: 4px solid #059669; padding: 15px; margin: 20px 0;">
            <p style="margin: 0; font-size: 16px;"><strong>Order Details:</strong></p>
            <p style="margin: 5px 0 0 0;">Order #${order.orderId.slice(-8)}</p>
            <p style="margin: 5px 0 0 0;">Amount: ${order.total.toFixed(2)}</p>
          </div>
          
          <p><strong>Your letter packages:</strong></p>
          <ul style="background: #f3f4f6; padding: 20px; border-radius: 8px;">
            ${order.letterPackages.map((pkg: any) => `
              <li style="margin: 10px 0;">
                Letter for <strong>${pkg.childFirstName} ${pkg.childLastName}</strong>
              </li>
            `).join('')}
          </ul>
          
          ${order.monthlySubscription ? `
            <div style="background: #dbeafe; border-left: 4px solid #3b82f6; padding: 15px; margin: 20px 0;">
              <p style="margin: 0; font-size: 16px;"><strong>üìÖ Monthly Subscription Active</strong></p>
              <p style="margin: 5px 0 0 0;">You'll continue receiving magical letters monthly.</p>
            </div>
          ` : ''}
          
          <p style="margin-top: 30px; color: #6b7280; font-size: 14px;">
            Your letters are being prepared and will ship soon. We'll send you tracking information shortly!
          </p>
        </div>
        <div style="background: #f9fafb; padding: 20px; text-align: center; color: #6b7280; font-size: 12px; border-radius: 0 0 10px 10px;">
          <p>Questions? Contact us at support@santascertifiedletter.com</p>
          <p style="margin-top: 10px; color: #9ca3af;">¬© 2025 Letters From Santa. All rights reserved.</p>
        </div>
      </div>
    </body>
    </html>
  `;
  
  try {
    await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${resendApiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        from: EMAIL_FROM,
        to: [order.customerInfo.email],
        subject: "üéÖ Payment Updated - Your Santa Letters Are On The Way!",
        html: emailHtml,
      }),
    });
    console.log(`üìß Payment update confirmation email sent to ${order.customerInfo.email}`);
  } catch (error) {
    console.error("‚ùå Failed to send payment update email:", error);
  }
}

// ============================================
// UPSELL FUNNEL ROUTES
// ============================================

// Get active upsells for admin
app.get("/make-server-cf244566/admin/upsells", async (c) => {
  try {
    const allUpsellIds = (await kv.get("upsells:all")) || [];
    const upsells = [];
    
    // If no upsells exist, create the default products
    if (allUpsellIds.length === 0) {
      const defaultSnowUpsell = {
        id: "upsell_north_pole_snow",
        name: "Certified North Pole Snow",
        description: "Authentic snow from the North Pole! Our premium certified snow powder expands up to 100x its size when water is added. Direct from Santa's workshop - perfect for Christmas decorations, crafts, and creating memorable Santa experiences!",
        price: 9.99,
        imageUrl: "figma:asset/17a13766bc697fc8dd73632f6223611df59e7213.png",
        active: true,
        promoText: "üéÑ SPECIAL OFFER: Add authentic North Pole snow to your Santa experience!",
        features: [
          "Certified authentic from the North Pole",
          "Expands up to 100x its original size",
          "Looks and feels like real snow",
          "Safe, non-toxic, and reusable",
          "Perfect for Christmas decorations and photos",
          "Makes approximately 2 gallons of snow"
        ],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
      
      const subscriptionUpsell = {
        id: "upsell_magical_journey",
        name: "Santa's Magical Journey",
        description: "Join Santa's Magical Journey and receive a personalized letter every month! Watch your child's excitement grow as Santa shares his adventures from around the world.",
        price: 12.00,
        imageUrl: "",
        active: true,
        isSubscription: true,
        promoText: "üéÖ SPECIAL OFFER: Continue the magic all year long!",
        features: [
          "FREE: Welcome package with your first letter",
          "Monthly personalized letters from Santa",
          "Santa shares his travels from around the world",
          "Unique stories and adventures each month",
          "Customized for each child by name",
          "Cancel anytime - no commitments!"
        ],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
      
      await kv.set(`upsell:${defaultSnowUpsell.id}`, defaultSnowUpsell);
      await kv.set(`upsell:${subscriptionUpsell.id}`, subscriptionUpsell);
      await kv.set("upsells:all", [defaultSnowUpsell.id, subscriptionUpsell.id]);
      
      console.log("‚úÖ Created default upsells: North Pole Snow + Santa's Magical Journey");
      
      return c.json({ success: true, upsells: [defaultSnowUpsell, subscriptionUpsell] });
    }
    
    for (const id of allUpsellIds) {
      const upsell = await kv.get(`upsell:${id}`);
      if (upsell) {
        upsells.push(upsell);
      }
    }
    
    return c.json({ success: true, upsells });
  } catch (error: any) {
    console.error("‚ùå Error fetching upsells:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Create or update upsell product
app.post("/make-server-cf244566/admin/upsell/save", async (c) => {
  try {
    const upsellData = await c.req.json();
    
    const allUpsellIds = (await kv.get("upsells:all")) || [];
    
    if (!upsellData.id) {
      // Create new upsell with generated ID
      upsellData.id = `upsell_${Date.now()}`;
      upsellData.createdAt = new Date().toISOString();
      allUpsellIds.push(upsellData.id);
      await kv.set("upsells:all", allUpsellIds);
    } else {
      // Check if this ID already exists in the list
      if (!allUpsellIds.includes(upsellData.id)) {
        // Add to the list if it's a new ID
        allUpsellIds.push(upsellData.id);
        await kv.set("upsells:all", allUpsellIds);
      }
      // Preserve createdAt if updating existing upsell
      const existingUpsell = await kv.get(`upsell:${upsellData.id}`);
      if (existingUpsell && (existingUpsell as any).createdAt) {
        upsellData.createdAt = (existingUpsell as any).createdAt;
      } else {
        upsellData.createdAt = new Date().toISOString();
      }
    }
    
    upsellData.updatedAt = new Date().toISOString();
    
    await kv.set(`upsell:${upsellData.id}`, upsellData);
    
    console.log(`‚úÖ Upsell saved: ${upsellData.id}`, upsellData);
    
    return c.json({ success: true, upsell: upsellData });
  } catch (error: any) {
    console.error("‚ùå Error saving upsell:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Delete upsell
app.delete("/make-server-cf244566/admin/upsell/:id", async (c) => {
  try {
    const id = c.req.param("id");
    
    await kv.del(`upsell:${id}`);
    
    const allUpsellIds = (await kv.get("upsells:all")) || [];
    const updatedIds = allUpsellIds.filter((uid: string) => uid !== id);
    await kv.set("upsells:all", updatedIds);
    
    console.log(`‚úÖ Upsell deleted: ${id}`);
    
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error deleting upsell:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Get next upsell offer for customer
app.get("/make-server-cf244566/upsell/get-offer/:token", async (c) => {
  try {
    const token = c.req.param("token");
    
    // Get order by access token
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === token) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    // Get all active upsells
    const allUpsellIds = (await kv.get("upsells:all")) || [];
    const activeUpsells = [];
    
    for (const id of allUpsellIds) {
      const upsell: any = await kv.get(`upsell:${id}`);
      if (upsell && upsell.active) {
        activeUpsells.push(upsell);
      }
    }
    
    // Sort upsells: non-subscriptions first, subscriptions last
    activeUpsells.sort((a, b) => {
      if (a.isSubscription && !b.isSubscription) return 1;
      if (!a.isSubscription && b.isSubscription) return -1;
      return 0;
    });
    
    if (activeUpsells.length === 0) {
      return c.json({ noMoreUpsells: true });
    }
    
    // Initialize upsell tracking if not exists
    if (!order.upsellsOffered) {
      order.upsellsOffered = [];
      order.upsellsAccepted = [];
      order.upsellDeclineAttempts = {}; // Track decline attempts per upsell
    }
    if (!order.upsellDeclineAttempts) {
      order.upsellDeclineAttempts = {};
    }
    
    // Find next upsell that hasn't been fully declined (max 2 attempts)
    let nextUpsell = null;
    let currentPrice = null;
    let attemptNumber = 1;
    
    for (const upsell of activeUpsells) {
      const attempts = order.upsellDeclineAttempts[upsell.id] || 0;
      
      // If already accepted or declined 2 times, skip
      if (order.upsellsAccepted?.some((a: any) => a.upsellId === upsell.id)) {
        continue;
      }
      if (attempts >= 2) {
        continue;
      }
      
      // Special handling for subscription upsell
      if (upsell.isSubscription) {
        // Skip if customer already has an active subscription (they checked the box on checkout)
        if (order.monthlySubscription && order.subscriptionId) {
          console.log(`‚è≠Ô∏è Skipping subscription upsell - customer already subscribed on checkout`);
          continue;
        }
      }
      
      nextUpsell = upsell;
      attemptNumber = attempts + 1;
      
      // Calculate downsell pricing based on product type
      if (upsell.isSubscription) {
        // Santa's Magical Journey: $12 -> $10 (ONLY 2 attempts)
        if (attemptNumber === 1) {
          currentPrice = upsell.price; // $12
        } else {
          currentPrice = 10.00; // Final downsell
        }
      } else {
        // Regular products (North Pole Snow): $9.99 -> $7.99 (ONLY 2 attempts)
        if (attemptNumber === 1) {
          currentPrice = upsell.price; // Original price
        } else {
          currentPrice = 7.99; // Final downsell
        }
      }
      
      break;
    }
    
    if (!nextUpsell) {
      return c.json({ noMoreUpsells: true });
    }
    
    // Mark as offered if first attempt
    if (attemptNumber === 1 && !order.upsellsOffered.includes(nextUpsell.id)) {
      order.upsellsOffered.push(nextUpsell.id);
    }
    
    await kv.set(`order:${order.orderId}`, order);
    
    // Suggested quantity: for subscriptions default to 1, for products match letter packages
    const suggestedQuantity = nextUpsell.isSubscription ? 1 : (order.letterPackages?.length || 1);
    
    console.log(`üì¶ Offering upsell ${nextUpsell.id} to order ${order.orderId} (Attempt ${attemptNumber}, Price: ${currentPrice})`);
    
    return c.json({
      success: true,
      upsell: {
        ...nextUpsell,
        price: currentPrice // Override with downsell price
      },
      suggestedQuantity,
      attemptNumber,
      isDownsell: attemptNumber > 1
    });
  } catch (error: any) {
    console.error("‚ùå Error getting upsell offer:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Accept upsell and charge customer
app.post("/make-server-cf244566/upsell/accept", async (c) => {
  try {
    const { orderToken, upsellId, quantity, source = "upsell_funnel" } = await c.req.json();
    
    if (!orderToken || !upsellId || !quantity || quantity < 1) {
      return c.json({ error: "Invalid request" }, 400);
    }
    
    // Get order
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === orderToken) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    // Get upsell product
    const upsell: any = await kv.get(`upsell:${upsellId}`);
    if (!upsell) {
      return c.json({ error: "Upsell product not found" }, 404);
    }
    
    // Get the actual price (may be downsell price)
    const attempts = order.upsellDeclineAttempts?.[upsellId] || 0;
    let actualPrice = upsell.price;
    
    if (upsell.isSubscription) {
      if (attempts === 1) actualPrice = 10.00;
    } else {
      if (attempts === 1) actualPrice = 7.99;
    }
    
    const totalAmount = actualPrice * quantity;
    
    console.log(`üí≥ Processing upsell: ${totalAmount.toFixed(2)} for ${quantity}x ${upsell.name} (${upsell.isSubscription ? 'Subscription' : 'One-time'})`);
    
    // Initialize Stripe
    const stripe = Stripe(Deno.env.get("STRIPE_SECRET_KEY") || "", {
      apiVersion: "2023-10-16",
    });
    
    if (!order.stripeCustomerId) {
      return c.json({ error: "No customer on file" }, 400);
    }
    
    // If no payment method stored, try to get it from Stripe customer
    if (!order.stripePaymentMethodId) {
      console.log("‚ö†Ô∏è No payment method stored, retrieving from Stripe customer...");
      try {
        const customer: any = await stripe.customers.retrieve(order.stripeCustomerId);
        const defaultPaymentMethod = customer.invoice_settings?.default_payment_method || customer.default_source;
        
        if (!defaultPaymentMethod) {
          // Try to get the first attached payment method
          const paymentMethods = await stripe.paymentMethods.list({
            customer: order.stripeCustomerId,
            type: 'card',
            limit: 1
          });
          
          if (paymentMethods.data.length > 0) {
            order.stripePaymentMethodId = paymentMethods.data[0].id;
            console.log("‚úÖ Found payment method from customer:", order.stripePaymentMethodId);
            // Save it back to order for future use
            await kv.set(`order:${order.orderId}`, order);
          } else {
            return c.json({ error: "No payment method on file" }, 400);
          }
        } else {
          order.stripePaymentMethodId = defaultPaymentMethod as string;
          console.log("‚úÖ Retrieved default payment method:", order.stripePaymentMethodId);
          // Save it back to order for future use
          await kv.set(`order:${order.orderId}`, order);
        }
      } catch (error: any) {
        console.error("‚ùå Error retrieving payment method:", error);
        return c.json({ error: "Unable to retrieve payment method" }, 400);
      }
    }
    
    let paymentIntent: any = null;
    let subscriptionId = null;
    
    if (upsell.isSubscription) {
      // Create subscription for Santa's Magical Journey
      console.log(`üìÖ Creating subscription at ${actualPrice}/month for ${quantity} kid(s)`);
      
      // First, create or get the product
      let product;
      try {
        // Try to retrieve existing product by metadata
        const products = await stripe.products.search({
          query: `metadata['upsell_id']:'${upsell.id}'`,
          limit: 1
        });
        
        if (products.data.length > 0) {
          product = products.data[0];
          console.log(`‚úÖ Using existing product: ${product.id}`);
        } else {
          // Create new product
          product = await stripe.products.create({
            name: `${upsell.name} - Monthly Letters`,
            description: `Personalized monthly letters from Santa`,
            metadata: {
              upsell_id: upsell.id,
              type: 'subscription'
            }
          });
          console.log(`‚úÖ Created new product: ${product.id}`);
        }
      } catch (productError: any) {
        console.error('Error with product:', productError);
        // Fallback: create product without search
        product = await stripe.products.create({
          name: `${upsell.name} - Monthly Letters`,
          description: `Personalized monthly letters from Santa`,
          metadata: {
            upsell_id: upsell.id,
            type: 'subscription'
          }
        });
      }
      
      // Create a price for this product
      const price = await stripe.prices.create({
        product: product.id,
        unit_amount: Math.round(actualPrice * 100),
        currency: 'usd',
        recurring: {
          interval: 'month',
        },
      });
      
      const subscription = await stripe.subscriptions.create({
        customer: order.stripeCustomerId,
        items: [{
          price: price.id,
          quantity: quantity,
        }],
        payment_behavior: 'default_incomplete',
        payment_settings: { 
          save_default_payment_method: 'on_subscription',
          payment_method_types: ['card']
        },
        expand: ['latest_invoice.payment_intent'],
        metadata: {
          orderId: order.orderId,
          packageType: 'magical_journey',
          numberOfKids: quantity.toString(),
          pricePerKid: actualPrice.toString()
        }
      });
      
      subscriptionId = subscription.id;
      
      // Confirm the payment
      const invoice: any = subscription.latest_invoice;
      paymentIntent = invoice.payment_intent;
      
      if (paymentIntent.status === 'requires_payment_method' || paymentIntent.status === 'requires_confirmation') {
        const confirmed = await stripe.paymentIntents.confirm(paymentIntent.id, {
          payment_method: order.stripePaymentMethodId
        });
        paymentIntent = confirmed;
      }
      
      if (paymentIntent.status !== 'succeeded') {
        console.error(`‚ùå Subscription payment failed: ${paymentIntent.status}`);
        // Cancel the subscription
        await stripe.subscriptions.cancel(subscriptionId);
        return c.json({ 
          error: "Payment was declined. Please contact support.",
          declineCode: paymentIntent.last_payment_error?.code
        }, 402);
      }
      
      // Update order with subscription info
      order.subscription = {
        subscriptionId: subscription.id,
        status: subscription.status,
        currentPeriodEnd: new Date(subscription.current_period_end * 1000).toISOString(),
        pricePerMonth: actualPrice,
        numberOfKids: quantity,
        createdAt: new Date().toISOString()
      };
      
      console.log(`‚úÖ Subscription created: ${subscriptionId}`);
    } else {
      // One-time charge for regular products
      paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(totalAmount * 100),
        currency: 'usd',
        customer: order.stripeCustomerId,
        payment_method: order.stripePaymentMethodId,
        off_session: true,
        confirm: true,
        description: `Upsell: ${quantity}x ${upsell.name} - Order ${order.orderId}`,
        metadata: {
          orderId: order.orderId,
          upsellId: upsell.id,
          quantity: quantity.toString(),
          type: 'upsell'
        }
      });
      
      if (paymentIntent.status !== 'succeeded') {
        console.error(`‚ùå Upsell payment failed: ${paymentIntent.status}`);
        return c.json({ 
          error: "Payment was declined. Please contact support.",
          declineCode: paymentIntent.last_payment_error?.code
        }, 402);
      }
    }
    
    // Add upsell to order
    if (!order.upsellsAccepted) {
      order.upsellsAccepted = [];
    }
    
    order.upsellsAccepted.push({
      upsellId: upsell.id,
      name: upsell.name,
      quantity,
      price: actualPrice,
      total: totalAmount,
      chargedAt: new Date().toISOString(),
      stripePaymentIntentId: paymentIntent.id,
      isSubscription: upsell.isSubscription || false,
      subscriptionId: subscriptionId,
      source: source // Track where the upsell was accepted: "checkout", "upsell_funnel", or "success_page"
    });
    
    // Update order total
    order.total = (order.total || 0) + totalAmount;
    order.updatedAt = new Date().toISOString();
    
    // Add activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: upsell.isSubscription ? 'Subscription Upsell Accepted' : 'Upsell Accepted',
      details: upsell.isSubscription 
        ? `${quantity}x ${upsell.name} - ${actualPrice}/month subscription started - First payment: ${totalAmount.toFixed(2)}`
        : `${quantity}x ${upsell.name} - ${totalAmount.toFixed(2)} charged`,
      user: 'Customer',
      stripeUrl: subscriptionId 
        ? `https://dashboard.stripe.com/subscriptions/${subscriptionId}`
        : `https://dashboard.stripe.com/payments/${paymentIntent.id}`
    });
    
    await kv.set(`order:${order.orderId}`, order);
    
    console.log(`‚úÖ Upsell accepted and charged: ${upsellId}`);
    
    // Send upsell confirmation email
    try {
      const resendApiKey = Deno.env.get("RESEND_API_KEY");
      if (resendApiKey && order.customerInfo?.email) {
        const emailHtml = `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
          </head>
          <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÅ ${upsell.isSubscription ? 'Subscription Started!' : 'Item Added to Your Order!'}</h1>
              </div>
              <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                <p>Hi ${order.customerInfo.name || 'there'},</p>
                
                <p style="font-size: 18px; color: #059669;"><strong>‚úÖ Great choice! Your order has been updated.</strong></p>
                
                <div style="background: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #16a34a;">
                  <p style="margin: 0 0 10px 0;"><strong>Item Added:</strong></p>
                  <p style="font-size: 20px; margin: 0; color: #16a34a;"><strong>${quantity}x ${upsell.name}</strong></p>
                  ${upsell.isSubscription ? `
                    <p style="margin: 10px 0 0 0; font-size: 14px; color: #166534;">
                      üí≥ Monthly subscription at ${actualPrice.toFixed(2)}/month per child<br>
                      üìÖ First payment charged today: ${totalAmount.toFixed(2)}<br>
                      üîÑ Next billing: ${new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toLocaleDateString()}
                    </p>
                  ` : `
                    <p style="margin: 10px 0 0 0; font-size: 14px; color: #166534;">
                      üí≥ Amount charged: ${totalAmount.toFixed(2)}
                    </p>
                  `}
                </div>
                
                ${upsell.isSubscription ? `
                  <div style="background: #dbeafe; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #3b82f6;">
                    <p style="margin: 0 0 10px 0;"><strong>üéÖ Welcome to Santa's Magical Journey!</strong></p>
                    <p style="margin: 5px 0; font-size: 14px;">You're now subscribed to receive monthly personalized letters from Santa. Each month includes:</p>
                    <ul style="margin: 10px 0; padding-left: 20px; font-size: 14px;">
                      <li>A personalized letter from Santa</li>
                      <li>A postcard from his latest destination</li>
                      <li>Enchanting stories and cultural insights</li>
                      <li>Fun activities and illustrations</li>
                    </ul>
                    <p style="margin: 10px 0 0 0; font-size: 13px; color: #1e40af;">
                      You can manage or cancel your subscription anytime from your order confirmation email.
                    </p>
                  </div>
                ` : ''}
                
                <div style="background: #f9fafb; padding: 20px; border-radius: 8px; margin: 20px 0;">
                  <p style="margin: 0 0 10px 0;"><strong>üìã Order Summary:</strong></p>
                  <p style="margin: 5px 0;"><strong>Order #:</strong> ${order.orderId.slice(-8)}</p>
                  <p style="margin: 5px 0;"><strong>Updated Total:</strong> ${order.total.toFixed(2)}</p>
                </div>
                
                <p style="margin-top: 30px;">Thank you for your purchase! The magic continues... ‚ú®</p>
              </div>
              <div style="background: #f9fafb; padding: 20px; text-align: center; color: #6b7280; font-size: 14px; border-radius: 0 0 10px 10px;">
                <p>Questions? Contact us at support@letterfromsanta.com</p>
                <p style="margin: 5px 0 0 0;">¬© ${new Date().getFullYear()} Letter From Santa. All rights reserved.</p>
              </div>
            </div>
          </body>
          </html>
        `;

        const response = await fetch("https://api.resend.com/emails", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${resendApiKey}`,
          },
          body: JSON.stringify({
            from: EMAIL_FROM,
            to: [order.customerInfo.email],
            subject: upsell.isSubscription 
              ? `üéÖ Subscription Started - Santa's Magical Journey!`
              : `üéÅ Item Added to Your Order - ${upsell.name}`,
            html: emailHtml,
          }),
        });

        if (response.ok) {
          console.log("‚úÖ Upsell confirmation email sent to:", order.customerInfo.email);
        } else {
          const errorText = await response.text();
          console.error("ÔøΩÔøΩ Failed to send upsell email:", errorText);
        }
      }
    } catch (emailError) {
      console.error("‚ùå Error sending upsell confirmation email:", emailError);
    }
    
    return c.json({ 
      success: true,
      chargedAmount: totalAmount,
      paymentIntentId: paymentIntent.id,
      subscriptionId: subscriptionId,
      isSubscription: upsell.isSubscription || false
    });
  } catch (error: any) {
    console.error("‚ùå Error accepting upsell:", error);
    
    // Check if it's a Stripe error
    if (error.type === 'StripeCardError' || error.code) {
      return c.json({ 
        error: error.message || "Payment was declined",
        declineCode: error.code
      }, 402);
    }
    
    return c.json({ error: error.message }, 500);
  }
});

// Accept snow upsell (funnel - $9.99)
app.post("/make-server-cf244566/upsell/accept-snow", async (c) => {
  try {
    const { orderToken, quantity } = await c.req.json();
    
    if (!orderToken || !quantity || quantity < 1) {
      return c.json({ error: "Invalid request" }, 400);
    }
    
    // Get order
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === orderToken) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!stripe) {
      return c.json({ error: "Payment system not configured" }, 503);
    }
    
    const pricePerUnit = 9.99;
    const totalAmount = pricePerUnit * quantity;
    
    try {
      // Charge using saved payment method
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(totalAmount * 100),
        currency: 'usd',
        customer: order.stripeCustomerId,
        payment_method: order.stripePaymentMethodId,
        off_session: true,
        confirm: true,
        description: `Certified North Pole Snow (${quantity}x) - Order ${order.orderId}`,
        metadata: {
          orderId: order.orderId,
          upsellType: 'snow',
          quantity: quantity.toString(),
          price: pricePerUnit.toString(),
          source: 'funnel_upsell'
        }
      });
      
      // Add to order
      if (!order.acceptedUpsells) {
        order.acceptedUpsells = [];
      }
      
      order.acceptedUpsells.push({
        id: 'snow_upsell',
        name: 'Certified North Pole Snow',
        price: pricePerUnit,
        quantity,
        total: totalAmount,
        acceptedAt: new Date().toISOString(),
        paymentIntentId: paymentIntent.id,
        source: 'funnel_upsell'
      });
      
      order.total += totalAmount;
      order.updatedAt = new Date().toISOString();
      
      // Add activity log entry
      if (!order.activityLog) {
        order.activityLog = [];
      }
      order.activityLog.push({
        timestamp: new Date().toISOString(),
        action: 'Upsell Accepted - Certified North Pole Snow',
        details: `Certified North Pole Snow - Quantity: ${quantity}, Amount: ${totalAmount.toFixed(2)}`,
        user: 'Customer',
        stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntent.id}`
      });
      
      await kv.set(`order:${order.orderId}`, order);
      
      console.log(`‚úÖ Snow upsell accepted: Order ${order.orderId}, Quantity: ${quantity}, Amount: ${totalAmount}`);
      
      return c.json({ 
        success: true,
        chargedAmount: totalAmount,
        paymentIntentId: paymentIntent.id
      });
    } catch (error: any) {
      console.error("‚ùå Error charging for snow upsell:", error);
      
      if (error.type === 'StripeCardError' || error.code) {
        return c.json({ 
          error: error.message || "Payment was declined",
          declineCode: error.code
        }, 402);
      }
      
      throw error;
    }
  } catch (error: any) {
    console.error("‚ùå Error accepting snow upsell:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Accept snow downsell (funnel - $7.99)
app.post("/make-server-cf244566/upsell/accept-snow-downsell", async (c) => {
  try {
    const { orderToken, quantity } = await c.req.json();
    
    if (!orderToken || !quantity || quantity < 1) {
      return c.json({ error: "Invalid request" }, 400);
    }
    
    // Get order
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === orderToken) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!stripe) {
      return c.json({ error: "Payment system not configured" }, 503);
    }
    
    const pricePerUnit = 7.99;
    const totalAmount = pricePerUnit * quantity;
    
    try {
      // Charge using saved payment method
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(totalAmount * 100),
        currency: 'usd',
        customer: order.stripeCustomerId,
        payment_method: order.stripePaymentMethodId,
        off_session: true,
        confirm: true,
        description: `Certified North Pole Snow - SPECIAL DISCOUNT (${quantity}x) - Order ${order.orderId}`,
        metadata: {
          orderId: order.orderId,
          upsellType: 'snow_downsell',
          quantity: quantity.toString(),
          price: pricePerUnit.toString(),
          source: 'funnel_downsell'
        }
      });
      
      // Add to order
      if (!order.acceptedUpsells) {
        order.acceptedUpsells = [];
      }
      
      order.acceptedUpsells.push({
        id: 'snow_downsell',
        name: 'Certified North Pole Snow (Special Discount)',
        price: pricePerUnit,
        quantity,
        total: totalAmount,
        acceptedAt: new Date().toISOString(),
        paymentIntentId: paymentIntent.id,
        source: 'funnel_downsell',
        originalPrice: 9.99,
        discount: 2.00
      });
      
      order.total += totalAmount;
      order.updatedAt = new Date().toISOString();
      
      // Add activity log entry
      if (!order.activityLog) {
        order.activityLog = [];
      }
      const savings = 2.00 * quantity;
      order.activityLog.push({
        timestamp: new Date().toISOString(),
        action: 'Upsell Accepted - Snow Downsell',
        details: `Certified North Pole Snow (Special Discount) - Quantity: ${quantity}, Amount: ${totalAmount.toFixed(2)} (saved ${savings.toFixed(2)})`,
        user: 'Customer',
        stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntent.id}`
      });
      
      await kv.set(`order:${order.orderId}`, order);
      
      console.log(`‚úÖ Snow downsell accepted: Order ${order.orderId}, Quantity: ${quantity}, Amount: ${totalAmount}`);
      
      return c.json({ 
        success: true,
        chargedAmount: totalAmount,
        paymentIntentId: paymentIntent.id
      });
    } catch (error: any) {
      console.error("‚ùå Error charging for snow downsell:", error);
      
      if (error.type === 'StripeCardError' || error.code) {
        return c.json({ 
          error: error.message || "Payment was declined",
          declineCode: error.code
        }, 402);
      }
      
      throw error;
    }
  } catch (error: any) {
    console.error("‚ùå Error accepting snow downsell:", error);
    return c.json({ error: error.message }, 500);
  }
});

// OLD ROUTE - DISABLED - Duplicate route that doesn't handle subscriptions properly
// The correct route with subscription support is further down in the file (line ~11007)
/*
// Create payment intent for upsell from success page
app.post("/make-server-cf244566/order/:token/create-upsell-payment", async (c) => {
  try {
    const token = c.req.param("token");
    const { upsellId, upsellName, price, quantity } = await c.req.json();
    
    if (!token || !upsellId || !upsellName || !price || !quantity || quantity < 1) {
      return c.json({ error: "Invalid request" }, 400);
    }
    
    // Get order by token
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === token) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      console.error("‚ùå Order not found for token:", token);
      return c.json({ error: "Order not found" }, 404);
    }
    
    // AUTO-FIX: If customer ID is missing, try to retrieve or create it
    if (!order.stripeCustomerId && stripe) {
      console.log("üîß AUTO-FIXING: Missing customer ID for order:", order.orderId);
      try {
        let customerId = null;
        
        // Try to get customer from payment intent first
        if (order.stripePaymentId) {
          try {
            const paymentIntent = await stripe.paymentIntents.retrieve(order.stripePaymentId);
            if (paymentIntent.customer) {
              customerId = paymentIntent.customer as string;
              console.log("‚úÖ Found customer ID from payment intent:", customerId);
              
              // Also get payment method if available
              if (paymentIntent.payment_method && !order.stripePaymentMethodId) {
                order.stripePaymentMethodId = paymentIntent.payment_method as string;
              }
            }
          } catch (piError: any) {
            console.log("‚ö†Ô∏è Could not retrieve payment intent:", piError.message);
          }
        }
        
        // If still no customer, create a new one from order data
        if (!customerId && order.customerInfo?.email) {
          console.log("üÜï Creating new Stripe customer for order:", order.orderId);
          const customer = await stripe.customers.create({
            email: order.customerInfo.email,
            name: order.customerInfo.name || "Customer",
            phone: order.customerInfo.phone || undefined,
            address: order.customerInfo.address ? {
              line1: order.customerInfo.address.line1 || undefined,
              line2: order.customerInfo.address.line2 || undefined,
              city: order.customerInfo.address.city || undefined,
              state: order.customerInfo.address.state || undefined,
              postal_code: order.customerInfo.address.postal_code || undefined,
              country: order.customerInfo.address.country || "US"
            } : undefined,
            metadata: {
              orderId: order.orderId,
              source: "auto-fix-upsell"
            }
          });
          customerId = customer.id;
          console.log("‚úÖ Created new Stripe customer:", customerId);
        }
        
        // Save customer ID to order
        if (customerId) {
          order.stripeCustomerId = customerId;
          await kv.set(`order:${order.orderId}`, order);
          console.log("‚úÖ AUTO-FIXED: Saved customer ID to order");
        }
      } catch (error: any) {
        console.error("‚ùå Auto-fix failed:", error.message);
      }
    }
    
    console.log("üì¶ Order found for upsell payment:", {
      orderId: order.orderId,
      hasCustomerId: !!order.stripeCustomerId,
      customerId: order.stripeCustomerId ? `${order.stripeCustomerId.substring(0, 15)}...` : 'MISSING',
      hasCustomerInfo: !!order.customerInfo,
      customerEmail: order.customerInfo?.email || 'MISSING'
    });
    
    if (!stripe) {
      return c.json({ error: "Payment system not configured" }, 503);
    }
    
    // If still missing customer ID after auto-fix attempt, log but continue
    if (!order.stripeCustomerId) {
      console.error("‚ùå Order still missing customer ID after auto-fix. This shouldn't happen but continuing anyway:", order.orderId);
      // Don't return error - let Stripe handle it when creating payment intent
    }
    
    const totalAmount = price * quantity;
    
    console.log(`üí≥ Creating payment intent for customer: ${order.stripeCustomerId}`);
    
    // Create payment intent with customer
    const paymentIntentData: any = {
      amount: Math.round(totalAmount * 100),
      currency: 'usd',
      description: `${upsellName} (${quantity}x) - Order ${order.orderId}`,
      metadata: {
        orderId: order.orderId,
        upsellId: upsellId,
        upsellName: upsellName,
        quantity: quantity.toString(),
        price: price.toString(),
        type: 'upsell_from_success_page',
        customerEmail: order.customerInfo?.email || '',
        customerName: order.customerInfo?.name || ''
      }
    };
    
    // Only add customer if we have a valid ID
    if (order.stripeCustomerId && order.stripeCustomerId.trim() !== '') {
      paymentIntentData.customer = order.stripeCustomerId;
    }
    
    const paymentIntent = await stripe.paymentIntents.create(paymentIntentData);
    
    console.log(`‚úÖ Created payment intent for upsell: ${paymentIntent.id}`);
    
    return c.json({ clientSecret: paymentIntent.client_secret });
  } catch (error: any) {
    console.error("‚ùå Error creating upsell payment intent:", error);
    return c.json({ error: error.message || "Failed to create payment intent" }, 500);
  }
});

// Confirm upsell after payment success
app.post("/make-server-cf244566/order/:token/confirm-upsell", async (c) => {
  try {
    const token = c.req.param("token");
    const { paymentIntentId } = await c.req.json();
    
    if (!token || !paymentIntentId) {
      return c.json({ error: "Invalid request" }, 400);
    }
    
    // Get order by token
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === token) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!stripe) {
      return c.json({ error: "Payment system not configured" }, 503);
    }
    
    // Retrieve payment intent to get metadata
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
    
    if (paymentIntent.status !== 'succeeded') {
      return c.json({ error: "Payment not completed" }, 400);
    }
    
    const { upsellId, upsellName, quantity, price } = paymentIntent.metadata;
    const totalAmount = parseFloat(price) * parseInt(quantity);
    
    // Add upsell to order's accepted upsells
    if (!order.acceptedUpsells) {
      order.acceptedUpsells = [];
    }
    
    order.acceptedUpsells.push({
      id: upsellId,
      name: upsellName,
      price: parseFloat(price),
      quantity: parseInt(quantity),
      total: totalAmount,
      addedAt: new Date().toISOString(),
      paymentIntentId: paymentIntentId,
      source: 'success_page'
    });
    
    // Update total
    order.total = (order.total || 0) + totalAmount;
    
    // Save updated order
    await kv.set(`order:${order.orderId}`, order);
    
    console.log(`‚úÖ Upsell confirmed for order ${order.orderId}: ${upsellName} x${quantity}`);
    
    // Send confirmation email
    try {
      const resendApiKey = Deno.env.get("RESEND_API_KEY");
      if (resendApiKey) {
        await fetch("https://api.resend.com/emails", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${resendApiKey}`,
          },
          body: JSON.stringify({
            from: EMAIL_FROM,
            to: order.customerInfo.email,
            subject: `üéÅ ${upsellName} Added to Your Order!`,
            html: `
              <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                <h1 style="color: #c41e3a;">‚úÖ Purchase Confirmed!</h1>
                <p>Great news! We've successfully added the following to your order:</p>
                
                <div style="background: #f0f9ff; padding: 20px; border-radius: 8px; margin: 20px 0;">
                  <h2 style="color: #0369a1; margin-top: 0;">${upsellName}</h2>
                  <p style="font-size: 18px; margin: 10px 0;">
                    <strong>Quantity:</strong> ${quantity}<br>
                    <strong>Total:</strong> ${totalAmount.toFixed(2)}
                  </p>
                </div>
                
                <p>This item will be shipped with your Santa letter package.</p>
                
                <div style="margin-top: 30px; padding: 15px; background: #fef3c7; border-radius: 8px;">
                  <p style="margin: 0; color: #92400e;">
                    <strong>Order #${order.orderId}</strong><br>
                    Your order has been updated and will be processed together.
                  </p>
                </div>
                
                <p style="margin-top: 30px;">
                  Thank you for your purchase!<br>
                  üéÖ Santa's Workshop Team
                </p>
              </div>
            `,
          }),
        });
        console.log(`‚úÖ Upsell confirmation email sent to ${order.customerInfo.email}`);
      }
    } catch (emailError) {
      console.error("‚ùå Failed to send upsell confirmation email:", emailError);
    }
    
    return c.json({ 
      success: true, 
      upsellName,
      quantity: parseInt(quantity),
      total: totalAmount 
    });
  } catch (error: any) {
    console.error("‚ùå Error confirming upsell:", error);
    return c.json({ error: error.message || "Failed to confirm upsell" }, 500);
  }
});
*/
// END OF DISABLED OLD ROUTES

// Legacy endpoint - kept for backwards compatibility
app.post("/make-server-cf244566/order/:token/add-upsell", async (c) => {
  try {
    const token = c.req.param("token");
    const { upsellId, upsellName, price, quantity, cardDetails } = await c.req.json();
    
    if (!token || !upsellId || !upsellName || !price || !quantity || quantity < 1) {
      return c.json({ error: "Invalid request" }, 400);
    }
    
    if (!cardDetails || !cardDetails.number || !cardDetails.expMonth || !cardDetails.expYear || !cardDetails.cvc) {
      return c.json({ error: "Card details required" }, 400);
    }
    
    // Get order by token
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === token) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!stripe) {
      return c.json({ error: "Payment system not configured" }, 503);
    }
    
    const totalAmount = price * quantity;
    
    // Create a payment method from card details
    const paymentMethod = await stripe.paymentMethods.create({
      type: 'card',
      card: {
        number: cardDetails.number,
        exp_month: cardDetails.expMonth,
        exp_year: cardDetails.expYear,
        cvc: cardDetails.cvc,
      },
      billing_details: {
        address: {
          postal_code: cardDetails.zip,
        },
      },
    });
    
    // Attach the payment method to the customer
    await stripe.paymentMethods.attach(paymentMethod.id, {
      customer: order.stripeCustomerId,
    });
    
    // Charge customer for the upsell using the new payment method
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(totalAmount * 100),
      currency: 'usd',
      customer: order.stripeCustomerId,
      payment_method: paymentMethod.id,
      off_session: false,
      confirm: true,
      description: `${upsellName} (${quantity}x) - Order ${order.orderId}`,
      metadata: {
        orderId: order.orderId,
        upsellId: upsellId,
        quantity: quantity.toString(),
        type: 'upsell_from_success_page'
      }
    });
    
    if (paymentIntent.status !== 'succeeded') {
      console.error(`‚ùå Payment failed: ${paymentIntent.status}`);
      return c.json({ 
        error: "Payment was declined. Please check your card.",
        declineCode: paymentIntent.last_payment_error?.code
      }, 402);
    }
    
    // Add upsell to order's accepted upsells
    if (!order.acceptedUpsells) {
      order.acceptedUpsells = [];
    }
    
    order.acceptedUpsells.push({
      name: upsellName,
      quantity: quantity,
      price: price,
      total: totalAmount
    });
    
    // Update order total
    order.total = (order.total || 0) + totalAmount;
    order.updatedAt = new Date().toISOString();
    
    // Add activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Upsell Added from Success Page',
      details: `${quantity}x ${upsellName} - ${totalAmount.toFixed(2)} charged`,
      user: 'Customer',
      stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntent.id}`
    });
    
    await kv.set(`order:${order.orderId}`, order);
    
    console.log(`‚úÖ Upsell added from success page: ${upsellName} x${quantity}`);
    
    // Send confirmation email
    try {
      const resendApiKey = Deno.env.get("RESEND_API_KEY");
      if (resendApiKey && order.customerInfo?.email) {
        const emailHtml = `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
          </head>
          <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÅ Item Added!</h1>
              </div>
              <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                <p>Hi ${order.customerInfo.name || 'there'},</p>
                
                <p style="font-size: 18px; color: #059669;"><strong>‚úÖ We're adding ${upsellName} to your order!</strong></p>
                
                <div style="background: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #16a34a;">
                  <p style="margin: 0 0 10px 0;"><strong>Item Added:</strong></p>
                  <p style="font-size: 20px; margin: 0; color: #16a34a;"><strong>${quantity}x ${upsellName}</strong></p>
                  <p style="margin: 10px 0 0 0; font-size: 14px; color: #166534;">
                    üí≥ Amount charged: ${totalAmount.toFixed(2)}
                  </p>
                </div>
                
                <div style="background: #f9fafb; padding: 20px; border-radius: 8px; margin: 20px 0;">
                  <p style="margin: 0 0 10px 0;"><strong>üìã Order Summary:</strong></p>
                  <p style="margin: 5px 0;"><strong>Order #:</strong> ${order.orderId.slice(-8)}</p>
                  <p style="margin: 5px 0;"><strong>Updated Total:</strong> ${order.total.toFixed(2)}</p>
                </div>
                
                <div style="background: #dbeafe; padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #3b82f6;">
                  <p style="margin: 0; font-size: 14px; color: #1e40af;">
                    <strong>‚ú® Your ${upsellName} will be shipped with your letter package!</strong>
                  </p>
                </div>
                
                <p style="margin-top: 30px;">Thank you for your purchase! The magic continues... ‚ú®</p>
                
                <p>With Christmas cheer,<br>The Santa's Letters Team üéÑ</p>
              </div>
              <div style="background: #f9fafb; padding: 20px; text-align: center; color: #6b7280; font-size: 14px; border-radius: 0 0 10px 10px;">
                <p>Questions? Contact us at support@letterfromsanta.com</p>
                <p style="margin: 5px 0 0 0;">¬© ${new Date().getFullYear()} Letter From Santa. All rights reserved.</p>
              </div>
            </div>
          </body>
          </html>
        `;

        const response = await fetch("https://api.resend.com/emails", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${resendApiKey}`,
          },
          body: JSON.stringify({
            from: EMAIL_FROM,
            to: [order.customerInfo.email],
            subject: `üéÅ ${upsellName} Added to Your Order!`,
            html: emailHtml,
          }),
        });

        if (response.ok) {
          console.log("‚úÖ Upsell confirmation email sent to:", order.customerInfo.email);
        } else {
          const errorText = await response.text();
          console.error("‚ùå Failed to send email:", errorText);
        }
      }
    } catch (emailError) {
      console.error("‚ùå Error sending email:", emailError);
    }
    
    return c.json({ 
      success: true,
      message: `${upsellName} added to your order!`,
      order: {
        orderId: order.orderId,
        total: order.total,
        acceptedUpsells: order.acceptedUpsells
      }
    });
  } catch (error: any) {
    console.error("‚ùå Error adding upsell from success page:", error);
    return c.json({ error: error.message || "Failed to add item" }, 500);
  }
});

// Decline upsell
app.post("/make-server-cf244566/upsell/decline", async (c) => {
  try {
    const { orderToken, upsellId } = await c.req.json();
    
    // Get order
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === orderToken) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    // Track decline attempts
    if (!order.upsellDeclineAttempts) {
      order.upsellDeclineAttempts = {};
    }
    if (!order.upsellsDeclined) {
      order.upsellsDeclined = [];
    }
    
    // Increment decline attempts
    if (upsellId) {
      const currentAttempts = order.upsellDeclineAttempts[upsellId] || 0;
      order.upsellDeclineAttempts[upsellId] = currentAttempts + 1;
      
      // If declined 2 times, add to fully declined list
      if (order.upsellDeclineAttempts[upsellId] >= 2) {
        if (!order.upsellsDeclined.includes(upsellId)) {
          order.upsellsDeclined.push(upsellId);
        }
      }
    }
    
    order.updatedAt = new Date().toISOString();
    await kv.set(`order:${order.orderId}`, order);
    
    const attempts = order.upsellDeclineAttempts[upsellId] || 0;
    console.log(`üëé Upsell declined: ${upsellId} (Attempt ${attempts}/2)`);
    
    return c.json({ 
      success: true,
      shouldRetry: attempts < 2 // Tell frontend if we should show downsell
    });
  } catch (error: any) {
    console.error("‚ùå Error declining upsell:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Mark upsell flow complete and send confirmation email
app.post("/make-server-cf244566/upsell/complete", async (c) => {
  try {
    const { orderToken } = await c.req.json();
    
    // Get order
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === orderToken) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    // Mark upsell flow as complete
    order.upsellFlowCompleted = true;
    order.upsellFlowCompletedAt = new Date().toISOString();
    await kv.set(`order:${order.orderId}`, order);
    
    // Send confirmation email with upsells
    await sendOrderConfirmationWithUpsells(order);
    
    console.log(`‚úÖ Upsell flow completed for order: ${order.orderId}`);
    
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error completing upsell flow:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Helper function to send order confirmation with upsells
async function sendOrderConfirmationWithUpsells(order: any) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  if (!resendApiKey) {
    console.log("‚ö†Ô∏è No Resend API key - skipping email");
    return;
  }
  
  const hasUpsells = order.upsellsAccepted && order.upsellsAccepted.length > 0;
  
  // Build upsells HTML
  let upsellsHtml = '';
  if (hasUpsells) {
    upsellsHtml = `
      <div style="background: #f0fdf4; border: 2px solid #059669; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <h3 style="margin-top: 0; color: #059669; font-family: 'Pacifico', cursive;">üéÅ Bonus Items Added</h3>
        ${order.upsellsAccepted.map((upsell: any) => `
          <div style="padding: 10px 0; border-bottom: 1px solid #d1fae5;">
            <div style="display: flex; justify-content: space-between;">
              <span>${upsell.quantity}x ${upsell.name}</span>
              <span style="font-weight: bold;">${upsell.total.toFixed(2)}</span>
            </div>
          </div>
        `).join('')}
      </div>
    `;
  }
  
  const emailHtml = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
    </head>
    <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
      <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
          <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÖ Order Confirmed!</h1>
        </div>
        <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
          <p>Hi ${order.customerInfo.name},</p>
          
          <p style="font-size: 18px; color: #059669;"><strong>‚úÖ Your order has been confirmed and is being processed!</strong></p>
          
          <div style="background: #f9fafb; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <p style="margin: 0 0 10px 0;"><strong>Order #:</strong> ${order.orderId}</p>
            <p style="margin: 0 0 10px 0;"><strong>Letter Packages:</strong> ${order.letterPackages?.length || 0}</p>
            ${order.monthlySubscription ? `<p style="margin: 0;"><strong>Subscription:</strong> Monthly Letters</p>` : ''}
          </div>
          
          ${upsellsHtml}
          
          <div style="background: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: center;">
            <p style="font-size: 24px; margin: 0; color: #16a34a;"><strong>${order.total.toFixed(2)}</strong></p>
            <p style="margin: 5px 0 0 0;">Total Paid</p>
          </div>
          
          <p>Your magical letters from Santa are being prepared and will be mailed soon!</p>
          
          ${order.monthlySubscription ? `
          <div style="background: #dbeafe; border-left: 4px solid #3b82f6; padding: 15px; margin: 20px 0;">
            <p style="margin: 0;"><strong>üìÖ Monthly Subscription Active</strong></p>
            <p style="margin: 5px 0 0 0;">You'll receive new letters every month. Manage your subscription anytime.</p>
          </div>
          ` : ''}
          
          <p style="margin-top: 30px;">Thank you for choosing Santa's Letters!</p>
          
          <p>With Christmas cheer,<br>The Santa's Letters Team üéÑ</p>
        </div>
      </div>
    </body>
    </html>
  `;
  
  try {
    const response = await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${resendApiKey}`,
      },
      body: JSON.stringify({
        from: EMAIL_FROM,
        to: order.customerInfo.email,
        subject: `üéÖ Order Confirmed - Santa's Letters`,
        html: emailHtml,
      }),
    });

    if (!response.ok) {
      console.error("‚ùå Failed to send confirmation email:", await response.text());
    } else {
      console.log(`‚úÖ Confirmation email sent to ${order.customerInfo.email}`);
    }
  } catch (error) {
    console.error("‚ùå Error sending confirmation email:", error);
  }
}

// ============================================
// ADMIN ALERTS SYSTEM
// ============================================

// Get all alerts
app.get("/make-server-cf244566/admin/alerts", async (c) => {
  try {
    const allAlertIds = (await kv.get("alerts:all")) || [];
    const alerts = [];
    let unreadCount = 0;
    
    for (const id of allAlertIds) {
      const alert = await kv.get(`alert:${id}`);
      if (alert) {
        alerts.push(alert);
        if ((alert as any).status === "unread") {
          unreadCount++;
        }
      }
    }
    
    // Sort by created date, newest first
    alerts.sort((a: any, b: any) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
    
    return c.json({ success: true, alerts, unreadCount });
  } catch (error: any) {
    console.error("‚ùå Error fetching alerts:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Mark alert as read
app.patch("/make-server-cf244566/admin/alerts/:alertId/read", async (c) => {
  try {
    const alertId = c.req.param("alertId");
    const alert: any = await kv.get(`alert:${alertId}`);
    
    if (!alert) {
      return c.json({ error: "Alert not found" }, 404);
    }
    
    alert.status = "read";
    alert.readAt = new Date().toISOString();
    
    await kv.set(`alert:${alertId}`, alert);
    
    return c.json({ success: true, alert });
  } catch (error: any) {
    console.error("‚ùå Error marking alert as read:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Mark all alerts as read
app.post("/make-server-cf244566/admin/alerts/read-all", async (c) => {
  try {
    const allAlertIds = (await kv.get("alerts:all")) || [];
    
    for (const id of allAlertIds) {
      const alert: any = await kv.get(`alert:${id}`);
      if (alert && alert.status === "unread") {
        alert.status = "read";
        alert.readAt = new Date().toISOString();
        await kv.set(`alert:${id}`, alert);
      }
    }
    
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error marking all alerts as read:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Delete alert
app.delete("/make-server-cf244566/admin/alerts/:alertId", async (c) => {
  try {
    const alertId = c.req.param("alertId");
    
    await kv.del(`alert:${alertId}`);
    
    const allAlertIds = (await kv.get("alerts:all")) || [];
    const updatedIds = allAlertIds.filter((id: string) => id !== alertId);
    await kv.set("alerts:all", updatedIds);
    
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error deleting alert:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Helper function to create an admin alert
async function createAdminAlert(
  type: string,
  orderId: string,
  message: string,
  details: any,
  priority: "low" | "medium" | "high" = "low",
  relatedOrderId?: string
) {
  try {
    const alertId = `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    const alert = {
      id: alertId,
      type,
      orderId,
      relatedOrderId,
      message,
      details,
      status: "unread",
      priority,
      createdAt: new Date().toISOString(),
    };
    
    await kv.set(`alert:${alertId}`, alert);
    
    const allAlertIds = (await kv.get("alerts:all")) || [];
    allAlertIds.push(alertId);
    await kv.set("alerts:all", allAlertIds);
    
    console.log(`‚úÖ Admin alert created: ${type} for order ${orderId}`);
  } catch (error) {
    console.error("‚ùå Error creating admin alert:", error);
  }
}

// ============================================
// DECLINED CHARGE AUTO-RETRY SYSTEM
// ============================================

// Stripe webhook handler for declined charges
app.post("/make-server-cf244566/stripe-webhook", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }

  try {
    const signature = c.req.header("stripe-signature");
    const webhookSecret = Deno.env.get("STRIPE_WEBHOOK_SECRET");
    
    if (!webhookSecret) {
      console.error("‚ùå STRIPE_WEBHOOK_SECRET not configured");
      return c.json({ error: "Webhook secret not configured" }, 500);
    }

    if (!signature) {
      console.error("‚ùå No signature provided");
      return c.json({ error: "No signature" }, 400);
    }

    const body = await c.req.text();
    let event: Stripe.Event;

    try {
      event = stripe.webhooks.constructEvent(body, signature, webhookSecret);
    } catch (err: any) {
      console.error("‚ùå Webhook signature verification failed:", err.message);
      return c.json({ error: `Webhook Error: ${err.message}` }, 400);
    }

    console.log(`üì• Webhook received: ${event.type}`);

    // Handle invoice.payment_failed for subscription declines
    if (event.type === "invoice.payment_failed") {
      const invoice = event.data.object as Stripe.Invoice;
      const subscriptionId = invoice.subscription as string;

      if (!subscriptionId) {
        console.log("‚ö†Ô∏è Invoice has no subscription, skipping");
        return c.json({ received: true });
      }

      console.log(`üí≥‚ùå Subscription payment failed: ${subscriptionId}`);

      // Find order with this subscription
      const allOrderIds = (await kv.get("orders:all")) || [];
      let targetOrder = null;
      let targetOrderId = null;

      for (const orderId of allOrderIds) {
        const order = await kv.get(`order:${orderId}`);
        if (order && (order as any).subscriptionId === subscriptionId) {
          targetOrder = order;
          targetOrderId = orderId;
          break;
        }
      }

      if (!targetOrder) {
        console.error(`‚ùå No order found for subscription ${subscriptionId}`);
        return c.json({ received: true });
      }

      const order = targetOrder as any;

      // Create or update decline record
      const declineId = `decline_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const now = new Date().toISOString();

      const declineData = {
        declineId,
        timestamp: now,
        orderId: targetOrderId,
        subscriptionId,
        stripeInvoiceId: invoice.id,
        status: "payment_failed",
        declineReason: invoice.last_finalization_error?.message || "Payment failed",
        declineCode: invoice.last_finalization_error?.code || "unknown",
        amount: invoice.amount_due / 100,
        customerInfo: order.customerInfo,
        letterPackages: order.letterPackages,
        numberOfPackages: order.letterPackages?.length || 0,
        affiliateId: order.affiliateId || null,
        // Retry tracking fields
        retryAttempts: 0,
        firstFailureDate: now,
        lastFailureDate: now,
        nextRetryDate: new Date(Date.now() + 12 * 60 * 60 * 1000).toISOString(), // 12 hours from now
        emailsSent: [],
        retryHistory: [
          {
            timestamp: now,
            event: "Initial decline",
            details: invoice.last_finalization_error?.message || "Payment failed",
          },
        ],
      };

      await kv.set(`decline:${declineId}`, declineData);
      console.log(`‚úÖ Decline tracked: ${declineId}`);

      // Create admin alert
      await createAdminAlert(
        "payment_failed",
        targetOrderId as string,
        `Subscription payment failed for ${order.customerInfo.name}`,
        {
          subscriptionId,
          amount: declineData.amount,
          reason: declineData.declineReason,
        },
        "high"
      );

      return c.json({ received: true });
    }

    return c.json({ received: true });
  } catch (error: any) {
    console.error("‚ùå Webhook error:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Process declined charge retries (called by cron or manually)
app.post("/make-server-cf244566/admin/process-retries", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }

  try {
    console.log("üîÑ Processing declined charge retries...");

    // Get all decline records
    const allDeclines = await kv.getByPrefix("decline:");
    const now = new Date();

    let retriesAttempted = 0;
    let retriesSucceeded = 0;
    let retriesFailed = 0;
    let emailsSent = 0;

    for (const decline of allDeclines) {
      const declineData = decline as any;

      // Skip if already attempted 3 times
      if (declineData.retryAttempts >= 3) {
        continue;
      }

      // Check if it's time to retry
      const nextRetryDate = new Date(declineData.nextRetryDate);
      if (now < nextRetryDate) {
        continue; // Not time yet
      }

      console.log(`üîÑ Processing retry for decline ${declineData.declineId}`);
      retriesAttempted++;

      // Get the order
      const order = await kv.get(`order:${declineData.orderId}`);
      if (!order) {
        console.error(`‚ùå Order not found: ${declineData.orderId}`);
        continue;
      }

      const orderData = order as any;

      // Try to charge the subscription
      try {
        const subscription = await stripe.subscriptions.retrieve(declineData.subscriptionId);

        if (!subscription.latest_invoice) {
          console.error(`‚ùå No invoice found for subscription ${declineData.subscriptionId}`);
          retriesFailed++;
          continue;
        }

        // Retry the invoice payment
        const invoice = await stripe.invoices.retrieve(subscription.latest_invoice as string);
        
        if (invoice.status === "paid") {
          console.log(`‚úÖ Invoice already paid: ${invoice.id}`);
          
          // Mark decline as resolved
          declineData.status = "resolved";
          declineData.resolvedDate = new Date().toISOString();
          declineData.retryHistory.push({
            timestamp: new Date().toISOString(),
            event: "Resolved - payment successful",
            details: "Invoice was paid",
          });
          await kv.set(`decline:${declineData.declineId}`, declineData);
          
          retriesSucceeded++;
          continue;
        }

        // Try to pay the invoice
        const paidInvoice = await stripe.invoices.pay(invoice.id);

        if (paidInvoice.status === "paid") {
          console.log(`‚úÖ Retry successful for ${declineData.declineId}`);
          retriesSucceeded++;

          // Mark decline as resolved
          declineData.status = "resolved";
          declineData.resolvedDate = new Date().toISOString();
          declineData.retryHistory.push({
            timestamp: new Date().toISOString(),
            event: "Retry successful",
            details: `Payment processed successfully. Invoice: ${paidInvoice.id}`,
          });
          await kv.set(`decline:${declineData.declineId}`, declineData);

          // Send success email
          const childNames = orderData.letterPackages
            .map((pkg: any) => pkg.childFirstName)
            .join(' and ');
          await sendRetrySuccessEmail(orderData, childNames);

          continue;
        }
      } catch (error: any) {
        console.error(`‚ùå Retry failed for ${declineData.declineId}:`, error.message);
        retriesFailed++;

        // Update retry attempt
        declineData.retryAttempts++;
        declineData.lastFailureDate = new Date().toISOString();
        
        // Calculate next retry date based on attempt number
        // Attempt 1: 12h + 24h = 36h total (1.5 days)
        // Attempt 2: 36h + 24h = 60h total (2.5 days)
        // Attempt 3: stop
        if (declineData.retryAttempts < 3) {
          declineData.nextRetryDate = new Date(now.getTime() + 24 * 60 * 60 * 1000).toISOString();
        }

        declineData.retryHistory.push({
          timestamp: new Date().toISOString(),
          event: `Retry attempt ${declineData.retryAttempts} failed`,
          details: error.message,
        });

        // Send recovery email
        await sendRecoveryEmail(orderData, declineData);
        emailsSent++;

        declineData.emailsSent.push({
          timestamp: new Date().toISOString(),
          attemptNumber: declineData.retryAttempts,
          type: "recovery",
        });

        await kv.set(`decline:${declineData.declineId}`, declineData);

        // If this was the 3rd attempt, create admin alert
        if (declineData.retryAttempts >= 3) {
          await createAdminAlert(
            "payment_retry_exhausted",
            declineData.orderId,
            `All retry attempts exhausted for ${orderData.customerInfo.name}`,
            {
              declineId: declineData.declineId,
              amount: declineData.amount,
              attempts: declineData.retryAttempts,
            },
            "high"
          );
        }
      }
    }

    console.log(`‚úÖ Retry processing complete:`);
    console.log(`   Attempted: ${retriesAttempted}`);
    console.log(`   Succeeded: ${retriesSucceeded}`);
    console.log(`   Failed: ${retriesFailed}`);
    console.log(`   Emails sent: ${emailsSent}`);

    return c.json({
      success: true,
      retriesAttempted,
      retriesSucceeded,
      retriesFailed,
      emailsSent,
    });
  } catch (error: any) {
    console.error("‚ùå Error processing retries:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Send recovery email when payment fails
async function sendRecoveryEmail(order: any, decline: any) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  if (!resendApiKey || !order.customerInfo?.email) {
    console.log("‚ö†Ô∏è Cannot send recovery email - missing API key or email");
    return;
  }

  // Get child names from letter packages
  const childNames = order.letterPackages
    .map((pkg: any) => pkg.childFirstName)
    .join(", ");

  const emailHtml = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
    </head>
    <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
      <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background: linear-gradient(135deg, #dc2626 0%, #ea580c 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
          <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÖ Payment Issue</h1>
        </div>
        <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
          <p>Hi ${order.customerInfo.name},</p>
          
          <p style="font-size: 18px; color: #dc2626;"><strong>‚ö†Ô∏è ${childNames}'s Letter is Waiting!</strong></p>
          
          <p>We tried to process your monthly subscription payment, but it didn't go through.</p>
          
          <div style="background: #fef2f2; border-left: 4px solid #dc2626; padding: 15px; margin: 20px 0;">
            <p style="margin: 0;"><strong>What happened?</strong></p>
            <p style="margin: 5px 0 0 0;">Your card may have expired, reached its limit, or there might be insufficient funds.</p>
          </div>
          
          <div style="background: #dcfce7; border: 2px solid #16a34a; border-radius: 8px; padding: 20px; margin: 20px 0; text-align: center;">
            <p style="margin: 0 0 15px 0;"><strong>Don't let ${childNames} miss out on their magical letter!</strong></p>
            <a href="https://billing.stripe.com/p/login/test_placeholder" 
               style="display: inline-block; background: #16a34a; color: white; padding: 12px 30px; text-decoration: none; border-radius: 6px; font-weight: bold;">
              Update Payment Method
            </a>
          </div>
          
          <p><strong>Attempt ${decline.retryAttempts} of 3</strong></p>
          <p style="font-size: 14px; color: #6b7280;">We'll automatically try again in 24 hours. After 3 failed attempts, your subscription will be cancelled.</p>
          
          <p style="margin-top: 30px;">Questions? Reply to this email and we'll help!</p>
          
          <p>With Christmas cheer,<br>The Santa's Letters Team üéÑ</p>
        </div>
      </div>
    </body>
    </html>
  `;

  try {
    const response = await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${resendApiKey}`,
      },
      body: JSON.stringify({
        from: EMAIL_FROM,
        to: order.customerInfo.email,
        subject: `üéÖ Payment Issue - ${childNames}'s Letter is Waiting!`,
        html: emailHtml,
      }),
    });

    if (!response.ok) {
      console.error("‚ùå Failed to send recovery email:", await response.text());
    } else {
      console.log(`‚úÖ Recovery email sent to ${order.customerInfo.email}`);
    }
  } catch (error) {
    console.error("‚ùå Error sending recovery email:", error);
  }
}

// Migration endpoint - backfill customer IDs for existing orders
app.post("/make-server-cf244566/admin/migrate-customer-ids", async (c) => {
  try {
    const { adminPassword } = await c.req.json();
    
    // Verify admin password
    const correctPassword = Deno.env.get("ADMIN_PASSWORD");
    if (!correctPassword || adminPassword !== correctPassword) {
      return c.json({ error: "Unauthorized" }, 401);
    }
    
    if (!stripe) {
      return c.json({ error: "Stripe not configured" }, 503);
    }
    
    const allOrderIds = (await kv.get("orders:all")) || [];
    let updated = 0;
    let skipped = 0;
    let errors = 0;
    
    console.log(`üîÑ Starting migration for ${allOrderIds.length} orders...`);
    
    for (const orderId of allOrderIds) {
      const order: any = await kv.get(`order:${orderId}`);
      
      if (!order) {
        skipped++;
        continue;
      }
      
      // Skip if already has customer ID
      if (order.stripeCustomerId) {
        skipped++;
        continue;
      }
      
      // Try to get customer ID from payment intent
      if (order.stripePaymentId) {
        try {
          const paymentIntent = await stripe.paymentIntents.retrieve(order.stripePaymentId);
          
          if (paymentIntent.customer) {
            order.stripeCustomerId = paymentIntent.customer as string;
            
            // Also get payment method if available
            if (paymentIntent.payment_method && !order.stripePaymentMethodId) {
              order.stripePaymentMethodId = paymentIntent.payment_method as string;
            }
            
            await kv.set(`order:${orderId}`, order);
            updated++;
            console.log(`‚úÖ Updated order ${orderId} with customer ID`);
          } else {
            skipped++;
            console.log(`‚è≠Ô∏è Order ${orderId} has no customer in payment intent`);
          }
        } catch (error: any) {
          errors++;
          console.error(`‚ùå Error processing order ${orderId}:`, error.message);
        }
      } else {
        skipped++;
      }
    }
    
    console.log(`‚úÖ Migration complete: ${updated} updated, ${skipped} skipped, ${errors} errors`);
    
    return c.json({ 
      success: true, 
      updated, 
      skipped, 
      errors,
      total: allOrderIds.length 
    });
  } catch (error: any) {
    console.error("‚ùå Migration error:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Retry Payment - Manual admin action to force charge existing payment method
app.post("/make-server-cf244566/decline/retry-payment", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not initialized" }, 500);
  }

  try {
    const { declineId, paymentIntentId } = await c.req.json();

    if (!declineId || !paymentIntentId) {
      return c.json({ error: "Missing declineId or paymentIntentId" }, 400);
    }

    console.log(`üîÑ Admin retry payment: ${paymentIntentId}`);

    // Get the payment intent
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);

    // Try to confirm/retry the payment
    let result;
    if (paymentIntent.status === 'requires_payment_method') {
      // Cannot retry - needs new payment method
      return c.json({ 
        error: "Card declined. Please update payment method first.",
        details: "This payment requires a new payment method before it can be retried."
      }, 400);
    } else if (paymentIntent.status === 'requires_confirmation') {
      result = await stripe.paymentIntents.confirm(paymentIntentId);
    } else if (paymentIntent.status === 'requires_action') {
      // Might need 3D secure - just return current status
      return c.json({
        error: "Payment requires customer action (3D Secure)",
        details: "Customer must complete authentication",
        paymentIntentId
      }, 400);
    } else {
      // Try to create a new payment intent with same payment method
      const newPaymentIntent = await stripe.paymentIntents.create({
        amount: paymentIntent.amount,
        currency: paymentIntent.currency,
        customer: paymentIntent.customer as string,
        payment_method: paymentIntent.payment_method as string,
        confirm: true,
        description: `Retry of ${paymentIntentId}`,
        metadata: paymentIntent.metadata,
      });
      result = newPaymentIntent;
    }

    if (result.status === 'succeeded') {
      // Update decline record to resolved
      const declineData = await kv.get(`decline:${declineId}`);
      if (declineData) {
        declineData.status = 'resolved';
        declineData.resolvedDate = new Date().toISOString();
        declineData.retryHistory = declineData.retryHistory || [];
        declineData.retryHistory.push({
          timestamp: new Date().toISOString(),
          event: 'Admin Manual Retry - Success',
          details: `Payment succeeded: ${result.id}`
        });
        await kv.set(`decline:${declineId}`, declineData);
      }

      console.log(`‚úÖ Payment retry successful: ${result.id}`);
      return c.json({ success: true, paymentIntentId: result.id });
    } else {
      console.log(`‚ùå Payment retry failed: ${result.status}`);
      return c.json({ 
        error: "Payment retry failed", 
        details: result.last_payment_error?.message || result.status 
      }, 400);
    }
  } catch (error: any) {
    console.error("‚ùå Retry payment error:", error);
    return c.json({ error: error.message, details: error.raw?.message }, 500);
  }
});

// Update Payment Method - Admin adds new card from phone call
app.post("/make-server-cf244566/decline/update-payment-method", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not initialized" }, 500);
  }

  try {
    const { declineId, paymentIntentId, cardNumber, expMonth, expYear, cvc } = await c.req.json();

    if (!declineId || !paymentIntentId || !cardNumber || !expMonth || !expYear || !cvc) {
      return c.json({ error: "Missing required card details" }, 400);
    }

    console.log(`üí≥ Admin updating payment method for: ${paymentIntentId}`);

    // Get the payment intent to get customer ID
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
    const customerId = paymentIntent.customer as string;

    if (!customerId) {
      return c.json({ error: "No customer found for this payment" }, 400);
    }

    // Create a payment method from card details
    const paymentMethod = await stripe.paymentMethods.create({
      type: 'card',
      card: {
        number: cardNumber,
        exp_month: parseInt(expMonth),
        exp_year: parseInt(expYear),
        cvc: cvc,
      },
    });

    // Attach payment method to customer
    await stripe.paymentMethods.attach(paymentMethod.id, {
      customer: customerId,
    });

    // Set as default payment method
    await stripe.customers.update(customerId, {
      invoice_settings: {
        default_payment_method: paymentMethod.id,
      },
    });

    // Update the payment intent with new payment method
    await stripe.paymentIntents.update(paymentIntentId, {
      payment_method: paymentMethod.id,
    });

    // Update decline record
    const declineData = await kv.get(`decline:${declineId}`);
    if (declineData) {
      declineData.retryHistory = declineData.retryHistory || [];
      declineData.retryHistory.push({
        timestamp: new Date().toISOString(),
        event: 'Admin Updated Payment Method',
        details: `New card ending in ${cardNumber.slice(-4)}`
      });
      await kv.set(`decline:${declineId}`, declineData);
    }

    console.log(`‚úÖ Payment method updated for customer: ${customerId}`);
    return c.json({ success: true, paymentMethodId: paymentMethod.id });
  } catch (error: any) {
    console.error("‚ùå Update payment method error:", error);
    return c.json({ 
      error: error.message || "Failed to update payment method",
      details: error.raw?.message 
    }, 500);
  }
});

// Stop Recovery - Remove from retry queue and stop emails
app.post("/make-server-cf244566/decline/stop-recovery", async (c) => {
  try {
    const { declineId } = await c.req.json();

    if (!declineId) {
      return c.json({ error: "Missing declineId" }, 400);
    }

    console.log(`üõë Admin stopping recovery for: ${declineId}`);

    // Update decline record
    const declineData = await kv.get(`decline:${declineId}`);
    if (!declineData) {
      return c.json({ error: "Decline not found" }, 404);
    }

    // Mark as stopped
    declineData.status = 'stopped';
    declineData.unsubscribed = true;
    declineData.unsubscribedAt = new Date().toISOString();
    declineData.retryHistory = declineData.retryHistory || [];
    declineData.retryHistory.push({
      timestamp: new Date().toISOString(),
      event: 'Admin Stopped Recovery',
      details: 'All recovery attempts and emails stopped by admin'
    });

    await kv.set(`decline:${declineId}`, declineData);

    console.log(`‚úÖ Recovery stopped for: ${declineId}`);
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Stop recovery error:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Create payment intent for upsell from success page (requires new card input)
app.post("/make-server-cf244566/order/:token/create-upsell-payment", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not initialized" }, 500);
  }

  try {
    const token = c.req.param("token");
    const { upsellId, upsellName, price, quantity } = await c.req.json();

    if (!token || !upsellId || !price || !quantity) {
      return c.json({ error: "Missing required fields" }, 400);
    }

    console.log(`üí≥ Creating payment intent for upsell: ${upsellName} x${quantity}`);

    // Find order by access token
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;

    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === token) {
        order = orderData;
        break;
      }
    }

    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    // For subscriptions, charge $0 initially (billing starts January 1st)
    const isSubscription = upsellId === "upsell_subscription";
    const totalAmount = isSubscription ? 0 : (price * quantity);

    // For subscriptions, use SetupIntent (can't charge $0 with PaymentIntent)
    // For regular upsells, use PaymentIntent
    if (isSubscription) {
      // Create SetupIntent for subscription (saves payment method for future use)
      const setupIntent = await stripe.setupIntents.create({
        customer: order.stripeCustomerId,
        description: `Santa's Magical Journey Subscription Setup (${quantity} ${quantity === 1 ? 'child' : 'children'}) - Billing starts Jan 1st`,
        metadata: {
          orderId: order.orderId,
          upsellId,
          upsellName,
          quantity: quantity.toString(),
          price: price.toString(),
          source: "success_page",
          type: "success_page_upsell",
          isSubscription: "true",
        },
        automatic_payment_methods: {
          enabled: true,
        },
      });

      console.log(`‚úÖ SetupIntent created for subscription: ${setupIntent.id}`);
      return c.json({ clientSecret: setupIntent.client_secret });
    }

    // Create payment intent for regular upsells
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(totalAmount * 100),
      currency: "usd",
      customer: order.stripeCustomerId,
      description: `${quantity}x ${upsellName} - Order ${order.orderId}`,
      metadata: {
        orderId: order.orderId,
        upsellId,
        upsellName,
        quantity: quantity.toString(),
        price: price.toString(),
        source: "success_page",
        type: "success_page_upsell",
        isSubscription: "false",
      },
      automatic_payment_methods: {
        enabled: true,
      },
    });

    console.log(`‚úÖ Payment intent created: ${paymentIntent.id}`);

    return c.json({ clientSecret: paymentIntent.client_secret });
  } catch (error: any) {
    console.error("‚ùå Error creating upsell payment intent:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Confirm upsell payment and add to order (after successful payment)
app.post("/make-server-cf244566/order/:token/confirm-upsell", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not initialized" }, 500);
  }

  try {
    const token = c.req.param("token");
    const { paymentIntentId } = await c.req.json();

    if (!token || !paymentIntentId) {
      return c.json({ error: "Missing required fields" }, 400);
    }

    console.log(`‚úÖ Confirming upsell payment: ${paymentIntentId}`);

    // Determine if this is a SetupIntent (subscription) or PaymentIntent (regular upsell)
    let metadata: any;
    let paymentMethodId: string | null = null;
    
    if (paymentIntentId.startsWith('seti_')) {
      // This is a SetupIntent (subscription)
      const setupIntent = await stripe.setupIntents.retrieve(paymentIntentId);
      
      if (setupIntent.status !== "succeeded") {
        return c.json({ error: "Setup not completed" }, 400);
      }
      
      metadata = setupIntent.metadata;
      paymentMethodId = setupIntent.payment_method as string;
    } else {
      // This is a PaymentIntent (regular upsell)
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
      
      if (paymentIntent.status !== "succeeded") {
        return c.json({ error: "Payment not completed" }, 400);
      }
      
      metadata = paymentIntent.metadata;
      paymentMethodId = paymentIntent.payment_method as string;
    }

    const { orderId, upsellId, upsellName, quantity, price, source } = metadata;

    // Find order
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    // Verify token
    if (order.accessToken !== token) {
      return c.json({ error: "Invalid access token" }, 403);
    }

    const qty = parseInt(quantity);
    const unitPrice = parseFloat(price);
    const total = unitPrice * qty;

    // HANDLE SUBSCRIPTION UPSELL - Same logic as pre-checkout
    if (upsellId === "upsell_subscription") {
      console.log(`üéÖ Creating subscription from success page for ${qty} children`);
      
      // Calculate trial end date: January 1st of next year
      const january1st = new Date(new Date().getFullYear() + 1, 0, 1);
      const trialEndTimestamp = Math.floor(january1st.getTime() / 1000);
      
      console.log(`üìÖ Setting trial_end to January 1st: ${january1st.toISOString()}`);

      try {
        // Attach payment method to customer (if not already attached)
        if (paymentMethodId) {
          try {
            await stripe.paymentMethods.attach(paymentMethodId, {
              customer: order.stripeCustomerId,
            });
          } catch (e: any) {
            // Payment method might already be attached, that's OK
            if (!e.message?.includes('already been attached')) {
              throw e;
            }
          }
          
          // Set as default payment method
          await stripe.customers.update(order.stripeCustomerId, {
            invoice_settings: {
              default_payment_method: paymentMethodId,
            },
          });
        }

        // Get the subscription price ID from environment variable
        const subscriptionPriceId = Deno.env.get('STRIPE_SUBSCRIPTION_PRICE_ID');
        if (!subscriptionPriceId) {
          console.error('‚ùå STRIPE_SUBSCRIPTION_PRICE_ID environment variable not set!');
          throw new Error('Subscription price not configured. Please create a Stripe Price for $12/month and set STRIPE_SUBSCRIPTION_PRICE_ID environment variable.');
        }

        // Create the subscription with trial period until January 1st
        const subscription = await stripe.subscriptions.create({
          customer: order.stripeCustomerId,
          items: [
            {
              price: subscriptionPriceId, // $12/month subscription price from env
              quantity: qty,
            },
          ],
          trial_end: trialEndTimestamp, // Use trial_end instead of billing_cycle_anchor
          proration_behavior: "none",
          default_payment_method: paymentMethodId,
          metadata: {
            orderId: order.orderId,
            source: "success_page_subscription",
            numberOfChildren: qty.toString(),
          },
        });

        console.log(`‚úÖ Subscription created: ${subscription.id} for ${qty} children, billing starts January 1st`);

        // CREATE A NEW SEPARATE SUBSCRIPTION ORDER (no letters sent immediately)
        const subscriptionOrderId = `SUB-${Date.now()}-${Math.random().toString(36).substring(7)}`;
        
        // Copy letter data from original order for subscription letters (up to qty)
        const subscriptionLetters = [];
        if (order.letterPackages && order.letterPackages.length > 0) {
          // Copy up to qty letters from the original order
          for (let i = 0; i < qty; i++) {
            const sourceLetter = order.letterPackages[i] || order.letterPackages[0]; // Use first letter as template if not enough
            subscriptionLetters.push({
              childFirstName: sourceLetter.childFirstName || "",
              childLastName: sourceLetter.childLastName || "",
              friendName: sourceLetter.friendName || "",
              streetAddress: sourceLetter.streetAddress || "",
              unitApt: sourceLetter.unitApt || "",
              city: sourceLetter.city || "",
              state: sourceLetter.state || "",
              zipCode: sourceLetter.zipCode || "",
              letterIndex: i + 1, // Track which letter this is
            });
          }
        } else {
          // Create blank letter data if no original order data
          for (let i = 0; i < qty; i++) {
            subscriptionLetters.push({
              childFirstName: "",
              childLastName: "",
              friendName: "",
              streetAddress: "",
              unitApt: "",
              city: "",
              state: "",
              zipCode: "",
              letterIndex: i + 1,
            });
          }
        }
        
        const subscriptionOrder: any = {
          orderId: subscriptionOrderId,
          orderDate: new Date().toISOString(),
          status: "subscription_active",
          total: 0, // $0 initial charge
          customerInfo: order.customerInfo,
          stripeCustomerId: order.stripeCustomerId,
          stripePaymentMethodId: paymentMethodId,
          stripePaymentId: paymentIntentId,
          stripeCheckoutUrl: `https://dashboard.stripe.com/subscriptions/${subscription.id}`,
          letterPackages: [], // NO LETTERS sent in this order - subscription only
          subscriptionLetters: subscriptionLetters, // Store subscription letter data separately
          numberOfPackages: 0,
          shippingDate: order.shippingDate || "", // Copy shipping date from original order
          monthlySubscription: true,
          subscriptionId: subscription.id,
          subscriptionQuantity: qty,
          subscriptionStartDate: new Date(january1st).toISOString(),
          subscriptionNextBillingDate: new Date(january1st).toISOString(),
          subscriptionMonthsActive: 0,
          subscriptionPrice: 12.00 * qty, // Total monthly price: $12 per child
          subscriptionProductName: "Santa's Magical Journey",
          billingIntervalDays: 30,
          subscriptionSource: "success_page_upsell",
          originalOrderId: order.orderId, // Reference to the original order
          accessToken: `sub_${Date.now()}_${Math.random().toString(36).substring(7)}`,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          activityLog: [
            {
              timestamp: new Date().toISOString(),
              action: "Subscription Order Created",
              details: `Subscription activated from success page for ${qty} ${qty === 1 ? 'child' : 'children'}. First billing: January 1st, ${january1st.getFullYear()} (${(12 * qty).toFixed(2)}/month). Letter data copied from original order. No immediate letters sent.`,
              user: "Customer",
              stripeUrl: `https://dashboard.stripe.com/subscriptions/${subscription.id}`,
            }
          ],
        };

        // Save the NEW subscription order
        await kv.set(`order:${subscriptionOrderId}`, subscriptionOrder);
        
        // Add to global orders list
        const allOrderIds = (await kv.get("orders:all")) || [];
        allOrderIds.push(subscriptionOrderId);
        await kv.set("orders:all", allOrderIds);

        console.log(`‚úÖ Created separate subscription order: ${subscriptionOrderId}`);

        // Update ORIGINAL order to reference the subscription order
        if (!order.activityLog) {
          order.activityLog = [];
        }
        order.activityLog.push({
          timestamp: new Date().toISOString(),
          action: "Subscription Upsell Accepted",
          details: `Customer added Santa's Magical Journey subscription (${qty} ${qty === 1 ? 'child' : 'children'}). Separate subscription order created: ${subscriptionOrderId}`,
          user: "Customer",
          stripeUrl: `https://dashboard.stripe.com/subscriptions/${subscription.id}`,
        });
        
        order.linkedSubscriptionOrderId = subscriptionOrderId;
        order.updatedAt = new Date().toISOString();
        await kv.set(`order:${orderId}`, order);
        
        console.log(`‚úÖ Original order ${orderId} updated with subscription reference`);

        // Return subscription-specific data
        return c.json({
          success: true,
          isSubscription: true,
          subscriptionId: subscription.id,
          subscriptionOrderId: subscriptionOrderId,
          upsellName: "Santa's Magical Journey",
          quantity: qty,
          total: 0,
          billingStart: january1st.toISOString(),
          monthlyPrice: 12 * qty,
        });

      } catch (subError: any) {
        console.error("‚ùå Failed to create subscription from success page:", subError);
        throw new Error(`Subscription creation failed: ${subError.message}`);
      }
    } else {
      // Regular upsell (non-subscription)
      if (!order.upsellsAccepted) {
        order.upsellsAccepted = [];
      }

      order.upsellsAccepted.push({
        upsellId: upsellId,
        name: upsellName,
        quantity: qty,
        price: unitPrice,
        total,
        chargedAt: new Date().toISOString(),
        stripePaymentIntentId: paymentIntentId,
        source: source || "success_page",
      });

      // Update order total
      order.total = (order.total || 0) + total;
      order.updatedAt = new Date().toISOString();

      // Add activity log
      if (!order.activityLog) {
        order.activityLog = [];
      }
      order.activityLog.push({
        timestamp: new Date().toISOString(),
        action: "Success Page Upsell Added",
        details: `${qty}x ${upsellName} - ${total.toFixed(2)} charged`,
        user: "Customer",
        stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntentId}`,
      });

      await kv.set(`order:${orderId}`, order);
      
      console.log(`‚úÖ Upsell confirmed and added to order: ${upsellName}`);

      // Send confirmation email for regular upsells
      try {
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        if (resendApiKey && order.customerInfo?.email) {
          const emailHtml = `
            <!DOCTYPE html>
            <html>
            <head>
              <meta charset="utf-8">
              <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
            </head>
            <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
              <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                  <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÅ Item Added to Your Order!</h1>
                </div>
                <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                  <p>Hi ${order.customerInfo.name || "there"},</p>
                  
                  <p style="font-size: 18px; color: #059669;"><strong>‚úÖ Great choice! Your order has been updated.</strong></p>
                  
                  <div style="background: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #16a34a;">
                    <p style="margin: 0 0 10px 0;"><strong>Item Added:</strong></p>
                    <p style="font-size: 20px; margin: 0; color: #16a34a;"><strong>${qty}x ${upsellName}</strong></p>
                    <p style="margin: 10px 0 0 0; font-size: 24px; color: #16a34a;"><strong>${total.toFixed(2)}</strong></p>
                  </div>
                  
                  <p style="margin-top: 30px;">This item has been added to Order #${order.orderId} and will be included with your original order.</p>
                  
                  <p style="margin-top: 30px;">Questions? Reply to this email and we'll help!</p>
                  
                  <p>With Christmas cheer,<br>The Santa's Letters Team üéÑ</p>
                </div>
              </div>
            </body>
            </html>
          `;

          await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${resendApiKey}`,
            },
            body: JSON.stringify({
              from: EMAIL_FROM,
              to: [order.customerInfo.email],
              subject: `üéÅ ${upsellName} Added to Your Order!`,
              html: emailHtml,
            }),
          });

          console.log("üìß Upsell confirmation email sent");
        }
      } catch (emailError) {
        console.error("‚ùå Failed to send confirmation email:", emailError);
        // Don't fail the request if email fails
      }

      return c.json({
        success: true,
        isSubscription: false,
        upsellName,
        quantity: qty,
        total,
      });
    }
  } catch (error: any) {
    console.error("‚ùå Error confirming upsell:", error);
    return c.json({ error: error.message }, 500);
  }
});

// ========== ADMIN SUBSCRIPTION MANAGEMENT ENDPOINTS ==========

// Update subscription letters
app.post("/make-server-cf244566/admin/update-subscription-letters", async (c) => {
  try {
    const { orderId, subscriptionLetters } = await c.req.json();

    // Get order
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    // Update subscription letters
    order.subscriptionLetters = subscriptionLetters;
    order.updatedAt = new Date().toISOString();

    // Add activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: "Subscription Letters Updated",
      details: `Subscription letter data updated by admin. Total letters: ${subscriptionLetters.length}`,
      user: "Admin",
    });

    await kv.set(`order:${orderId}`, order);

    console.log(`‚úÖ Updated subscription letters for ${orderId}`);
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error updating subscription letters:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Update subscription quantity and sync with Stripe
app.post("/make-server-cf244566/admin/update-subscription-quantity", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }

  try {
    const { orderId, newQuantity, subscriptionLetters, subscriptionId } = await c.req.json();

    // Get order
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    const oldQuantity = order.subscriptionQuantity || 0;
    const oldPrice = order.subscriptionPrice || 12.00;

    // Calculate new price based on quantity ($12 per letter)
    const newPrice = newQuantity * 12.00;

    // Update order
    order.subscriptionQuantity = newQuantity;
    order.subscriptionLetters = subscriptionLetters;
    order.subscriptionPrice = newPrice;
    order.updatedAt = new Date().toISOString();

    // Update Stripe subscription quantity
    if (subscriptionId && stripe) {
      try {
        const subscription = await stripe.subscriptions.retrieve(subscriptionId);
        
        if (subscription.items.data.length > 0) {
          const subscriptionItemId = subscription.items.data[0].id;
          
          await stripe.subscriptionItems.update(subscriptionItemId, {
            quantity: newQuantity,
          });

          console.log(`‚úÖ Updated Stripe subscription quantity from ${oldQuantity} to ${newQuantity} (Price: ${oldPrice.toFixed(2)} ‚Üí ${newPrice.toFixed(2)})`);
        }
      } catch (stripeError) {
        console.error("‚ùå Error updating Stripe subscription:", stripeError);
        throw new Error("Failed to update Stripe subscription quantity");
      }
    }

    // Add activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: "Subscription Quantity Adjusted",
      details: `Subscription quantity changed from ${oldQuantity} to ${newQuantity} letters by admin. Monthly price updated from ${oldPrice.toFixed(2)} to ${newPrice.toFixed(2)}. Stripe subscription updated.`,
      user: "Admin",
      stripeUrl: subscriptionId ? `https://dashboard.stripe.com/subscriptions/${subscriptionId}` : undefined,
    });

    await kv.set(`order:${orderId}`, order);

    console.log(`‚úÖ Updated subscription quantity for ${orderId}: ${oldQuantity} ‚Üí ${newQuantity} (Price: ${oldPrice.toFixed(2)} ‚Üí ${newPrice.toFixed(2)})`);
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error updating subscription quantity:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Charge subscription immediately
app.post("/make-server-cf244566/admin/charge-subscription-now", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }

  try {
    const { orderId, amount, quantity, customerId, paymentMethodId } = await c.req.json();

    // Get order
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    // Create a payment intent to charge the customer
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(amount * 100), // Convert to cents
      currency: "usd",
      customer: customerId,
      payment_method: paymentMethodId,
      confirm: true,
      off_session: true,
      description: `Santa's Magical Journey - Manual charge for ${quantity} ${quantity === 1 ? 'letter' : 'letters'}`,
      metadata: {
        orderId: orderId,
        subscriptionCharge: "true",
        quantity: quantity.toString(),
      },
    });

    if (paymentIntent.status !== "succeeded") {
      throw new Error(`Payment failed: ${paymentIntent.status}`);
    }

    console.log(`‚úÖ Successfully charged ${amount} for subscription ${orderId}`);

    // Increment successful charges counter
    order.successfulCharges = (order.successfulCharges || 0) + 1;
    order.subscriptionMonthsActive = order.successfulCharges;
    
    // Add activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: "Manual Subscription Charge",
      details: `Admin manually charged ${amount.toFixed(2)} for ${quantity} ${quantity === 1 ? 'letter' : 'letters'}. Month ${order.successfulCharges}.`,
      user: "Admin",
      stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntent.id}`,
    });

    order.updatedAt = new Date().toISOString();
    await kv.set(`order:${orderId}`, order);

    // Create a new order for this charge (for fulfillment)
    console.log(`üì¶ [Custom Charge] Creating fulfillment order. Subscription letters count: ${(order.subscriptionLetters || []).length}`);
    console.log(`üì¶ [Custom Charge] Subscription letters data:`, JSON.stringify(order.subscriptionLetters));
    
    const allOrderIds = (await kv.get("orders:all")) || [];
    const newOrderId = `ord_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    const newOrder = {
      orderId: newOrderId,
      parentOrderId: order.orderId,
      subscriptionId: order.subscriptionId,
      sessionId: paymentIntent.id,
      stripePaymentId: paymentIntent.id,
      stripeCheckoutUrl: `https://dashboard.stripe.com/payments/${paymentIntent.id}`,
      orderDate: new Date().toISOString(),
      status: "pending",
      total: amount,
      customerInfo: order.customerInfo,
      letterPackages: order.letterPackages,
      numberOfPackages: order.numberOfPackages,
      letters: order.subscriptionLetters || [], // Copy subscription letter data for fulfillment
      shippingDate: "",
      monthlySubscription: false,
      subscriptionRecurringOrder: true,
      subscriptionMonth: order.successfulCharges,
      subscriptionProductName: order.subscriptionProductName || "Santa's Magical Journey",
      affiliateId: order.affiliateId,
      affiliateName: order.affiliateName,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      activityLog: [{
        timestamp: new Date().toISOString(),
        action: 'Order Created',
        details: `Recurring subscription order - Manual charge. Copied ${(order.subscriptionLetters || []).length} letter(s) from subscription.`,
        user: 'Admin'
      }]
    };
    
    await kv.set(`order:${newOrderId}`, newOrder);
    allOrderIds.push(newOrderId);
    await kv.set("orders:all", allOrderIds);
    
    console.log(`‚úÖ Created new order ${newOrderId} for manual charge`);

    // Send email notification
    try {
      const resendApiKey = Deno.env.get("RESEND_API_KEY");
      if (resendApiKey && order.customerInfo?.email) {
        const emailHtml = `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
          </head>
          <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <div style="background: linear-gradient(135deg, #7c3aed 0%, #db2777 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üí≥ Payment Processed</h1>
              </div>
              <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                <p>Hi ${order.customerInfo.name || "there"},</p>
                
                <p style="font-size: 18px; color: #7c3aed;"><strong>Your subscription payment has been processed successfully.</strong></p>
                
                <div style="background: #f3e8ff; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #7c3aed;">
                  <p style="margin: 0 0 10px 0;"><strong>Santa's Magical Journey</strong></p>
                  <p style="font-size: 20px; margin: 0; color: #7c3aed;"><strong>${quantity} ${quantity === 1 ? 'Letter' : 'Letters'}</strong></p>
                  <p style="margin: 10px 0 0 0; font-size: 24px; color: #7c3aed;"><strong>${amount.toFixed(2)}</strong></p>
                </div>
                
                <p style="margin-top: 30px;">Your personalized letters from Santa will continue to arrive monthly, bringing joy and magic to your child throughout the year!</p>
                
                <p style="margin-top: 30px;">Questions? Reply to this email and we'll help!</p>
                
                <p>With Christmas cheer,<br>The Santa's Letters Team üéÑ</p>
              </div>
            </div>
          </body>
          </html>
        `;

        const emailResponse = await fetch("https://api.resend.com/emails", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${resendApiKey}`,
          },
          body: JSON.stringify({
            from: EMAIL_FROM,
            to: [order.customerInfo.email],
            subject: `üí≥ Subscription Payment Processed - ${amount.toFixed(2)}`,
            html: emailHtml,
          }),
        });

        if (emailResponse.ok) {
          const emailData = await emailResponse.json();
          console.log(`‚úÖ Payment confirmation email sent to ${order.customerInfo.email}`);

          // Log email in activity log
          await logEmailActivity(
            orderId,
            "subscription_charge_email",
            order.customerInfo.email,
            `üí≥ Subscription Payment Processed - ${amount.toFixed(2)}`,
            emailData.id
          );
        } else {
          const errorText = await emailResponse.text();
          console.error("‚ùå Failed to send payment confirmation email:", errorText);
        }
      }
    } catch (emailError) {
      console.error("‚ùå Error sending payment email:", emailError);
      // Don't fail the charge if email fails
    }

    return c.json({
      success: true,
      paymentIntentId: paymentIntent.id,
      amount,
    });
  } catch (error: any) {
    console.error("‚ùå Error charging subscription:", error);
    return c.json({ error: error.message }, 500);
  }
});

// ========== GLOBAL SETTINGS ENDPOINTS ==========

// Get global settings (default prices, etc.)
app.get("/make-server-cf244566/settings", async (c) => {
  try {
    const settings: any = await kv.get("global:settings") || {
      defaultLetterPrice: 17.95,
      updatedAt: new Date().toISOString(),
    };

    // Ensure default values exist
    if (!settings.defaultLetterPrice) {
      settings.defaultLetterPrice = 17.95;
    }

    return c.json(settings);
  } catch (error: any) {
    console.error("‚ùå Error fetching settings:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Update global settings (admin only)
app.post("/make-server-cf244566/admin/update-settings", async (c) => {
  try {
    const { defaultLetterPrice } = await c.req.json();

    if (typeof defaultLetterPrice !== 'number' || defaultLetterPrice <= 0) {
      return c.json({ error: "Invalid price value" }, 400);
    }

    const settings = {
      defaultLetterPrice,
      updatedAt: new Date().toISOString(),
    };

    await kv.set("global:settings", settings);

    console.log(`‚úÖ Updated global settings: defaultLetterPrice = ${defaultLetterPrice}`);
    return c.json({ success: true, settings });
  } catch (error: any) {
    console.error("‚ùå Error updating settings:", error);
    return c.json({ error: error.message }, 500);
  }
});
/*
CORRUPTED DUPLICATE CODE - COMMENTED OUT
}${(session.amount_total ? session.amount_total / 100 : 0).toFixed(2)}`,
          user: 'Customer',
          stripeUrl: `https://dashboard.stripe.com/${session.payment_intent?.toString().startsWith('pi_test') ? 'test' : 'live'}/payments/${session.payment_intent}`
        }],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      console.log("üíæ Saving order to database...");
      
      // Try to get payment method from payment intent for future use
      if (stripe && session.payment_intent && stripeCustomerId) {
        try {
          const paymentIntent = await stripe.paymentIntents.retrieve(session.payment_intent as string);
          if (paymentIntent.payment_method) {
            order.stripePaymentMethodId = paymentIntent.payment_method as string;
            console.log("üí≥ Payment method ID saved:", order.stripePaymentMethodId);
          }
        } catch (pmError) {
          console.warn("‚ö†Ô∏è Could not retrieve payment method:", pmError);
          // Don't fail order if we can't get payment method
        }
      }
      
      try {
        // Save order to database
        await kv.set(`order:${session.id}`, order);
        console.log("‚úÖ Order saved to KV store with customer ID:", stripeCustomerId);
        
        // Add to orders index
        const allOrderIds = (await kv.get("orders:all")) || [];
        console.log("Current order count:", allOrderIds.length);
        allOrderIds.push(session.id);
        await kv.set("orders:all", allOrderIds);
        console.log("‚úÖ Order added to index. New count:", allOrderIds.length);
        
        // Store token -> orderId mapping for quick lookup
        await kv.set(`token:${accessToken}`, session.id);
        console.log("üîê Secure access token mapping created");

        console.log("üéâ Order saved successfully:", session.id);
        
        // Check if this is a repeat customer and create alert
        const existingOrders = allOrderIds.filter((id: string) => id !== session.id);
        let isRepeatCustomer = false;
        let previousOrderId = null;
        
        for (const existingId of existingOrders) {
          const existingOrder: any = await kv.get(`order:${existingId}`);
          if (existingOrder && existingOrder.customerInfo?.email === customerEmail) {
            isRepeatCustomer = true;
            previousOrderId = existingId;
            break;
          }
        }
        
        if (isRepeatCustomer && previousOrderId) {
          await createAdminAlert(
            "new_order_from_existing",
            session.id,
            "üÜï Repeat Customer - New Order!",
            {
              childName: letterPackages[0]?.childFirstName + ' ' + letterPackages[0]?.childLastName,
              packages: numberOfPackages,
              amount: order.total,
              customerEmail: customerEmail,
              previousOrder: `#${previousOrderId.slice(-8)}`
            },
            "medium",
            previousOrderId
          );
        }
      } catch (dbError) {
        console.error("‚ùå DATABASE ERROR saving order:", dbError);
        console.error("Error details:", JSON.stringify(dbError));
        throw dbError; // Re-throw to be caught by outer try-catch
      }

      // Send order confirmation email
      try {
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        if (resendApiKey && customerEmail) {
          // Generate email HTML
          const packagesHtml = letterPackages.map((pkg: any, idx: number) => `
            <div style="background: #fef2f2; border: 2px solid #fecaca; border-radius: 8px; padding: 15px; margin: 15px 0;">
              <p><strong>üì¶ Package ${idx + 1}</strong></p>
              <p><strong>Child:</strong> ${pkg.childFirstName} ${pkg.childLastName}</p>
              <p><strong>Friend:</strong> ${pkg.friendName}</p>
              <p><strong>Shipping to:</strong> ${pkg.streetAddress}${pkg.unitApt ? ', ' + pkg.unitApt : ''}, ${pkg.city}, ${pkg.state} ${pkg.zipCode}</p>
            </div>
          `).join('');

          const emailHtml = `
            <!DOCTYPE html>
            <html>
            <head>
              <meta charset="utf-8">
              <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
            </head>
            <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
              <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                  <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÖ Letter From Santa</h1>
                  <p style="margin: 10px 0 0 0; font-size: 18px;">Order Confirmed!</p>
                </div>
                <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                  <p>Dear ${customerName || 'Valued Customer'},</p>
                  
                  <p><span style="font-size: 24px;">üéâ</span> Thank you for your order! We're excited to help you keep the magic of Christmas alive.</p>
                  
                  <p><strong>Order Number:</strong> #${session.id.slice(-8)}<br>
                  <strong>Order Date:</strong> ${new Date().toLocaleDateString()}<br>
                  <strong>Total Amount:</strong> ${order.total.toFixed(2)}</p>
                  
                  <h3 style="color: #dc2626; margin-top: 30px;">üì¨ Your Letter Packages:</h3>
                  ${packagesHtml}
                  
                  <p style="margin-top: 30px;"><strong>What happens next?</strong></p>
                  <ul>
                    <li>‚ú® We're preparing your personalized letters from Santa</li>
                    <li>üìù Each letter will include a Good Behavior Certificate and Nice List</li>
                    <li>üìÆ Your packages will ship within 2-3 business days</li>
                    <li>üìß You'll receive a shipping notification with tracking</li>
                  </ul>
                  ${monthlySubscription ? `
                  <p style="margin-top: 30px; padding: 20px; background: #fff7ed; border-radius: 8px; border-left: 4px solid #f97316;">
                    <strong>üéÅ Welcome to Santa's Magical Adventures!</strong><br>
                    You're all set! Your subscription will start in January 2026 at $12/month. You can cancel anytime. Get ready for monthly packages filled with heartwarming stories from Santa!
                  </p>
                  ` : ''}
                  
                  <p style="margin-top: 30px; padding: 20px; background: #fef2f2; border-radius: 8px; border-left: 4px solid #dc2626;">
                    <strong>üéÑ Keep the Magic Alive!</strong><br>
                    Make sure to retrieve the mail before your little ones do! üòä
                  </p>
                </div>
                <div style="background: #f9fafb; padding: 20px; text-align: center; color: #6b7280; font-size: 14px; border-radius: 0 0 10px 10px;">
                  <p>Questions? Contact us at support@letterfromsanta.com</p>
                  <p style="margin-top: 10px; color: #9ca3af;">¬© 2025 Letters From Santa. All rights reserved.</p>
                </div>
              </div>
            </body>
            </html>
          `;

          const emailResponse = await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${resendApiKey}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
              to: [customerEmail],
              subject: `üéÖ Your Letters From Santa Order Confirmed! #${session.id.slice(-8)}`,
              html: emailHtml,
            }),
          });

          if (emailResponse.ok) {
            console.log("Order confirmation email sent to:", customerEmail);
          } else {
            console.error("Failed to send confirmation email:", await emailResponse.text());
          }

          // Send SMS if phone number provided
          const twilioSid = Deno.env.get("TWILIO_ACCOUNT_SID");
          const twilioToken = Deno.env.get("TWILIO_AUTH_TOKEN");
          const twilioPhone = Deno.env.get("TWILIO_PHONE_NUMBER");

          if (twilioSid && twilioToken && twilioPhone && customerPhone) {
            const twilioUrl = `https://api.twilio.com/2010-04-01/Accounts/${twilioSid}/Messages.json`;
            const credentials = btoa(`${twilioSid}:${twilioToken}`);

            const formData = new URLSearchParams();
            formData.append("To", customerPhone);
            formData.append("From", twilioPhone);
            formData.append("Body", `üéÖ Thank you! Your Letters From Santa order #${session.id.slice(-8)} is confirmed. We'll send tracking info when it ships! Check your email for details.`);

            const smsResponse = await fetch(twilioUrl, {
              method: "POST",
              headers: {
                Authorization: `Basic ${credentials}`,
                "Content-Type": "application/x-www-form-urlencoded",
              },
              body: formData.toString(),
            });

            if (smsResponse.ok) {
              console.log("Order confirmation SMS sent to:", customerPhone);
            } else {
              console.error("Failed to send confirmation SMS:", await smsResponse.text());
            }
          }
        }
      } catch (error) {
        console.error("Error sending order confirmation notifications:", error);
        // Don't fail the webhook if email/SMS fails
      }

      // Track sale event for affiliate
      if (affiliateId) {
        const eventId = `event_${Date.now()}_${Math.random().toString(36).substring(7)}`;
        const event = {
          eventId,
          affiliateId,
          eventType: "sale",
          orderId: session.id,
          revenue: order.total,
          commission: affiliateCommission,
          subIds: subIds || {},
          timestamp: new Date().toISOString(),
        };

        await kv.set(`event:${eventId}`, event);

        const allEventIds = (await kv.get("events:all")) || [];
        allEventIds.push(eventId);
        await kv.set("events:all", allEventIds);

        // Fire sale postback
        const postbacks = (await kv.get(`postbacks:${affiliateId}`)) || [];
        for (const postback of postbacks) {
          if (postback.enabledEvents && postback.enabledEvents.includes("sale")) {
            try {
              let url = postback.postbackUrl
                .replace('{affiliate_id}', affiliateId)
                .replace('{event_type}', 'sale')
                .replace('{amount}', order.total.toString())
                .replace('{commission}', affiliateCommission.toString())
                .replace('{orderid}', session.id)
                .replace('{timestamp}', event.timestamp);

              // Add sub IDs to URL
              Object.entries(subIds || {}).forEach(([key, value]) => {
                url = url.replace(`{${key}}`, value as string);
              });

              const response = await fetch(url, { method: 'GET' });
              
              const postbackLog = {
                postbackId: `pb_${Date.now()}`,
                affiliateId,
                eventId,
                eventType: "sale",
                orderId: session.id,
                url,
                status: response.ok ? "success" : "failed",
                statusCode: response.status,
                timestamp: new Date().toISOString(),
              };

              await kv.set(`postback_log:${postbackLog.postbackId}`, postbackLog);

              const allPostbackLogs = (await kv.get("postback_logs:all")) || [];
              allPostbackLogs.push(postbackLog.postbackId);
              await kv.set("postback_logs:all", allPostbackLogs);
            } catch (err: any) {
              console.error("Error firing sale postback:", err);
            }
          }
        }
      }
    }

    // Handle chargebacks
    if (event.type === "charge.dispute.created") {
      const dispute = event.data.object as any;
      const chargeId = dispute.charge;
      
      console.log("Chargeback created:", dispute.id);

      try {
        // Find the order associated with this charge
        const allOrderIds = (await kv.get("orders:all")) || [];
        let affectedOrder: any = null;
        
        for (const orderId of allOrderIds) {
          const order: any = await kv.get(`order:${orderId}`);
          if (order && order.sessionId && order.sessionId.includes(chargeId)) {
            affectedOrder = order;
            break;
          }
        }

        if (affectedOrder) {
          const chargebackId = `cb_${Date.now()}_${Math.random().toString(36).substring(7)}`;
          
          const chargeback = {
            chargebackId,
            orderId: affectedOrder.orderId,
            sessionId: affectedOrder.sessionId,
            affiliateId: affectedOrder.affiliateId || "direct",
            affiliateName: affectedOrder.affiliateName || "Direct Sale",
            amount: affectedOrder.total || 0,
            commission: affectedOrder.affiliateCommission || 0,
            reason: dispute.reason || "unknown",
            stripeChargeId: chargeId,
            stripeDisputeId: dispute.id,
            chargebackDate: new Date().toISOString(),
            orderDate: affectedOrder.orderDate,
            status: "pending",
            customerEmail: affectedOrder.customerInfo?.email || "",
            createdAt: new Date().toISOString(),
          };

          // Save chargeback
          await kv.set(`chargeback:${chargebackId}`, chargeback);
          
          const allChargebacks = (await kv.get("chargebacks:all")) || [];
          allChargebacks.push(chargebackId);
          await kv.set("chargebacks:all", allChargebacks);

          // Update order status
          affectedOrder.status = "chargeback";
          affectedOrder.chargebackId = chargebackId;
          affectedOrder.updatedAt = new Date().toISOString();
          await kv.set(`order:${affectedOrder.sessionId}`, affectedOrder);

          console.log("Chargeback recorded:", chargebackId);
        }
      } catch (error) {
        console.error("Error processing chargeback:", error);
      }
    }

    // Handle chargeback updates
    if (event.type === "charge.dispute.closed") {
      const dispute = event.data.object as any;
      
      // Find the chargeback
      const allChargebacks = (await kv.get("chargebacks:all")) || [];
      for (const chargebackId of allChargebacks) {
        const chargeback: any = await kv.get(`chargeback:${chargebackId}`);
        if (chargeback && chargeback.stripeDisputeId === dispute.id) {
          chargeback.status = dispute.status === "won" ? "won" : "lost";
          chargeback.updatedAt = new Date().toISOString();
          await kv.set(`chargeback:${chargebackId}`, chargeback);
          
          console.log(`Chargeback ${chargebackId} updated to: ${chargeback.status}`);
          break;
        }
      }
    }

    // Handle payment declines
    if (event.type === "payment_intent.payment_failed") {
      const paymentIntent = event.data.object as any;
      
      console.log("Payment declined:", paymentIntent.id);

      const declineId = `dec_${Date.now()}_${Math.random().toString(36).substring(7)}`;
      
      const decline = {
        declineId,
        paymentIntentId: paymentIntent.id,
        amount: paymentIntent.amount / 100,
        reason: paymentIntent.last_payment_error?.message || "unknown",
        customerEmail: paymentIntent.receipt_email || "",
        declineDate: new Date().toISOString(),
        createdAt: new Date().toISOString(),
      };

      await kv.set(`decline:${declineId}`, decline);
      
      const allDeclines = (await kv.get("declines:all")) || [];
      allDeclines.push(declineId);
      await kv.set("declines:all", allDeclines);
    }

    // Handle successful subscription payments (recurring charges)
    if (event.type === "invoice.payment_succeeded") {
      const invoice = event.data.object as any;
      
      // Skip if this is the initial $0 invoice
      if (invoice.amount_paid === 0 || invoice.billing_reason === "subscription_create") {
        console.log("Skipping $0 or initial subscription invoice");
        return c.json({ received: true });
      }

      console.log("üí≥ Subscription payment succeeded:", invoice.id, "Amount:", invoice.amount_paid / 100);

      // Find the parent order by subscription ID
      const allOrderIds = (await kv.get("orders:all")) || [];
      let parentOrder: any = null;
      
      for (const orderId of allOrderIds) {
        const order: any = await kv.get(`order:${orderId}`);
        if (order && order.subscriptionId === invoice.subscription) {
          parentOrder = order;
          break;
        }
      }

      if (parentOrder) {
        console.log("Found parent order:", parentOrder.orderId);
        
        // Increment successful charges
        parentOrder.successfulCharges = (parentOrder.successfulCharges || 0) + 1;
        parentOrder.subscriptionMonthsActive = parentOrder.successfulCharges;
        
        // Update next billing date
        const billingInterval = parentOrder.billingIntervalDays || 30;
        const nextBilling = new Date();
        nextBilling.setDate(nextBilling.getDate() + billingInterval);
        parentOrder.subscriptionNextBillingDate = nextBilling.toISOString();
        
        // Add activity log
        if (!parentOrder.activityLog) {
          parentOrder.activityLog = [];
        }
        parentOrder.activityLog.push({
          timestamp: new Date().toISOString(),
          action: 'Subscription Payment Received',
          details: `Charged ${(invoice.amount_paid / 100).toFixed(2)}. Month ${parentOrder.successfulCharges}. Next billing: ${nextBilling.toLocaleDateString()}. Invoice: ${invoice.id}`,
          user: 'Stripe Webhook',
          stripeUrl: `https://dashboard.stripe.com/invoices/${invoice.id}`
        });
        
        await kv.set(`order:${parentOrder.orderId}`, parentOrder);
        
        // Create a new order for this month's fulfillment
        console.log(`üì¶ [Webhook] Creating fulfillment order. Subscription letters count: ${(parentOrder.subscriptionLetters || []).length}`);
        console.log(`üì¶ [Webhook] Subscription letters data:`, JSON.stringify(parentOrder.subscriptionLetters));
        
        const newOrderId = `ord_${Date.now()}_${Math.random().toString(36).substring(7)}`;
        
        // Generate secure access token for this recurring order
        const recurringAccessToken = `oat_${Array.from(crypto.getRandomValues(new Uint8Array(32)))
          .map(b => b.toString(16).padStart(2, '0'))
          .join('')}`;
        
        const newOrder = {
          orderId: newOrderId,
          accessToken: recurringAccessToken, // Add access token for customer order lookup
          parentOrderId: parentOrder.orderId,
          subscriptionId: parentOrder.subscriptionId,
          sessionId: invoice.id,
          stripePaymentId: invoice.payment_intent,
          stripeCheckoutUrl: `https://dashboard.stripe.com/invoices/${invoice.id}`,
          orderDate: new Date().toISOString(),
          status: "pending",
          total: invoice.amount_paid / 100,
          customerInfo: parentOrder.customerInfo,
          letterPackages: parentOrder.letterPackages,
          numberOfPackages: parentOrder.numberOfPackages,
          letters: parentOrder.subscriptionLetters || [], // Copy subscription letter data for fulfillment
          shippingDate: "",
          monthlySubscription: false,
          subscriptionRecurringOrder: true,
          subscriptionMonth: parentOrder.successfulCharges,
          subscriptionProductName: parentOrder.subscriptionProductName || "Santa's Magical Journey",
          affiliateId: parentOrder.affiliateId,
          affiliateName: parentOrder.affiliateName,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          activityLog: [{
            timestamp: new Date().toISOString(),
            action: 'Order Created',
            details: `Recurring subscription order - Month ${parentOrder.successfulCharges}. Copied ${(parentOrder.subscriptionLetters || []).length} letter(s) from subscription.`,
            user: 'Stripe Webhook'
          }]
        };
        
        await kv.set(`order:${newOrderId}`, newOrder);
        allOrderIds.push(newOrderId);
        await kv.set("orders:all", allOrderIds);
        
        // Store token -> orderId mapping for quick lookup
        await kv.set(`token:${recurringAccessToken}`, newOrderId);
        
        console.log(`‚úÖ Created new order ${newOrderId} for subscription payment`);
        
        // Send email notification
        try {
          const resendApiKey = Deno.env.get("RESEND_API_KEY");
          if (resendApiKey && parentOrder.customerInfo?.email) {
            const emailResponse = await fetch("https://api.resend.com/emails", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${resendApiKey}`,
              },
              body: JSON.stringify({
                from: EMAIL_FROM,
                to: [parentOrder.customerInfo.email],
                subject: `üéÖ Your Month ${parentOrder.successfulCharges} Santa Letter is Coming!`,
                html: `
                  <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                    <h2 style="color: #dc2626;">üéÑ Ho Ho Ho!</h2>
                    <p>Dear ${parentOrder.customerInfo.name},</p>
                    <p>Great news! Your monthly Santa letter subscription payment has been processed successfully.</p>
                    <p><strong>Amount Charged:</strong> ${(invoice.amount_paid / 100).toFixed(2)}</p>
                    <p><strong>Subscription Month:</strong> ${parentOrder.successfulCharges}</p>
                    <p><strong>Product:</strong> ${parentOrder.subscriptionProductName || "Santa's Magical Journey"}</p>
                    <p>Your magical letter will be prepared and shipped soon!</p>
                    <p><strong>Next Billing Date:</strong> ${nextBilling.toLocaleDateString()}</p>
                    <p style="color: #059669;">Thank you for continuing this magical journey with us! üéÖ‚ú®</p>
                  </div>
                `,
              }),
            });
            
            if (emailResponse.ok) {
              const emailData = await emailResponse.json();
              console.log("‚úÖ Sent subscription payment notification email. Email ID:", emailData.id);
              
              // Log email activity
              await logEmailActivity(
                parentOrder.orderId,
                'subscription_payment',
                parentOrder.customerInfo.email,
                'Subscription Payment Confirmation',
                emailData.id
              );
            }
          }
        } catch (emailError) {
          console.error("Error sending subscription payment email:", emailError);
        }
      }
    }

    // Handle failed subscription payments
    if (event.type === "invoice.payment_failed") {
      const invoice = event.data.object as any;
      
      console.log("‚ùå Subscription payment failed:", invoice.id);

      // Find the parent order
      const allOrderIds = (await kv.get("orders:all")) || [];
      for (const orderId of allOrderIds) {
        const order: any = await kv.get(`order:${orderId}`);
        if (order && order.subscriptionId === invoice.subscription) {
          // Increment declined charges
          order.declinedCharges = (order.declinedCharges || 0) + 1;
          
          // Add activity log
          if (!order.activityLog) {
            order.activityLog = [];
          }
          order.activityLog.push({
            timestamp: new Date().toISOString(),
            action: 'Subscription Payment Failed',
            details: `Payment declined for ${(invoice.amount_due / 100).toFixed(2)}. Total declined: ${order.declinedCharges}. Invoice: ${invoice.id}`,
            user: 'Stripe Webhook',
            stripeUrl: `https://dashboard.stripe.com/invoices/${invoice.id}`
          });
          
          await kv.set(`order:${orderId}`, order);
          
          // Send email notification
          try {
            const resendApiKey = Deno.env.get("RESEND_API_KEY");
            if (resendApiKey && order.customerInfo?.email) {
              const emailResponse = await fetch("https://api.resend.com/emails", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  Authorization: `Bearer ${resendApiKey}`,
                },
                body: JSON.stringify({
                  from: EMAIL_FROM,
                  to: [order.customerInfo.email],
                  subject: "‚ö†Ô∏è Santa Letter Subscription - Payment Issue",
                  html: `
                    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                      <h2 style="color: #dc2626;">Payment Issue with Your Subscription</h2>
                      <p>Dear ${order.customerInfo.name},</p>
                      <p>We encountered an issue processing your monthly Santa letter subscription payment.</p>
                      <p><strong>Amount:</strong> ${(invoice.amount_due / 100).toFixed(2)}</p>
                      <p>Please update your payment method to continue receiving your magical letters.</p>
                      <p>If you have any questions, please contact us.</p>
                      <p style="color: #6b7280;">üéÑ Santa's Workshop</p>
                    </div>
                  `,
                }),
              });
              
              if (emailResponse.ok) {
                const emailData = await emailResponse.json();
                console.log("‚úÖ Sent payment failed email. Email ID:", emailData.id);
                
                // Log email activity
                await logEmailActivity(
                  orderId,
                  'payment_failed',
                  order.customerInfo.email,
                  'Payment Failed Notification',
                  emailData.id
                );
              }
            }
          } catch (emailError) {
            console.error("Error sending payment failed email:", emailError);
          }
          
          console.log(`‚úÖ Updated order ${orderId} with declined charge`);
          break;
        }
      }
    }

    console.log("‚úÖ Webhook processed successfully");
    console.log("========== WEBHOOK COMPLETE ==========\n");
    return c.json({ received: true });
  } catch (err: any) {
    console.error("‚ùå‚ùå‚ùå WEBHOOK ERROR ‚ùå‚ùå‚ùå");
    console.error("Error type:", err.constructor.name);
    console.error("Error message:", err.message);
    console.error("Error stack:", err.stack);
    console.error("Full error:", JSON.stringify(err, null, 2));
    console.error("========== WEBHOOK FAILED ==========\n");
    return c.json({ error: err.message }, 400);
  }
});

// TESTING: Simulate a webhook call (for debugging webhook handler)
app.post("/make-server-cf244566/test-webhook-simulation", async (c) => {
  console.log("üß™ WEBHOOK SIMULATION STARTED");
  
  try {
    const testSessionId = `cs_test_sim_${Date.now()}`;
    
    // Simulate what the webhook handler does
    const letterPackages = [{
      childFirstName: "Webhook",
      childLastName: "Test",
      friendName: "Test Friend",
      streetAddress: "123 Webhook St",
      unitApt: "",
      city: "Test City",
      state: "CA",
      zipCode: "12345",
    }];
    
    const order = {
      orderId: testSessionId,
      sessionId: testSessionId,
      stripePaymentId: `pi_webhook_test_${Date.now()}`,
      stripeCheckoutUrl: `https://dashboard.stripe.com/test/payments/pi_webhook_test_${Date.now()}`,
      orderDate: new Date().toISOString(),
      status: "pending",
      total: 17.95,
      customerInfo: {
        email: "webhook-test@test.com",
        name: "Webhook Test Customer",
        phone: "5555555555",
        address: {
          line1: "123 Webhook St",
          line2: "",
          city: "Test City",
          state: "CA",
          postal_code: "12345",
          country: "US",
        },
      },
      letterPackages,
      numberOfPackages: 1,
      shippingDate: "December 15th",
      monthlySubscription: false,
      subscriptionId: null,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    console.log("Simulating order save...");
    await kv.set(`order:${testSessionId}`, order);
    
    const allOrderIds = (await kv.get("orders:all")) || [];
    allOrderIds.push(testSessionId);
    await kv.set("orders:all", allOrderIds);
    
    console.log("‚úÖ Webhook simulation complete - order created:", testSessionId);
    
    return c.json({ 
      success: true, 
      message: "Webhook simulation successful",
      orderId: testSessionId,
      note: "This simulates what the Stripe webhook does. Check admin dashboard!"
    });
  } catch (error: any) {
    console.error("‚ùå Webhook simulation failed:", error);
    return c.json({ error: error.message }, 500);
  }
});

// TESTING: Create a test order manually (for debugging)
app.post("/make-server-cf244566/test-order", async (c) => {
  try {
    const testOrderId = `test_order_${Date.now()}`;
    
    const testOrder = {
      orderId: testOrderId,
      sessionId: testOrderId,
      stripePaymentId: `pi_test_${Date.now()}`,
      stripeCheckoutUrl: `https://dashboard.stripe.com/test/payments/pi_test_${Date.now()}`,
      orderDate: new Date().toISOString(),
      status: "pending",
      total: 17.95,
      customerInfo: {
        name: "Test Customer",
        email: "test@test.com",
        phone: "5555555555",
        address: {
          line1: "123 Test St",
          line2: "",
          city: "Test City",
          state: "CA",
          postal_code: "12345",
          country: "US",
        },
      },
      letterPackages: [{
        childFirstName: "Test",
        childLastName: "Child",
        friendName: "Best Friend",
        streetAddress: "123 Test St",
        unitApt: "",
        city: "Test City",
        state: "CA",
        zipCode: "12345",
      }],
      numberOfPackages: 1,
      shippingDate: "December 15th",
      monthlySubscription: false,
      subscriptionId: null,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    // Save the order
    await kv.set(`order:${testOrderId}`, testOrder);
    
    // Add to orders list
    const allOrderIds = (await kv.get("orders:all")) || [];
    allOrderIds.push(testOrderId);
    await kv.set("orders:all", allOrderIds);

    console.log("Test order created:", testOrderId);
    
    return c.json({ 
      success: true, 
      orderId: testOrderId,
      message: "Test order created successfully" 
    });
  } catch (error: any) {
    console.error("Error creating test order:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Get all orders (admin only)
app.get("/make-server-cf244566/orders", async (c) => {
  try {
    const allOrderIds = (await kv.get("orders:all")) || [];
    
    // Fetch all orders
    const orders = [];
    for (const orderId of allOrderIds) {
      const order = await kv.get(`order:${orderId}`);
      if (order) {
        orders.push(order);
      }
    }

    // Sort by date (newest first)
    orders.sort((a: any, b: any) => new Date(b.orderDate).getTime() - new Date(a.orderDate).getTime());

    return c.json({ orders });
  } catch (error: any) {
    console.error("Error fetching orders:", error);
    return c.json({ error: "Failed to fetch orders" }, 500);
  }
});

// Get admin alerts
app.get("/make-server-cf244566/admin/alerts", async (c) => {
  try {
    const alertIds = (await kv.getByPrefix("admin_alert:")) || [];
    
    const alerts = [];
    for (const item of alertIds) {
      if (item.value) {
        alerts.push(item.value);
      }
    }

    // Sort by date (newest first)
    alerts.sort((a: any, b: any) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());

    // Count unread
    const unreadCount = alerts.filter((a: any) => a.status === "unread").length;

    return c.json({ alerts, unreadCount });
  } catch (error: any) {
    console.error("Error fetching alerts:", error);
    return c.json({ error: "Failed to fetch alerts" }, 500);
  }
});

// Mark alert as read
app.patch("/make-server-cf244566/admin/alerts/:alertId/read", async (c) => {
  try {
    const alertId = c.req.param("alertId");
    const alert: any = await kv.get(`admin_alert:${alertId}`);
    
    if (!alert) {
      return c.json({ error: "Alert not found" }, 404);
    }

    alert.status = "read";
    alert.readAt = new Date().toISOString();
    
    await kv.set(`admin_alert:${alertId}`, alert);

    return c.json({ success: true, alert });
  } catch (error: any) {
    console.error("Error marking alert as read:", error);
    return c.json({ error: "Failed to mark alert as read" }, 500);
  }
});

// Mark all alerts as read
app.post("/make-server-cf244566/admin/alerts/read-all", async (c) => {
  try {
    const alertIds = (await kv.getByPrefix("admin_alert:")) || [];
    
    for (const item of alertIds) {
      if (item.value && item.value.status === "unread") {
        item.value.status = "read";
        item.value.readAt = new Date().toISOString();
        await kv.set(item.key, item.value);
      }
    }

    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error marking all alerts as read:", error);
    return c.json({ error: "Failed to mark alerts as read" }, 500);
  }
});

// Delete alert
app.delete("/make-server-cf244566/admin/alerts/:alertId", async (c) => {
  try {
    const alertId = c.req.param("alertId");
    await kv.del(`admin_alert:${alertId}`);

    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error deleting alert:", error);
    return c.json({ error: "Failed to delete alert" }, 500);
  }
});

// Get single order by ID
app.get("/make-server-cf244566/orders/:orderId", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const order = await kv.get(`order:${orderId}`);

    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    return c.json({ order });
  } catch (error: any) {
    console.error("Error fetching order:", error);
    return c.json({ error: "Failed to fetch order" }, 500);
  }
});

// Get order by access token (for success page)
app.get("/make-server-cf244566/order/:token", async (c) => {
  try {
    const token = c.req.param("token");
    console.log(`üîç Looking up order by token: ${token?.substring(0, 15)}...`);
    
    // Search for order by access token
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    // Legacy support: try direct order ID lookup first
    if (!token.startsWith("oat_")) {
      order = await kv.get(`order:${token}`);
      if (order) {
        console.log(`‚úÖ Found order by direct ID (legacy): ${order.orderId}`);
      }
    }
    
    // Try to find by access token
    if (!order) {
      for (const orderId of allOrderIds) {
        const orderData: any = await kv.get(`order:${orderId}`);
        if (orderData && orderData.accessToken === token) {
          order = orderData;
          console.log(`‚úÖ Found order by access token: ${order.orderId}`);
          break;
        }
      }
    }
    
    if (!order) {
      console.error("‚ùå Order not found for token");
      return c.json({ error: "Order not found" }, 404);
    }
    
    // AUTO-FIX: If customer ID is missing, try to retrieve or create it
    if (!order.stripeCustomerId && stripe) {
      console.log("üîß AUTO-FIXING: Missing customer ID for order:", order.orderId);
      try {
        let customerId = null;
        
        // Try to get customer from payment intent first
        if (order.stripePaymentId) {
          try {
            const paymentIntent = await stripe.paymentIntents.retrieve(order.stripePaymentId);
            if (paymentIntent.customer) {
              customerId = paymentIntent.customer as string;
              console.log("‚úÖ Found customer ID from payment intent:", customerId);
              
              // Also get payment method if available
              if (paymentIntent.payment_method && !order.stripePaymentMethodId) {
                order.stripePaymentMethodId = paymentIntent.payment_method as string;
              }
            }
          } catch (piError: any) {
            console.log("‚ö†Ô∏è Could not retrieve payment intent:", piError.message);
          }
        }
        
        // If still no customer, create a new one from order data
        if (!customerId && order.customerInfo?.email) {
          console.log("üÜï Creating new Stripe customer for order:", order.orderId);
          const customer = await stripe.customers.create({
            email: order.customerInfo.email,
            name: order.customerInfo.name || "Customer",
            phone: order.customerInfo.phone || undefined,
            address: order.customerInfo.address ? {
              line1: order.customerInfo.address.line1 || undefined,
              line2: order.customerInfo.address.line2 || undefined,
              city: order.customerInfo.address.city || undefined,
              state: order.customerInfo.address.state || undefined,
              postal_code: order.customerInfo.address.postal_code || undefined,
              country: order.customerInfo.address.country || "US"
            } : undefined,
            metadata: {
              orderId: order.orderId,
              source: "auto-fix-migration"
            }
          });
          customerId = customer.id;
          console.log("‚úÖ Created new Stripe customer:", customerId);
        }
        
        // Save customer ID to order
        if (customerId) {
          order.stripeCustomerId = customerId;
          await kv.set(`order:${order.orderId}`, order);
          console.log("‚úÖ AUTO-FIXED: Saved customer ID to order");
        } else {
          console.error("‚ùå Could not fix customer ID - no email address available");
        }
      } catch (error: any) {
        console.error("‚ùå Auto-fix failed:", error.message);
      }
    }
    
    return c.json({ order });
  } catch (error: any) {
    console.error("Error fetching order by token:", error);
    return c.json({ error: "Failed to fetch order" }, 500);
  }
});

// Update order status (POST /orders/:orderId/status - used by admin dashboard)
app.post("/make-server-cf244566/orders/:orderId/status", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const body = await c.req.json();
    const { status } = body;

    console.log(`üìù Updating order ${orderId} status to: ${status}`);

    const order: any = await kv.get(`order:${orderId}`);

    if (!order) {
      console.error(`‚ùå Order ${orderId} not found`);
      return c.json({ error: "Order not found" }, 404);
    }

    const oldStatus = order.status;
    
    // Add activity log entry
    if (!order.activityLog) order.activityLog = [];
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Status Changed',
      details: `Status changed from "${oldStatus}" to "${status}"`,
      user: 'Admin'
    });
    
    order.status = status;
    order.updatedAt = new Date().toISOString();

    await kv.set(`order:${orderId}`, order);
    console.log(`‚úÖ Order ${orderId} status updated successfully`);

    return c.json({ success: true, order });
  } catch (error: any) {
    console.error("Error updating order status:", error);
    return c.json({ error: error.message || "Failed to update status" }, 500);
  }
});

// Update order status (PATCH /orders/:orderId - legacy)
app.patch("/make-server-cf244566/orders/:orderId", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const body = await c.req.json();
    const { status } = body;

    const order: any = await kv.get(`order:${orderId}`);

    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    const oldStatus = order.status;
    order.status = status;
    order.updatedAt = new Date().toISOString();

    await kv.set(`order:${orderId}`, order);

    // Send canceled notification if order was canceled
    if (status === "canceled-refunded" && oldStatus !== "canceled-refunded") {
      try {
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        const customerEmail = order.customerInfo?.email;
        const customerName = order.customerInfo?.name || "Valued Customer";

        if (resendApiKey && customerEmail) {
          const emailHtml = `
            <!DOCTYPE html>
            <html>
            <body style="font-family: Arial, sans-serif;">
              <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <h1>Order Canceled</h1>
                <p>Dear ${customerName},</p>
                <p>Your order <strong>#${orderId.slice(-8)}</strong> has been canceled.</p>
                <p>If you have questions, please contact support@letterfromsanta.com</p>
              </div>
            </body>
            </html>
          `;

          const emailResponse = await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${resendApiKey}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
              to: [customerEmail],
              subject: `Order Canceled - #${orderId.slice(-8)}`,
              html: emailHtml,
            }),
          });
          
          if (emailResponse.ok) {
            const emailData = await emailResponse.json();
            console.log("‚úÖ Sent order canceled email. Email ID:", emailData.id);
            
            // Log email activity
            await logEmailActivity(
              orderId,
              'order_canceled',
              customerEmail,
              'Order Canceled Notification',
              emailData.id
            );
          }
        }
      } catch (error) {
        console.error("Error sending canceled notification:", error);
      }
    }

    return c.json({ order });
  } catch (error: any) {
    console.error("Error updating order:", error);
    return c.json({ error: "Failed to update order" }, 500);
  }
});

// Edit order letter data (admin only, unfulfilled orders)
app.patch("/make-server-cf244566/orders/:orderId/letter-data", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const body = await c.req.json();
    const { letterPackages } = body;

    const order: any = await kv.get(`order:${orderId}`);

    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    if (order.status === "fulfilled") {
      return c.json({ error: "Cannot edit fulfilled orders" }, 400);
    }

    // Track changes
    const changes: string[] = [];
    const oldPackages = order.letterPackages || [];

    letterPackages.forEach((newPkg: any, idx: number) => {
      const oldPkg = oldPackages[idx];
      if (oldPkg) {
        if (oldPkg.childFirstName !== newPkg.childFirstName || oldPkg.childLastName !== newPkg.childLastName) {
          changes.push(`Child name updated for package ${idx + 1}`);
        }
        if (oldPkg.friendName !== newPkg.friendName) {
          changes.push(`Friend name updated for package ${idx + 1}`);
        }
        if (oldPkg.streetAddress !== newPkg.streetAddress || oldPkg.city !== newPkg.city) {
          changes.push(`Address updated for package ${idx + 1}`);
        }
      }
    });

    order.letterPackages = letterPackages;
    order.numberOfPackages = letterPackages.length;
    order.updatedAt = new Date().toISOString();

    await kv.set(`order:${orderId}`, order);

    // Send change notification and create admin alert
    if (changes.length > 0) {
      // Create admin alert
      const alert = {
        id: `alert-${Date.now()}`,
        type: "order_edited",
        orderId: orderId,
        message: `Order edited by customer. Admin review required before shipping.`,
        details: {
          changes: changes,
          editedBy: "Customer",
          totalPackages: letterPackages.length,
        },
        status: "unread",
        priority: "medium",
        createdAt: new Date().toISOString(),
      };
      await kv.set(`admin_alert:${alert.id}`, alert);
      
      try {
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        const customerEmail = order.customerInfo?.email;
        const customerName = order.customerInfo?.name || "Valued Customer";

        if (resendApiKey && customerEmail) {
          const changesHtml = changes.map(c => `<li>${c}</li>`).join('');
          const emailHtml = `
            <!DOCTYPE html>
            <html>
            <body style="font-family: Arial, sans-serif;">
              <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <h1>‚úèÔ∏è Order Updated</h1>
                <p>Dear ${customerName},</p>
                <p>Your order <strong>#${orderId.slice(-8)}</strong> has been updated.</p>
                <h3>Changes Made:</h3>
                <ul>${changesHtml}</ul>
                <div style="background-color: #fef3c7; padding: 15px; border-radius: 5px; margin: 20px 0;">
                  <strong>‚ö†Ô∏è Important:</strong> Our team will review and confirm these changes before shipping your order.
                </div>
                <p>Questions? Contact support@letterfromsanta.com</p>
              </div>
            </body>
            </html>
          `;

          const emailResponse = await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${resendApiKey}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
              to: [customerEmail],
              subject: `‚úèÔ∏è Order Updated - #${orderId.slice(-8)}`,
              html: emailHtml,
            }),
          });
          
          if (emailResponse.ok) {
            const emailData = await emailResponse.json();
            console.log("‚úÖ Sent customer edit notification email. Email ID:", emailData.id);
            
            // Log email activity
            await logEmailActivity(
              orderId,
              'customer_edit',
              customerEmail,
              'Customer Edit Notification',
              emailData.id
            );
          }
        }
      } catch (error) {
        console.error("Error sending change notification:", error);
      }
    }

    return c.json({ order, changes });
  } catch (error: any) {
    console.error("Error editing order:", error);
    return c.json({ error: "Failed to edit order" }, 500);
  }
});

// Add child to existing order or create new order
app.post("/make-server-cf244566/order/add-child", async (c) => {
  try {
    const body = await c.req.json();
    const { orderToken, childrenData, numberOfPackages, addNorthPoleSnow, packagePrice, paymentMethodId, isFulfilled } = body;

    // Find the original order
    const order: any = await kv.get(`order:${orderToken}`);
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    const stripe = new Stripe(Deno.env.get("STRIPE_SECRET_KEY")!);
    const northPoleSnowPrice = 9.99;
    const packagesTotal = packagePrice * numberOfPackages;
    const snowTotal = addNorthPoleSnow ? northPoleSnowPrice : 0;
    const totalAmount = packagesTotal + snowTotal;

    // Create payment intent
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(totalAmount * 100),
      currency: "usd",
      payment_method: paymentMethodId,
      confirm: true,
      automatic_payment_methods: {
        enabled: true,
        allow_redirects: "never",
      },
      description: `Additional ${numberOfPackages} letter package(s)${addNorthPoleSnow ? ' + North Pole Snow' : ''}`,
      metadata: {
        originalOrderId: order.orderId,
        orderType: isFulfilled ? "new_order" : "order_update",
        numberOfPackages: numberOfPackages.toString(),
        includesNorthPoleSnow: addNorthPoleSnow.toString(),
      },
    });

    if (paymentIntent.status !== "succeeded") {
      return c.json({ error: "Payment failed" }, 400);
    }

    // Build child names list (used in both branches)
    const childNames = childrenData.map((c: any) => `${c.childFirstName} ${c.childLastName}`).join(', ');

    if (isFulfilled) {
      // CREATE NEW ORDER
      const newOrderId = `ORD-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      const newOrder = {
        orderId: newOrderId,
        orderDate: new Date().toISOString(),
        status: "pending",
        total: totalAmount,
        customerInfo: order.customerInfo,
        letterPackages: childrenData,
        numberOfPackages: numberOfPackages,
        shippingDate: order.shippingDate,
        monthlySubscription: false,
        includesNorthPoleSnow: addNorthPoleSnow,
        northPoleSnowPrice: addNorthPoleSnow ? northPoleSnowPrice : 0,
        stripePaymentIntentId: paymentIntent.id,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        relatedOrderId: order.orderId, // Link to original order
        orderSource: "add_child_fulfilled",
        activityLog: [{
          timestamp: new Date().toISOString(),
          action: "Order Created",
          details: `New order created from existing order ${order.orderId}. ${numberOfPackages} package(s)${addNorthPoleSnow ? ' + North Pole Snow' : ''}`,
          user: "Customer"
        }]
      };

      await kv.set(`order:${newOrderId}`, newOrder);
      
      // Add to orders list
      const allOrderIds = (await kv.get("orders:all")) || [];
      allOrderIds.push(newOrderId);
      await kv.set("orders:all", allOrderIds);

      // Create admin alert
      const alert = {
        id: `alert-${Date.now()}`,
        type: "new_order_from_existing",
        orderId: newOrderId,
        relatedOrderId: order.orderId,
        message: `New order created by customer. Original order ${order.orderId} was already fulfilled.`,
        details: {
          children: childNames,
          packages: numberOfPackages,
          includesNorthPoleSnow: addNorthPoleSnow,
          amount: totalAmount,
        },
        status: "unread",
        createdAt: new Date().toISOString(),
      };
      await kv.set(`admin_alert:${alert.id}`, alert);

      // Send confirmation email
      try {
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        if (resendApiKey && order.customerInfo?.email) {
          const emailResponse = await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              Authorization: `Bearer ${resendApiKey}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              from: "Santa's Letters <orders@santasletters.com>",
              to: order.customerInfo.email,
              subject: `New Order Confirmed! Order #${newOrderId.slice(-8)}`,
              html: `
                <h2>üéÖ New Letter Package Order Confirmed!</h2>
                <p>Dear ${order.customerInfo.name},</p>
                <p>We've created a new order for your additional letter ${numberOfPackages > 1 ? 'packages' : 'package'}!</p>
                <h3>Order Details:</h3>
                <ul>
                  <li><strong>Order Number:</strong> ${newOrderId.slice(-8)}</li>
                  <li><strong>Children:</strong> ${childNames}</li>
                  <li><strong>Packages:</strong> ${numberOfPackages}</li>
                  ${addNorthPoleSnow ? '<li><strong>North Pole Snow:</strong> Included ‚ùÑÔ∏è</li>' : ''}
                  <li><strong>Total:</strong> ${totalAmount.toFixed(2)}</li>
                </ul>
                <p>Your original order (#${order.orderId.slice(-8)}) has already been shipped, so this will be processed as a separate order.</p>
                <p>Thank you for spreading more Christmas magic! üéÑ</p>
              `,
            }),
          });
          
          if (emailResponse.ok) {
            const emailData = await emailResponse.json();
            console.log("‚úÖ Sent new order confirmation email. Email ID:", emailData.id);
            
            // Log email activity to the NEW order
            await logEmailActivity(
              newOrderId,
              'new_order_confirmation',
              order.customerInfo.email,
              'New Order Confirmation',
              emailData.id
            );
          }
        }
      } catch (emailError) {
        console.error("Error sending email:", emailError);
      }

      return c.json({ 
        success: true, 
        orderCreated: true,
        orderId: newOrderId,
        message: "New order created successfully" 
      });
    } else {
      // UPDATE EXISTING ORDER
      const updatedPackages = [...order.letterPackages, ...childrenData];

      const oldTotal = order.total || 0;
      const newTotal = oldTotal + totalAmount;
      
      // Update North Pole Snow if added
      if (addNorthPoleSnow) {
        order.includesNorthPoleSnow = true;
        order.northPoleSnowPrice = (order.northPoleSnowPrice || 0) + northPoleSnowPrice;
      }

      order.letterPackages = updatedPackages;
      order.numberOfPackages = updatedPackages.length;
      order.total = newTotal;
      order.updatedAt = new Date().toISOString();

      // Add to activity log
      if (!order.activityLog) order.activityLog = [];
      order.activityLog.push({
        timestamp: new Date().toISOString(),
        action: "Packages Added",
        details: `Customer added ${numberOfPackages} package(s) for ${childNames}${addNorthPoleSnow ? ' + North Pole Snow' : ''}. Payment: ${totalAmount.toFixed(2)}`,
        user: "Customer",
        stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntent.id}`
      });

      // Track additional payment
      if (!order.additionalPayments) order.additionalPayments = [];
      order.additionalPayments.push({
        amount: totalAmount,
        paymentIntentId: paymentIntent.id,
        timestamp: new Date().toISOString(),
        reason: "Additional letter package",
      });

      await kv.set(`order:${orderToken}`, order);

      // Create admin alert
      const alert = {
        id: `alert-${Date.now()}`,
        type: "order_updated",
        orderId: order.orderId,
        message: `Customer added ${numberOfPackages} package(s)${addNorthPoleSnow ? ' + North Pole Snow' : ''} to unfulfilled order. Please review changes before shipping.`,
        details: {
          children: childNames,
          packagesAdded: numberOfPackages,
          includesNorthPoleSnow: addNorthPoleSnow,
          additionalAmount: totalAmount,
          newTotal: newTotal,
          totalPackages: updatedPackages.length,
        },
        status: "unread",
        priority: "high",
        createdAt: new Date().toISOString(),
      };
      await kv.set(`admin_alert:${alert.id}`, alert);

      // Send confirmation email
      try {
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        if (resendApiKey && order.customerInfo?.email) {
          const emailResponse = await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              Authorization: `Bearer ${resendApiKey}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              from: "Santa's Letters <orders@santasletters.com>",
              to: order.customerInfo.email,
              subject: `Order Updated - Added Letter Package(s)`,
              html: `
                <h2>üéÖ Order Updated Successfully!</h2>
                <p>Dear ${order.customerInfo.name},</p>
                <p>We've added ${numberOfPackages} letter package(s)${addNorthPoleSnow ? ' + Certified North Pole Snow ‚ùÑÔ∏è' : ''} to your order!</p>
                <h3>Updated Order Details:</h3>
                <ul>
                  <li><strong>Order Number:</strong> ${order.orderId.slice(-8)}</li>
                  <li><strong>Children Added:</strong> ${childNames}</li>
                  <li><strong>Packages Added:</strong> ${numberOfPackages}</li>
                  ${addNorthPoleSnow ? '<li><strong>North Pole Snow:</strong> Included ‚ùÑÔ∏è</li>' : ''}
                  <li><strong>Additional Amount:</strong> ${totalAmount.toFixed(2)}</li>
                  <li><strong>New Total:</strong> ${newTotal.toFixed(2)}</li>
                  <li><strong>Total Packages:</strong> ${updatedPackages.length}</li>
                </ul>
                <div style="background-color: #fef3c7; padding: 15px; border-radius: 5px; margin: 20px 0;">
                  <strong>‚ö†Ô∏è Important:</strong> Our team will review and confirm these changes before shipping your order.
                </div>
                <p>Thank you for adding more Christmas magic! üéÑ</p>
              `,
            }),
          });
          
          if (emailResponse.ok) {
            const emailData = await emailResponse.json();
            console.log("‚úÖ Sent packages added confirmation email. Email ID:", emailData.id);
            
            // Log email activity
            await logEmailActivity(
              order.orderId,
              'packages_added',
              order.customerInfo.email,
              'Packages Added Confirmation',
              emailData.id
            );
          }
        }
      } catch (emailError) {
        console.error("Error sending email:", emailError);
      }

      return c.json({ 
        success: true, 
        orderUpdated: true,
        orderId: order.orderId,
        message: "Order updated successfully" 
      });
    }
  } catch (error: any) {
    console.error("Error adding child:", error);
    return c.json({ error: error.message || "Failed to add child" }, 500);
  }
});

// Archive order
app.post("/make-server-cf244566/orders/:orderId/archive", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const order: any = await kv.get(`order:${orderId}`);
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    order.archived = true;
    order.updatedAt = new Date().toISOString();
    
    // Add to activity log
    if (!order.activityLog) order.activityLog = [];
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: "Order Archived",
      details: "Order moved to archived section",
      user: "Admin"
    });

    await kv.set(`order:${orderId}`, order);
    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error archiving order:", error);
    return c.json({ error: "Failed to archive order" }, 500);
  }
});

// Unarchive order
app.post("/make-server-cf244566/orders/:orderId/unarchive", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const order: any = await kv.get(`order:${orderId}`);
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    order.archived = false;
    order.updatedAt = new Date().toISOString();
    
    // Add to activity log
    if (!order.activityLog) order.activityLog = [];
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: "Order Restored",
      details: "Order restored from archived section",
      user: "Admin"
    });

    await kv.set(`order:${orderId}`, order);
    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error unarchiving order:", error);
    return c.json({ error: "Failed to unarchive order" }, 500);
  }
});

// Resend email notification
app.post("/make-server-cf244566/order/:orderId/resend-email", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const { emailType } = await c.req.json();
    
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    const resendApiKey = Deno.env.get("RESEND_API_KEY");
    if (!resendApiKey) {
      return c.json({ error: "Email service not configured" }, 503);
    }

    const customerEmail = order.customerInfo?.email;
    const customerName = order.customerInfo?.name || "Valued Customer";

    if (!customerEmail) {
      return c.json({ error: "No customer email found" }, 400);
    }

    let emailHtml = "";
    let subject = "";

    // Generate email based on type
    switch (emailType) {
      case "order_confirmation":
        subject = "üéÖ Order Confirmation - Santa's Letters";
        const packageDetails = order.letterPackages?.map((pkg: any, idx: number) => `
          <div style="background: #fef2f2; border: 2px solid #fecaca; border-radius: 8px; padding: 15px; margin: 15px 0;">
            <p><strong>üì¶ Package ${idx + 1}</strong></p>
            <p><strong>Child:</strong> ${pkg.childFirstName} ${pkg.childLastName}</p>
            <p><strong>Friend:</strong> ${pkg.friendName || 'N/A'}</p>
            <p><strong>Shipping to:</strong> ${pkg.streetAddress}${pkg.unitApt ? ', ' + pkg.unitApt : ''}, ${pkg.city}, ${pkg.state} ${pkg.zipCode}</p>
          </div>
        `).join('') || '';

        emailHtml = `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
          </head>
          <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÖ Thank You!</h1>
              </div>
              <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                <p>Hi ${customerName},</p>
                <p style="font-size: 18px; color: #059669;"><strong>‚úÖ Your order has been received!</strong></p>
                <div style="background: #dbeafe; padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #3b82f6;">
                  <p style="margin: 0;"><strong>Order #:</strong> ${orderId.slice(-8)}</p>
                  <p style="margin: 5px 0 0 0;"><strong>Total:</strong> ${order.total?.toFixed(2)}</p>
                </div>
                <h3>Your Letter Packages:</h3>
                ${packageDetails}
                <p style="margin-top: 30px;">The North Pole elves are preparing your magical letters! üéÑ</p>
                <p>Questions? Reply to this email anytime.</p>
              </div>
            </div>
          </body>
          </html>
        `;
        break;

      case "tracking_notification":
        subject = "üì¶ Your Order Has Shipped - Tracking Information";
        const trackingUrl = order.trackingNumber?.startsWith('1Z') 
          ? `https://www.ups.com/track?tracknum=${order.trackingNumber}`
          : `https://tools.usps.com/go/TrackConfirmAction?tLabels=${order.trackingNumber}`;

        emailHtml = `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
          </head>
          <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center;">
                <h1 style="font-family: 'Pacifico', cursive;">üì¶ Your Order Has Shipped!</h1>
              </div>
              <div style="background: white; padding: 30px;">
                <p>Hi ${customerName},</p>
                <p>Great news! Your magical letters from Santa are on their way! üéÖ‚ú®</p>
                <div style="background: #dbeafe; padding: 20px; border-radius: 8px; margin: 20px 0;">
                  <p><strong>Tracking Number:</strong> ${order.trackingNumber}</p>
                  <p><strong>Carrier:</strong> ${order.carrier || 'USPS'}</p>
                </div>
                <div style="text-align: center; margin: 30px 0;">
                  <a href="${trackingUrl}" style="background: #dc2626; color: white; padding: 15px 30px; text-decoration: none; border-radius: 5px; display: inline-block;">
                    Track Your Package
                  </a>
                </div>
              </div>
            </div>
          </body>
          </html>
        `;
        break;

      case "order_update":
        subject = "üìù Order Updated - Changes Confirmed";
        emailHtml = `
          <!DOCTYPE html>
          <html>
          <body style="font-family: Arial, sans-serif;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <h1>Order Updated</h1>
              <p>Hi ${customerName},</p>
              <p>Your order has been successfully updated!</p>
              <p><strong>Order #:</strong> ${orderId.slice(-8)}</p>
              <p>Thank you for your updates. Our elves are working on it! üéÖ</p>
            </div>
          </body>
          </html>
        `;
        break;

      case "subscription_payment":
        subject = "üéÖ Monthly Subscription Payment Confirmed";
        emailHtml = `
          <!DOCTYPE html>
          <html>
          <body style="font-family: Arial, sans-serif;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <h2 style="color: #dc2626;">üéÑ Ho Ho Ho!</h2>
              <p>Dear ${customerName},</p>
              <p>Your monthly Santa letter subscription payment has been processed successfully.</p>
              <p>Your magical letter will be prepared and shipped soon!</p>
              <p style="color: #059669;">Thank you for continuing this magical journey with us! üéÖ‚ú®</p>
            </div>
          </body>
          </html>
        `;
        break;

      case "payment_failed":
        subject = "‚ö†Ô∏è Santa Letter Subscription - Payment Issue";
        emailHtml = `
          <!DOCTYPE html>
          <html>
          <body style="font-family: Arial, sans-serif;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <h2 style="color: #dc2626;">Payment Issue with Your Subscription</h2>
              <p>Dear ${customerName},</p>
              <p>We encountered an issue processing your monthly Santa letter subscription payment.</p>
              <p>Please update your payment method to continue receiving your magical letters.</p>
              <p>If you have any questions, please contact us.</p>
              <p style="color: #6b7280;">üéÑ Santa's Workshop</p>
            </div>
          </body>
          </html>
        `;
        break;

      case "order_canceled":
        subject = `Order Canceled - #${orderId.slice(-8)}`;
        emailHtml = `
          <!DOCTYPE html>
          <html>
          <body style="font-family: Arial, sans-serif;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <h1>Order Canceled</h1>
              <p>Dear ${customerName},</p>
              <p>Your order <strong>#${orderId.slice(-8)}</strong> has been canceled.</p>
              <p>If you have questions, please contact support@letterfromsanta.com</p>
            </div>
          </body>
          </html>
        `;
        break;

      case "customer_edit":
        subject = `‚úèÔ∏è Order Updated - #${orderId.slice(-8)}`;
        emailHtml = `
          <!DOCTYPE html>
          <html>
          <body style="font-family: Arial, sans-serif;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <h1>‚úèÔ∏è Order Updated</h1>
              <p>Dear ${customerName},</p>
              <p>Your order <strong>#${orderId.slice(-8)}</strong> has been updated.</p>
              <div style="background-color: #fef3c7; padding: 15px; border-radius: 5px; margin: 20px 0;">
                <strong>‚ö†Ô∏è Important:</strong> Our team will review and confirm these changes before shipping your order.
              </div>
              <p>Questions? Contact support@letterfromsanta.com</p>
            </div>
          </body>
          </html>
        `;
        break;

      case "new_order_confirmation":
      case "packages_added":
        subject = "üéÖ Order Confirmed - Additional Packages";
        emailHtml = `
          <!DOCTYPE html>
          <html>
          <body style="font-family: Arial, sans-serif;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <h2>üéÖ Order Updated Successfully!</h2>
              <p>Dear ${customerName},</p>
              <p>We've added letter package(s) to your order!</p>
              <p><strong>Order #:</strong> ${orderId.slice(-8)}</p>
              <div style="background-color: #fef3c7; padding: 15px; border-radius: 5px; margin: 20px 0;">
                <strong>‚ö†Ô∏è Important:</strong> Our team will review and confirm these changes before shipping your order.
              </div>
              <p>Thank you for adding more Christmas magic! üéÑ</p>
            </div>
          </body>
          </html>
        `;
        break;

      default:
        return c.json({ error: "Invalid email type" }, 400);
    }

    // Send email via Resend
    const emailResponse = await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${resendApiKey}`,
      },
      body: JSON.stringify({
        from: EMAIL_FROM,
        to: [customerEmail],
        subject: subject,
        html: emailHtml,
      }),
    });

    if (!emailResponse.ok) {
      const errorData = await emailResponse.json();
      throw new Error(errorData.message || "Failed to send email");
    }

    const emailResult = await emailResponse.json();

    // Log the resent email to activity log
    await logEmailActivity(orderId, emailType, customerEmail, subject, emailResult.id);

    return c.json({ 
      success: true, 
      recipient: customerEmail,
      emailId: emailResult.id,
      subject: subject
    });
  } catch (error: any) {
    console.error("Error resending email:", error);
    return c.json({ error: error.message || "Failed to resend email" }, 500);
  }
});

// Delete order (admin only)
app.delete("/make-server-cf244566/orders/:orderId", async (c) => {
  try {
    const orderId = c.req.param("orderId");

    // Remove from orders index
    const allOrderIds: any = (await kv.get("orders:all")) || [];
    const updatedOrderIds = allOrderIds.filter((id: string) => id !== orderId);
    await kv.set("orders:all", updatedOrderIds);

    // Delete order
    await kv.del(`order:${orderId}`);

    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error deleting order:", error);
    return c.json({ error: "Failed to delete order" }, 500);
  }
});

// Bulk import tracking numbers
app.post("/make-server-cf244566/orders/bulk-tracking", async (c) => {
  try {
    const body = await c.req.json();
    const { updates } = body; // Array of {orderId, trackingNumber}

    for (const update of updates) {
      const allOrderIds = (await kv.get("orders:all")) || [];
      const matchingOrderId = allOrderIds.find((id: string) => id.includes(update.orderId));
      
      if (matchingOrderId) {
        const order: any = await kv.get(`order:${matchingOrderId}`);
        if (order) {
          order.trackingNumber = update.trackingNumber;
          order.status = "fulfilled";
          order.updatedAt = new Date().toISOString();
          await kv.set(`order:${matchingOrderId}`, order);
        }
      }
    }

    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error bulk importing tracking:", error);
    return c.json({ error: "Failed to bulk import tracking" }, 500);
  }
});

// ========== DECLINED ORDERS ENDPOINTS ==========

// Get all declined orders (admin only)
app.get("/make-server-cf244566/declines", async (c) => {
  try {
    // Get all decline values from the key-value store (getByPrefix returns values directly)
    const declines = (await kv.getByPrefix("decline:")) || [];

    // Sort by timestamp (newest first)
    declines.sort((a: any, b: any) => {
      const dateA = new Date(a.timestamp || 0).getTime();
      const dateB = new Date(b.timestamp || 0).getTime();
      return dateB - dateA;
    });

    console.log(`üìä Fetched ${declines.length} declined orders`);
    return c.json({ declines });
  } catch (error: any) {
    console.error("Error fetching declined orders:", error);
    return c.json({ error: "Failed to fetch declined orders", details: error.message }, 500);
  }
});

// Get single declined order by ID
app.get("/make-server-cf244566/declines/:declineId", async (c) => {
  try {
    const declineId = c.req.param("declineId");
    const decline = await kv.get(`decline:${declineId}`);

    if (!decline) {
      return c.json({ error: "Declined order not found" }, 404);
    }

    return c.json({ decline });
  } catch (error: any) {
    console.error("Error fetching declined order:", error);
    return c.json({ error: "Failed to fetch declined order" }, 500);
  }
});

// ========== AFFILIATE MANAGEMENT ENDPOINTS ==========

// Helper function to fix tracking URLs (replace any domain with production domain)
function fixTrackingUrl(url: string): string {
  if (!url) return url;
  
  // Parse the URL
  const urlParts = url.split('?');
  if (urlParts.length === 0) return url;
  
  // Replace any domain with santascertifiedletter.com/offer (funnel page)
  const params = urlParts.length > 1 ? '?' + urlParts[1] : '';
  return `https://santascertifiedletter.com/offer${params}`;
}

// Get next affiliate ID
async function getNextAffiliateId(): Promise<string> {
  const counter = (await kv.get("affiliate:id_counter")) || 9003;
  const nextId = counter + 1;
  await kv.set("affiliate:id_counter", nextId);
  return nextId.toString();
}

// Create new affiliate account
app.post("/make-server-cf244566/admin/affiliates", async (c) => {
  try {
    const body = await c.req.json();
    const { name, email, payoutType, payoutAmount } = body;

    const affiliateId = await getNextAffiliateId();

    const affiliate = {
      affiliateId,
      affiliateName: name,
      email,
      status: "active",
      defaultPayoutType: payoutType,
      defaultPayoutAmount: payoutAmount,
      password: Math.random().toString(36).substring(2, 10), // Simple random password
      createdAt: new Date().toISOString(),
    };

    // Save affiliate
    await kv.set(`affiliate:${affiliateId}`, affiliate);

    // Add to affiliates index
    const allAffiliateIds = (await kv.get("affiliates:all")) || [];
    allAffiliateIds.push(affiliateId);
    await kv.set("affiliates:all", allAffiliateIds);

    // Create default tracking link
    const defaultLink = {
      linkId: `link_${affiliateId}_default`,
      affiliateId,
      linkName: "Default Link",
      payoutType,
      payoutAmount,
      isDefault: true,
      trackingUrl: `https://santascertifiedletter.com/offer?ref=${affiliateId}`,
      createdAt: new Date().toISOString(),
    };

    await kv.set(`link:${defaultLink.linkId}`, defaultLink);

    // Add to links index
    const allLinkIds = (await kv.get("links:all")) || [];
    allLinkIds.push(defaultLink.linkId);
    await kv.set("links:all", allLinkIds);

    return c.json({ affiliate, defaultLink });
  } catch (error: any) {
    console.error("Error creating affiliate:", error);
    return c.json({ error: "Failed to create affiliate" }, 500);
  }
});

// Get all affiliates
app.get("/make-server-cf244566/admin/affiliates", async (c) => {
  try {
    const allAffiliateIds = (await kv.get("affiliates:all")) || [];
    
    const affiliates = [];
    for (const affiliateId of allAffiliateIds) {
      const affiliate = await kv.get(`affiliate:${affiliateId}`);
      if (affiliate) {
        affiliates.push(affiliate);
      }
    }

    // Get all links and fix tracking URLs automatically
    const allLinkIds = (await kv.get("links:all")) || [];
    const links = [];
    for (const linkId of allLinkIds) {
      const link: any = await kv.get(`link:${linkId}`);
      if (link) {
        // Fix tracking URL to use production domain
        const fixedUrl = fixTrackingUrl(link.trackingUrl);
        
        // If URL was changed, update it in the database
        if (fixedUrl !== link.trackingUrl) {
          link.trackingUrl = fixedUrl;
          await kv.set(`link:${linkId}`, link);
          console.log(`‚úÖ Fixed tracking URL for link ${linkId}: ${fixedUrl}`);
        }
        
        links.push(link);
      }
    }

    return c.json({ affiliates, links });
  } catch (error: any) {
    console.error("Error fetching affiliates:", error);
    return c.json({ error: "Failed to fetch affiliates" }, 500);
  }
});

// Update affiliate account
app.patch("/make-server-cf244566/admin/affiliates/:affiliateId", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    const body = await c.req.json();

    const affiliate: any = await kv.get(`affiliate:${affiliateId}`);

    if (!affiliate) {
      return c.json({ error: "Affiliate not found" }, 404);
    }

    // Update fields
    if (body.status) affiliate.status = body.status;
    if (body.defaultPayoutType) affiliate.defaultPayoutType = body.defaultPayoutType;
    if (body.defaultPayoutAmount !== undefined) affiliate.defaultPayoutAmount = body.defaultPayoutAmount;

    await kv.set(`affiliate:${affiliateId}`, affiliate);

    return c.json({ affiliate });
  } catch (error: any) {
    console.error("Error updating affiliate:", error);
    return c.json({ error: "Failed to update affiliate" }, 500);
  }
});

// Create affiliate link
app.post("/make-server-cf244566/admin/affiliates/:affiliateId/links", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    const body = await c.req.json();
    const { linkName, payoutType, payoutAmount, customPrice } = body;

    const linkId = `link_${affiliateId}_${Date.now()}`;
    const campaignParam = linkName.toLowerCase().replace(/\s+/g, "-");

    let trackingUrl = `https://santascertifiedletter.com/offer?ref=${affiliateId}`;
    if (!linkName.toLowerCase().includes("default")) {
      trackingUrl += `&campaign=${campaignParam}`;
    }
    // Note: Custom price is stored in the link settings, not in the URL

    const link = {
      linkId,
      affiliateId,
      linkName,
      payoutType,
      payoutAmount,
      customPrice,
      isDefault: false,
      trackingUrl,
      createdAt: new Date().toISOString(),
    };

    await kv.set(`link:${linkId}`, link);

    // Add to links index
    const allLinkIds = (await kv.get("links:all")) || [];
    allLinkIds.push(linkId);
    await kv.set("links:all", allLinkIds);

    return c.json({ link });
  } catch (error: any) {
    console.error("Error creating link:", error);
    return c.json({ error: "Failed to create link" }, 500);
  }
});

// Update affiliate link (payout and price adjustments)
app.patch("/make-server-cf244566/admin/affiliates/links/:linkId", async (c) => {
  try {
    const linkId = c.req.param("linkId");
    const body = await c.req.json();

    const link: any = await kv.get(`link:${linkId}`);

    if (!link) {
      return c.json({ error: "Link not found" }, 404);
    }

    // Update fields
    if (body.payoutType) link.payoutType = body.payoutType;
    if (body.payoutAmount !== undefined) link.payoutAmount = body.payoutAmount;
    if (body.customPrice !== undefined) {
      link.customPrice = body.customPrice;
      
      // Update tracking URL with new price
      const baseUrl = link.trackingUrl.split('?')[0];
      const params = new URLSearchParams(link.trackingUrl.split('?')[1]);
      
      if (body.customPrice) {
        params.set('price', body.customPrice.toString());
      } else {
        params.delete('price');
      }
      
      link.trackingUrl = `${baseUrl}?${params.toString()}`;
    }

    await kv.set(`link:${linkId}`, link);

    return c.json({ link });
  } catch (error: any) {
    console.error("Error updating link:", error);
    return c.json({ error: "Failed to update link" }, 500);
  }
});

// Delete affiliate link
app.delete("/make-server-cf244566/admin/affiliates/links/:linkId", async (c) => {
  try {
    const linkId = c.req.param("linkId");

    // Remove from links index
    const allLinkIds: any = (await kv.get("links:all")) || [];
    const updatedLinkIds = allLinkIds.filter((id: string) => id !== linkId);
    await kv.set("links:all", updatedLinkIds);

    // Delete link
    await kv.del(`link:${linkId}`);

    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error deleting link:", error);
    return c.json({ error: "Failed to delete link" }, 500);
  }
});

// Get custom price for affiliate link (used by checkout page)
app.get("/make-server-cf244566/affiliate/link-price", async (c) => {
  try {
    const ref = c.req.query("ref"); // affiliate ID
    const campaign = c.req.query("campaign"); // optional campaign parameter
    
    if (!ref) {
      return c.json({ customPrice: null });
    }
    
    // Get all links for this affiliate
    const allLinkIds = (await kv.get("links:all")) || [];
    
    // Find the matching link
    for (const linkId of allLinkIds) {
      const link: any = await kv.get(`link:${linkId}`);
      
      if (link && link.affiliateId === ref) {
        // If campaign is specified, match it
        if (campaign) {
          const linkCampaign = link.linkName.toLowerCase().replace(/\s+/g, "-");
          if (linkCampaign === campaign.toLowerCase()) {
            return c.json({ 
              customPrice: link.customPrice || null,
              payoutType: link.payoutType,
              payoutAmount: link.payoutAmount
            });
          }
        } else if (link.isDefault) {
          // Return default link if no campaign specified
          return c.json({ 
            customPrice: link.customPrice || null,
            payoutType: link.payoutType,
            payoutAmount: link.payoutAmount
          });
        }
      }
    }
    
    // No matching link found, return null
    return c.json({ customPrice: null });
  } catch (error: any) {
    console.error("Error getting link price:", error);
    return c.json({ customPrice: null });
  }
});

// Affiliate login
app.post("/make-server-cf244566/affiliate/login", async (c) => {
  try {
    const body = await c.req.json();
    const { affiliateId, password } = body;

    const affiliate: any = await kv.get(`affiliate:${affiliateId}`);

    if (!affiliate || affiliate.password !== password) {
      return c.json({ error: "Invalid credentials" }, 401);
    }

    return c.json({
      affiliateId: affiliate.affiliateId,
      affiliateName: affiliate.affiliateName,
      email: affiliate.email,
    });
  } catch (error: any) {
    console.error("Error during login:", error);
    return c.json({ error: "Login failed" }, 500);
  }
});

// Get affiliate links (for affiliate dashboard)
app.get("/make-server-cf244566/affiliate/:affiliateId/links", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    const allLinkIds = (await kv.get("links:all")) || [];
    
    const links = [];
    for (const linkId of allLinkIds) {
      const link: any = await kv.get(`link:${linkId}`);
      if (link && link.affiliateId === affiliateId) {
        links.push(link);
      }
    }

    return c.json({ links });
  } catch (error: any) {
    console.error("Error fetching affiliate links:", error);
    return c.json({ error: "Failed to fetch links" }, 500);
  }
});

// Track affiliate event (page view, form fill, etc.)
app.post("/make-server-cf244566/affiliate/track-event", async (c) => {
  try {
    const body = await c.req.json();
    const { affiliateId, eventType, subIds } = body;
    // eventType: "page_view", "form_fill", "add_package", "payment_submit", "sale"

    const eventId = `event_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    const event = {
      eventId,
      affiliateId,
      eventType,
      subIds: subIds || {},
      timestamp: new Date().toISOString(),
    };

    await kv.set(`event:${eventId}`, event);

    // Add to events index
    const allEventIds = (await kv.get("events:all")) || [];
    allEventIds.push(eventId);
    await kv.set("events:all", allEventIds);

    // Fire postbacks if configured
    const postbacks = (await kv.get(`postbacks:${affiliateId}`)) || [];
    for (const postback of postbacks) {
      if (postback.enabledEvents.includes(eventType)) {
        // Fire postback
        try {
          // Skip if postback URL is empty or invalid
          if (!postback.postbackUrl || postback.postbackUrl.trim() === '') {
            console.log(`Skipping postback for ${affiliateId} - empty URL`);
            continue;
          }

          let url = postback.postbackUrl
            .replace('{affiliate_id}', affiliateId)
            .replace('{event_type}', eventType)
            .replace('{timestamp}', event.timestamp);

          // Add sub IDs to URL
          Object.entries(subIds || {}).forEach(([key, value]) => {
            url = url.replace(`{${key}}`, value as string);
          });

          const response = await fetch(url);
          
          // Log postback result
          const postbackLog = {
            postbackId: `pb_${Date.now()}`,
            affiliateId,
            eventId,
            eventType,
            url,
            status: response.ok ? "success" : "failed",
            statusCode: response.status,
            timestamp: new Date().toISOString(),
          };

          await kv.set(`postback_log:${postbackLog.postbackId}`, postbackLog);

          // Add to postback logs index
          const allPostbackLogs = (await kv.get("postback_logs:all")) || [];
          allPostbackLogs.push(postbackLog.postbackId);
          await kv.set("postback_logs:all", allPostbackLogs);
        } catch (err) {
          console.error("Error firing postback:", err);
          
          // Log failed postback
          const postbackLog = {
            postbackId: `pb_${Date.now()}`,
            affiliateId,
            eventId,
            eventType,
            url: postback.postbackUrl,
            status: "failed",
            error: err.message,
            timestamp: new Date().toISOString(),
          };

          await kv.set(`postback_log:${postbackLog.postbackId}`, postbackLog);

          const allPostbackLogs = (await kv.get("postback_logs:all")) || [];
          allPostbackLogs.push(postbackLog.postbackId);
          await kv.set("postback_logs:all", allPostbackLogs);
        }
      }
    }

    return c.json({ success: true, eventId });
  } catch (error: any) {
    console.error("Error tracking event:", error);
    return c.json({ error: "Failed to track event" }, 500);
  }
});

// Save postback settings for affiliate
app.post("/make-server-cf244566/admin/affiliates/:affiliateId/postbacks", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    const body = await c.req.json();
    const { postbackUrl, pixelCode, enabledEvents } = body;

    const postback = {
      postbackUrl,
      pixelCode,
      enabledEvents,
      updatedAt: new Date().toISOString(),
    };

    await kv.set(`postbacks:${affiliateId}`, [postback]);

    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error saving postbacks:", error);
    return c.json({ error: "Failed to save postbacks" }, 500);
  }
});

// Get postback settings for affiliate
app.get("/make-server-cf244566/admin/affiliates/:affiliateId/postbacks", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    const postbacks = (await kv.get(`postbacks:${affiliateId}`)) || [];

    return c.json({ postbacks: postbacks[0] || { postbackUrl: "", pixelCode: "", enabledEvents: [] } });
  } catch (error: any) {
    console.error("Error fetching postbacks:", error);
    return c.json({ error: "Failed to fetch postbacks" }, 500);
  }
});

// Get postback logs for affiliate
app.get("/make-server-cf244566/affiliate/:affiliateId/postback-logs", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    const allPostbackLogs = (await kv.get("postback_logs:all")) || [];
    
    const logs = [];
    for (const logId of allPostbackLogs) {
      const log: any = await kv.get(`postback_log:${logId}`);
      if (log && log.affiliateId === affiliateId) {
        logs.push(log);
      }
    }

    // Sort by timestamp (newest first)
    logs.sort((a: any, b: any) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());

    return c.json({ logs });
  } catch (error: any) {
    console.error("Error fetching postback logs:", error);
    return c.json({ error: "Failed to fetch postback logs" }, 500);
  }
});

// Get affiliate stats (orders, revenue, events)
app.get("/make-server-cf244566/affiliate/:affiliateId/stats", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    
    // Get all orders
    const allOrderIds = (await kv.get("orders:all")) || [];
    const affiliateOrders = [];
    
    for (const orderId of allOrderIds) {
      const order: any = await kv.get(`order:${orderId}`);
      if (order && order.affiliateId === affiliateId) {
        affiliateOrders.push(order);
      }
    }

    // Get all events
    const allEventIds = (await kv.get("events:all")) || [];
    const affiliateEvents = [];
    
    for (const eventId of allEventIds) {
      const event: any = await kv.get(`event:${eventId}`);
      if (event && event.affiliateId === affiliateId) {
        affiliateEvents.push(event);
      }
    }

    // Calculate stats
    const pageViews = affiliateEvents.filter((e: any) => e.eventType === "page_view").length;
    const formFills = affiliateEvents.filter((e: any) => e.eventType === "form_fill").length;
    const addPackageClicks = affiliateEvents.filter((e: any) => e.eventType === "add_package").length;
    const paymentSubmits = affiliateEvents.filter((e: any) => e.eventType === "payment_submit").length;
    
    const totalOrders = affiliateOrders.length;
    const totalRevenue = affiliateOrders.reduce((sum: number, order: any) => sum + order.total, 0);
    const totalCommission = affiliateOrders.reduce((sum: number, order: any) => sum + (order.affiliateCommission || 0), 0);

    return c.json({
      pageViews,
      formFills,
      addPackageClicks,
      paymentSubmits,
      sales: totalOrders,
      totalRevenue,
      totalCommission,
      orders: affiliateOrders,
    });
  } catch (error: any) {
    console.error("Error fetching affiliate stats:", error);
    return c.json({ error: "Failed to fetch stats" }, 500);
  }
});

// Export orders as CSV
app.get("/make-server-cf244566/orders/export/csv", async (c) => {
  try {
    const allOrderIds = (await kv.get("orders:all")) || [];
    
    // Fetch all orders
    const orders = [];
    for (const orderId of allOrderIds) {
      const order = await kv.get(`order:${orderId}`);
      if (order) {
        orders.push(order);
      }
    }

    // Sort by date (newest first)
    orders.sort((a: any, b: any) => new Date(b.orderDate).getTime() - new Date(a.orderDate).getTime());

    // Create CSV
    let csv = "Order ID,Order Date,Status,Customer Name,Customer Email,Customer Phone,Address,City,State,ZIP,Number of Packages,Letter Recipients,Shipping Date,Subscription,Total\n";

    for (const order of orders) {
      const recipients = order.letterPackages.map((pkg: any) => 
        `${pkg.childFirstName} ${pkg.childLastName}`
      ).join("; ");

      const address = `${order.customerInfo.address.line1} ${order.customerInfo.address.line2 || ""}`.trim();

      csv += `"${order.orderId}","${new Date(order.orderDate).toLocaleDateString()}","${order.status}","${order.customerInfo.name}","${order.customerInfo.email}","${order.customerInfo.phone}","${address}","${order.customerInfo.address.city}","${order.customerInfo.address.state}","${order.customerInfo.address.postal_code}","${order.numberOfPackages}","${recipients}","${order.shippingDate}","${order.monthlySubscription ? "Yes" : "No"}","${order.total.toFixed(2)}"\n`;
    }

    return new Response(csv, {
      headers: {
        "Content-Type": "text/csv",
        "Content-Disposition": "attachment; filename=santa-letters-orders.csv",
      },
    });
  } catch (error: any) {
    console.error("Error exporting orders:", error);
    return c.json({ error: "Failed to export orders" }, 500);
  }
});

// Add postback configuration for affiliate
app.post("/make-server-cf244566/affiliate/postback-configs", async (c) => {
  try {
    const body = await c.req.json();
    const { affiliateId, eventType, url } = body;

    if (!affiliateId || !eventType || !url) {
      return c.json({ error: "Missing required fields" }, 400);
    }

    const configId = `pbcfg_${Date.now()}`;
    const config = {
      id: configId,
      affiliateId,
      eventType,
      url,
      enabled: true,
      createdAt: new Date().toISOString(),
    };

    await kv.set(`postback_config:${configId}`, config);

    // Add to configs index
    const allConfigIds = (await kv.get("postback_configs:all")) || [];
    allConfigIds.push(configId);
    await kv.set("postback_configs:all", allConfigIds);

    return c.json({ config });
  } catch (error: any) {
    console.error("Error adding postback config:", error);
    return c.json({ error: "Failed to add postback config" }, 500);
  }
});

// Update postback configuration
app.patch("/make-server-cf244566/affiliate/postback-configs/:configId", async (c) => {
  try {
    const configId = c.req.param("configId");
    const body = await c.req.json();

    const config: any = await kv.get(`postback_config:${configId}`);
    if (!config) {
      return c.json({ error: "Config not found" }, 404);
    }

    // Update only the enabled field
    if (body.hasOwnProperty("enabled")) {
      config.enabled = body.enabled;
    }

    await kv.set(`postback_config:${configId}`, config);
    return c.json({ config });
  } catch (error: any) {
    console.error("Error updating postback config:", error);
    return c.json({ error: "Failed to update postback config" }, 500);
  }
});

// Delete postback configuration
app.delete("/make-server-cf244566/affiliate/postback-configs/:configId", async (c) => {
  try {
    const configId = c.req.param("configId");

    await kv.del(`postback_config:${configId}`);

    // Remove from configs index
    const allConfigIds = (await kv.get("postback_configs:all")) || [];
    const updatedConfigIds = allConfigIds.filter((id: string) => id !== configId);
    await kv.set("postback_configs:all", updatedConfigIds);

    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error deleting postback config:", error);
    return c.json({ error: "Failed to delete postback config" }, 500);
  }
});

// Get all postback configs for an affiliate
app.get("/make-server-cf244566/affiliate/postback-configs/:affiliateId", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    const allConfigIds = (await kv.get("postback_configs:all")) || [];
    
    const configs = [];
    for (const configId of allConfigIds) {
      const config: any = await kv.get(`postback_config:${configId}`);
      if (config && config.affiliateId === affiliateId) {
        configs.push(config);
      }
    }

    return c.json({ configs });
  } catch (error: any) {
    console.error("Error fetching postback configs:", error);
    return c.json({ error: "Failed to fetch postback configs" }, 500);
  }
});

// Get affiliate dashboard data
app.get("/make-server-cf244566/affiliate/dashboard", async (c) => {
  try {
    const range = c.req.query("range") || "7days";
    // For now, return empty data - in production, this would fetch real stats
    // This endpoint can be expanded later with real tracking data
    
    return c.json({
      affiliate: {
        affiliateId: "aff_unknown",
        affiliateName: "Affiliate",
        email: "affiliate@example.com",
        trackingUrl: "https://santascertifiedletter.com/?ref=aff_unknown",
        postbackUrl: "",
        pixelCode: "",
        commissionRate: 20,
        status: "active",
        createdAt: new Date().toISOString(),
      },
      stats: {
        totalClicks: 0,
        totalConversions: 0,
        totalRevenue: 0,
        conversionRate: 0,
        commission: 0,
      },
      dailyReports: [],
      hourlyReports: [],
      subIDReports: [],
      eventStats: [],
      invoices: [],
      openBalance: 0,
      prepaidCredit: 0,
      postbackConfigs: [],
    });
  } catch (error: any) {
    console.error("Error fetching dashboard data:", error);
    return c.json({ error: "Failed to fetch dashboard data" }, 500);
  }
});

// Create invoice for affiliate
app.post("/make-server-cf244566/affiliate/invoices", async (c) => {
  try {
    const body = await c.req.json();
    const { affiliateId, periodStart, periodEnd, totalCommission, status, dueDate } = body;

    if (!affiliateId || !periodStart || !periodEnd || totalCommission === undefined) {
      return c.json({ error: "Missing required fields" }, 400);
    }

    const invoiceId = `inv_${Date.now()}`;
    const invoiceNumber = `INV-${new Date().getFullYear()}-${String(Math.floor(Math.random() * 10000)).padStart(4, '0')}`;
    
    const invoice = {
      invoiceId,
      invoiceNumber,
      affiliateId,
      periodStart,
      periodEnd,
      totalCommission,
      amountPaid: 0,
      amountOwed: totalCommission,
      status: status || "pending",
      dueDate: dueDate || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),
      createdAt: new Date().toISOString(),
    };

    await kv.set(`invoice:${invoiceId}`, invoice);

    // Add to invoices index for this affiliate
    const affiliateInvoiceIds = (await kv.get(`affiliate_invoices:${affiliateId}`)) || [];
    affiliateInvoiceIds.push(invoiceId);
    await kv.set(`affiliate_invoices:${affiliateId}`, affiliateInvoiceIds);

    return c.json({ invoice });
  } catch (error: any) {
    console.error("Error creating invoice:", error);
    return c.json({ error: "Failed to create invoice" }, 500);
  }
});

// Update invoice payment status
app.patch("/make-server-cf244566/affiliate/invoices/:invoiceId", async (c) => {
  try {
    const invoiceId = c.req.param("invoiceId");
    const body = await c.req.json();

    const invoice: any = await kv.get(`invoice:${invoiceId}`);
    if (!invoice) {
      return c.json({ error: "Invoice not found" }, 404);
    }

    // Update payment fields
    if (body.amountPaid !== undefined) {
      const overpayment = Math.max(0, body.amountPaid - invoice.totalCommission);
      
      invoice.amountPaid = body.amountPaid;
      invoice.amountOwed = Math.max(0, invoice.totalCommission - body.amountPaid);
      
      // Update status based on payment
      if (invoice.amountOwed === 0) {
        invoice.status = "paid";
        invoice.paidDate = new Date().toISOString();
      } else if (invoice.amountPaid > 0) {
        invoice.status = "partial";
      }

      // Handle overpayment as prepaid credit
      if (overpayment > 0) {
        const affiliateId = invoice.affiliateId;
        const currentCredit = (await kv.get(`prepaid_credit:${affiliateId}`)) || 0;
        await kv.set(`prepaid_credit:${affiliateId}`, currentCredit + overpayment);
      }
    }

    await kv.set(`invoice:${invoiceId}`, invoice);
    return c.json({ invoice });
  } catch (error: any) {
    console.error("Error updating invoice:", error);
    return c.json({ error: "Failed to update invoice" }, 500);
  }
});

// Get invoices for affiliate
app.get("/make-server-cf244566/affiliate/invoices/:affiliateId", async (c) => {
  try {
    const affiliateId = c.req.param("affiliateId");
    const invoiceIds = (await kv.get(`affiliate_invoices:${affiliateId}`)) || [];
    
    const invoices = [];
    for (const invoiceId of invoiceIds) {
      const invoice: any = await kv.get(`invoice:${invoiceId}`);
      if (invoice) {
        invoices.push(invoice);
      }
    }

    const openBalance = invoices.reduce((sum, inv) => sum + inv.amountOwed, 0);
    const prepaidCredit = (await kv.get(`prepaid_credit:${affiliateId}`)) || 0;

    return c.json({ invoices, openBalance, prepaidCredit });
  } catch (error: any) {
    console.error("Error fetching invoices:", error);
    return c.json({ error: "Failed to fetch invoices" }, 500);
  }
});

// Delete invoice
app.delete("/make-server-cf244566/affiliate/invoices/:invoiceId", async (c) => {
  try {
    const invoiceId = c.req.param("invoiceId");
    
    const invoice: any = await kv.get(`invoice:${invoiceId}`);
    if (!invoice) {
      return c.json({ error: "Invoice not found" }, 404);
    }

    const affiliateId = invoice.affiliateId;

    // Remove from invoice index
    const affiliateInvoiceIds = (await kv.get(`affiliate_invoices:${affiliateId}`)) || [];
    const updatedInvoiceIds = affiliateInvoiceIds.filter((id: string) => id !== invoiceId);
    await kv.set(`affiliate_invoices:${affiliateId}`, updatedInvoiceIds);

    // Delete the invoice
    await kv.del(`invoice:${invoiceId}`);

    return c.json({ success: true });
  } catch (error: any) {
    console.error("Error deleting invoice:", error);
    return c.json({ error: "Failed to delete invoice" }, 500);
  }
});

// Send Email Notification
app.post("/make-server-cf244566/send-email", async (c) => {
  try {
    const body = await c.req.json();
    const { to, subject, html } = body;

    if (!to || !subject || !html) {
      return c.json({ error: "Missing required fields: to, subject, html" }, 400);
    }

    // Send email using Resend
    const { data, error } = await resend.emails.send({
      from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
      to: [to],
      subject: subject,
      html: html,
    });

    if (error) {
      console.error("Error sending email with Resend:", error);
      return c.json({ error: "Failed to send email", details: error }, 500);
    }

    console.log("Email sent successfully:", data);
    return c.json({ success: true, emailId: data?.id });
  } catch (error: any) {
    console.error("Error in send-email endpoint:", error);
    return c.json({ error: "Failed to send email", details: error.message }, 500);
  }
});

// Send SMS Notification
app.post("/make-server-cf244566/send-sms", async (c) => {
  try {
    const body = await c.req.json();
    const { to, message } = body;

    if (!to || !message) {
      return c.json({ error: "Missing required fields: to, message" }, 400);
    }

    // Twilio credentials
    const accountSid = Deno.env.get("TWILIO_ACCOUNT_SID");
    const authToken = Deno.env.get("TWILIO_AUTH_TOKEN");
    const fromNumber = Deno.env.get("TWILIO_PHONE_NUMBER");

    if (!accountSid || !authToken || !fromNumber) {
      console.error("Twilio credentials not configured");
      return c.json({ error: "SMS service not configured" }, 500);
    }

    // Send SMS using Twilio
    const twilioUrl = `https://api.twilio.com/2010-04-01/Accounts/${accountSid}/Messages.json`;
    const credentials = btoa(`${accountSid}:${authToken}`);

    const formData = new URLSearchParams();
    formData.append("To", to);
    formData.append("From", fromNumber);
    formData.append("Body", message);

    const response = await fetch(twilioUrl, {
      method: "POST",
      headers: {
        Authorization: `Basic ${credentials}`,
        "Content-Type": "application/x-www-form-urlencoded",
      },
      body: formData.toString(),
    });

    if (!response.ok) {
      const errorData = await response.json();
      console.error("Error sending SMS with Twilio:", errorData);
      return c.json({ error: "Failed to send SMS", details: errorData }, 500);
    }

    const data = await response.json();
    console.log("SMS sent successfully:", data);
    return c.json({ success: true, messageSid: data.sid });
  } catch (error: any) {
    console.error("Error in send-sms endpoint:", error);
    return c.json({ error: "Failed to send SMS", details: error.message }, 500);
  }
});

// Send Email Notification
app.post("/make-server-cf244566/send-email", async (c) => {
  try {
    const body = await c.req.json();
    const { to, subject, html } = body;

    if (!to || !subject || !html) {
      return c.json({ error: "Missing required fields: to, subject, html" }, 400);
    }

    const resendApiKey = Deno.env.get("RESEND_API_KEY");
    if (!resendApiKey) {
      console.error("RESEND_API_KEY not configured");
      return c.json({ error: "Email service not configured" }, 500);
    }

    // Send email using Resend API
    const response = await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${resendApiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
        to: [to],
        subject: subject,
        html: html,
      }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      console.error("Error sending email with Resend:", errorData);
      return c.json({ error: "Failed to send email", details: errorData }, 500);
    }

    const data = await response.json();
    console.log("Email sent successfully:", data);
    return c.json({ success: true, emailId: data.id });
  } catch (error: any) {
    console.error("Error in send-email endpoint:", error);
    return c.json({ error: "Failed to send email", details: error.message }, 500);
  }
});

// Send SMS Notification
app.post("/make-server-cf244566/send-sms", async (c) => {
  try {
    const body = await c.req.json();
    const { to, message } = body;

    if (!to || !message) {
      return c.json({ error: "Missing required fields: to, message" }, 400);
    }

    // Twilio credentials
    const accountSid = Deno.env.get("TWILIO_ACCOUNT_SID");
    const authToken = Deno.env.get("TWILIO_AUTH_TOKEN");
    const fromNumber = Deno.env.get("TWILIO_PHONE_NUMBER");

    if (!accountSid || !authToken || !fromNumber) {
      console.error("Twilio credentials not configured");
      return c.json({ error: "SMS service not configured" }, 500);
    }

    // Send SMS using Twilio
    const twilioUrl = `https://api.twilio.com/2010-04-01/Accounts/${accountSid}/Messages.json`;
    const credentials = btoa(`${accountSid}:${authToken}`);

    const formData = new URLSearchParams();
    formData.append("To", to);
    formData.append("From", fromNumber);
    formData.append("Body", message);

    const response = await fetch(twilioUrl, {
      method: "POST",
      headers: {
        Authorization: `Basic ${credentials}`,
        "Content-Type": "application/x-www-form-urlencoded",
      },
      body: formData.toString(),
    });

    if (!response.ok) {
      const errorData = await response.json();
      console.error("Error sending SMS with Twilio:", errorData);
      return c.json({ error: "Failed to send SMS", details: errorData }, 500);
    }

    const data = await response.json();
    console.log("SMS sent successfully:", data);
    return c.json({ success: true, messageSid: data.sid });
  } catch (error: any) {
    console.error("Error in send-sms endpoint:", error);
    return c.json({ error: "Failed to send SMS", details: error.message }, 500);
  }
});

// ========== ADMIN AFFILIATE REPORTING ENDPOINT ==========
app.get("/make-server-cf244566/admin/affiliate-reports", async (c) => {
  try {
    const dateRange = c.req.query("dateRange") || "7days";
    const affiliateId = c.req.query("affiliateId");

    // Helper function to convert UTC date to EST date string
    const toESTDateString = (date: Date): string => {
      return date.toLocaleString("en-US", {
        timeZone: "America/New_York",
        year: "numeric",
        month: "2-digit",
        day: "2-digit"
      }).split(',')[0].split('/').map((p: string) => p.padStart(2, '0')).reverse().join('-');
    };

    // Helper function to get EST hour (0-23)
    const getESTHour = (date: Date): number => {
      const estTime = date.toLocaleString("en-US", {
        timeZone: "America/New_York",
        hour: "2-digit",
        hour12: false
      });
      return parseInt(estTime.split(':')[0]);
    };

    // Get current time in EST
    const nowEST = new Date(new Date().toLocaleString("en-US", { timeZone: "America/New_York" }));
    let startDate: Date;
    
    switch (dateRange) {
      case "today":
        // Start of today in EST
        const todayEST = new Date(nowEST.getFullYear(), nowEST.getMonth(), nowEST.getDate());
        startDate = new Date(todayEST.toLocaleString("en-US", { timeZone: "UTC" }));
        break;
      case "yesterday":
        // Start of yesterday in EST
        const yesterdayEST = new Date(nowEST.getFullYear(), nowEST.getMonth(), nowEST.getDate() - 1);
        startDate = new Date(yesterdayEST.toLocaleString("en-US", { timeZone: "UTC" }));
        const endYesterday = new Date(nowEST.getFullYear(), nowEST.getMonth(), nowEST.getDate() - 1, 23, 59, 59, 999);
        nowEST.setTime(endYesterday.getTime());
        break;
      case "7days":
        startDate = new Date(nowEST.getTime() - 7 * 24 * 60 * 60 * 1000);
        break;
      case "30days":
        startDate = new Date(nowEST.getTime() - 30 * 24 * 60 * 60 * 1000);
        break;
      case "thismonth":
        // First day of current month in EST
        const thisMonthEST = new Date(nowEST.getFullYear(), nowEST.getMonth(), 1);
        startDate = new Date(thisMonthEST.toLocaleString("en-US", { timeZone: "UTC" }));
        break;
      case "lastmonth":
        // First day of last month in EST
        const lastMonthEST = new Date(nowEST.getFullYear(), nowEST.getMonth() - 1, 1);
        startDate = new Date(lastMonthEST.toLocaleString("en-US", { timeZone: "UTC" }));
        // Last day of last month
        const endLastMonth = new Date(nowEST.getFullYear(), nowEST.getMonth(), 0, 23, 59, 59, 999);
        nowEST.setTime(endLastMonth.getTime());
        break;
      default:
        startDate = new Date(nowEST.getTime() - 7 * 24 * 60 * 60 * 1000);
    }

    // Get all orders
    const allOrderIds = (await kv.get("orders:all")) || [];
    const orders = [];
    
    for (const orderId of allOrderIds) {
      const order: any = await kv.get(`order:${orderId}`);
      if (order) {
        const orderDate = new Date(order.orderDate);
        
        // Filter by date range
        if (orderDate >= startDate && orderDate <= nowEST) {
          // Filter by affiliate if specified
          if (!affiliateId || affiliateId === "all" || order.affiliateId === affiliateId) {
            orders.push(order);
          }
        }
      }
    }

    // Get chargebacks
    const allChargebacks = (await kv.get("chargebacks:all")) || [];
    const chargebacks = [];
    
    for (const chargebackId of allChargebacks) {
      const chargeback: any = await kv.get(`chargeback:${chargebackId}`);
      if (chargeback) {
        const cbDate = new Date(chargeback.chargebackDate);
        
        if (cbDate >= startDate && cbDate <= nowEST) {
          if (!affiliateId || affiliateId === "all" || chargeback.affiliateId === affiliateId) {
            chargebacks.push(chargeback);
          }
        }
      }
    }

    // Group data by date and hour (using EST)
    const dailyReportsMap: Record<string, any> = {};
    const hourlyReportsMap: Record<string, any> = {};
    
    // Get clicks from events
    const allEventIds = (await kv.get("events:all")) || [];
    
    for (const eventId of allEventIds) {
      const event: any = await kv.get(`event:${eventId}`);
      if (event) {
        const eventDate = new Date(event.timestamp);
        
        if (eventDate >= startDate && eventDate <= nowEST) {
          if (!affiliateId || affiliateId === "all" || event.affiliateId === affiliateId) {
            // Daily grouping (EST date string)
            const dateKey = toESTDateString(eventDate);
            
            if (!dailyReportsMap[dateKey]) {
              dailyReportsMap[dateKey] = {
                date: dateKey,
                clicks: 0,
                conversions: 0,
                revenue: 0,
                commission: 0,
                refunds: 0,
                chargebacks: 0,
                declines: 0,
              };
            }
            
            if (event.eventType === "page_view") {
              dailyReportsMap[dateKey].clicks++;
            }
            
            // Hourly grouping (EST - only for today)
            if (dateRange === "today") {
              const estHour = getESTHour(eventDate);
              const hourKey = `${estHour}:00`;
              
              if (!hourlyReportsMap[hourKey]) {
                hourlyReportsMap[hourKey] = {
                  hour: hourKey,
                  clicks: 0,
                  conversions: 0,
                  revenue: 0,
                  commission: 0,
                };
              }
              
              if (event.eventType === "page_view") {
                hourlyReportsMap[hourKey].clicks++;
              }
            }
          }
        }
      }
    }

    // Add order data to reports
    let totalRevenue = 0;
    let totalCommission = 0;
    let totalRefunds = 0;
    let totalChargebacks = 0;
    let totalDeclines = 0;

    const orderDetails = [];

    for (const order of orders) {
      const orderDate = new Date(order.orderDate);
      const dateKey = toESTDateString(orderDate);
      
      if (!dailyReportsMap[dateKey]) {
        dailyReportsMap[dateKey] = {
          date: dateKey,
          clicks: 0,
          conversions: 0,
          revenue: 0,
          commission: 0,
          refunds: 0,
          chargebacks: 0,
          declines: 0,
        };
      }

      const isRefunded = order.status === "refunded" || order.status === "canceled-refunded";
      const isChargeback = order.status === "chargeback";
      
      if (!isRefunded && !isChargeback) {
        dailyReportsMap[dateKey].conversions++;
        dailyReportsMap[dateKey].revenue += order.total || 0;
        dailyReportsMap[dateKey].commission += order.affiliateCommission || 0;
        
        totalRevenue += order.total || 0;
        totalCommission += order.affiliateCommission || 0;
      } else if (isRefunded) {
        dailyReportsMap[dateKey].refunds += order.total || 0;
        totalRefunds += order.total || 0;
      } else if (isChargeback) {
        dailyReportsMap[dateKey].chargebacks += order.total || 0;
        totalChargebacks += order.total || 0;
      }

      // Add to hourly if today
      if (dateRange === "today") {
        const estHour = getESTHour(orderDate);
        const hourKey = `${estHour}:00`;
        
        if (!hourlyReportsMap[hourKey]) {
          hourlyReportsMap[hourKey] = {
            hour: hourKey,
            clicks: 0,
            conversions: 0,
            revenue: 0,
            commission: 0,
          };
        }

        if (!isRefunded && !isChargeback) {
          hourlyReportsMap[hourKey].conversions++;
          hourlyReportsMap[hourKey].revenue += order.total || 0;
          hourlyReportsMap[hourKey].commission += order.affiliateCommission || 0;
        }
      }

      // Add to order details
      orderDetails.push({
        orderId: order.orderId,
        sessionId: order.orderId,
        affiliateId: order.affiliateId || "direct",
        affiliateName: order.affiliateName || "Direct Sale",
        customerEmail: order.customerInfo?.email || "",
        packageCount: order.numberOfPackages || 0,
        total: order.total || 0,
        commission: order.affiliateCommission || 0,
        status: isChargeback ? "chargeback" : isRefunded ? "refunded" : "completed",
        orderDate: order.orderDate,
        subIds: order.subIds || {},
      });
    }

    // Convert maps to arrays and sort
    const dailyReports = Object.values(dailyReportsMap).sort((a: any, b: any) => 
      new Date(b.date).getTime() - new Date(a.date).getTime()
    );
    
    const hourlyReports = Object.values(hourlyReportsMap).sort((a: any, b: any) => {
      const aHour = parseInt(a.hour.split(':')[0]);
      const bHour = parseInt(b.hour.split(':')[0]);
      return aHour - bHour;
    });

    // Calculate net revenue
    const netRevenue = totalRevenue - totalRefunds - totalChargebacks;

    return c.json({
      dailyReports,
      hourlyReports,
      orders: orderDetails,
      chargebacks: chargebacks.map((cb: any) => ({
        chargebackId: cb.chargebackId,
        orderId: cb.orderId,
        sessionId: cb.sessionId,
        affiliateId: cb.affiliateId,
        affiliateName: cb.affiliateName,
        amount: cb.amount,
        commission: cb.commission,
        reason: cb.reason,
        stripeChargeId: cb.stripeChargeId,
        chargebackDate: cb.chargebackDate,
        orderDate: cb.orderDate,
        status: cb.status,
      })),
      totalStats: {
        totalRevenue,
        totalCommission,
        totalRefunds,
        totalChargebacks,
        totalDeclines,
        netRevenue,
      },
    });
  } catch (error: any) {
    console.error("Error fetching affiliate reports:", error);
    return c.json({ error: "Failed to fetch reports" }, 500);
  }
});

// Update customer information
app.patch("/make-server-cf244566/orders/:orderId/customer-info", async (c) => {
  try {
    const orderId = c.req.param("orderId");
    const { customerInfo } = await c.req.json();

    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    // Update customer info
    order.customerInfo = customerInfo;
    order.updatedAt = new Date().toISOString();
    await kv.set(`order:${orderId}`, order);

    // Send notification email and SMS
    await sendCustomerInfoUpdateNotification(order);

    return c.json({ success: true, order });
  } catch (error: any) {
    console.error("Error updating customer info:", error);
    return c.json({ error: "Failed to update customer information" }, 500);
  }
});

// Cancel subscription
app.post("/make-server-cf244566/subscriptions/:subscriptionId/cancel", async (c) => {
  try {
    if (!stripe) {
      return c.json({ error: "Stripe not configured" }, 503);
    }

    const subscriptionId = c.req.param("subscriptionId");
    const { orderId } = await c.req.json();

    // Cancel in Stripe
    const subscription = await stripe.subscriptions.cancel(subscriptionId);

    // Update order status
    const order: any = await kv.get(`order:${orderId}`);
    if (order) {
      order.status = "canceled-refunded";
      order.updatedAt = new Date().toISOString();
      await kv.set(`order:${orderId}`, order);

      // Send cancellation notification
      await sendSubscriptionCanceledNotification(order);
    }

    return c.json({ success: true, subscription });
  } catch (error: any) {
    console.error("Error canceling subscription:", error);
    return c.json({ error: error.message || "Failed to cancel subscription" }, 500);
  }
});

// Process refund
app.post("/make-server-cf244566/orders/:orderId/refund", async (c) => {
  try {
    if (!stripe) {
      return c.json({ error: "Stripe not configured" }, 503);
    }

    const orderId = c.req.param("orderId");
    const { amount } = await c.req.json();

    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    // Check if order is already refunded
    if (order.status === "canceled-refunded" && order.refundAmount) {
      console.log(`‚ö†Ô∏è Order ${orderId} is already refunded: ${order.refundAmount}`);
      return c.json({ 
        error: "This order has already been refunded", 
        alreadyRefunded: true,
        refundAmount: order.refundAmount 
      }, 400);
    }

    // Process refund in Stripe
    let refund;
    try {
      refund = await stripe.refunds.create({
        payment_intent: order.stripePaymentId,
        amount: Math.round(amount * 100), // Convert to cents
      });
    } catch (stripeError: any) {
      // Handle already refunded error specifically
      if (stripeError.code === 'charge_already_refunded') {
        console.log(`‚ö†Ô∏è Stripe reports charge already refunded for order ${orderId}`);
        
        // Update our records to match Stripe's state
        order.status = "canceled-refunded";
        order.refundAmount = amount;
        order.updatedAt = new Date().toISOString();
        await kv.set(`order:${orderId}`, order);
        
        return c.json({ 
          error: "This charge has already been refunded in Stripe",
          alreadyRefunded: true,
          refundAmount: amount
        }, 400);
      }
      // Re-throw other Stripe errors
      throw stripeError;
    }

    // Add activity log entry
    if (!order.activityLog) order.activityLog = [];
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Refund Processed',
      details: `Refund of ${amount.toFixed(2)} issued via Stripe. Refund ID: ${refund.id}`,
      user: 'Admin',
      stripeUrl: `https://dashboard.stripe.com/payments/${order.stripePaymentId}`
    });
    
    // Update order status
    order.status = "canceled-refunded";
    order.refundAmount = amount;
    order.updatedAt = new Date().toISOString();
    await kv.set(`order:${orderId}`, order);

    // Send refund notification
    await sendRefundNotification(order, amount);

    console.log(`‚úÖ Refund processed successfully for order ${orderId}: ${amount}`);
    return c.json({ success: true, refund });
  } catch (error: any) {
    console.error("Error processing refund:", error);
    return c.json({ error: error.message || "Failed to process refund" }, 500);
  }
});

// Helper function to send customer info update notification
async function sendCustomerInfoUpdateNotification(order: any) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  const twilioAccountSid = Deno.env.get("TWILIO_ACCOUNT_SID");
  const twilioAuthToken = Deno.env.get("TWILIO_AUTH_TOKEN");
  const twilioPhoneNumber = Deno.env.get("TWILIO_PHONE_NUMBER");

  if (resendApiKey) {
    try {
      await fetch("https://api.resend.com/emails", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${resendApiKey}`,
        },
        body: JSON.stringify({
          from: "Santa's Workshop <noreply@updates.santascertifiedletter.com>",
          to: [order.customerInfo.email],
          subject: "Your Order Information Has Been Updated üìù",
          html: `<div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;"><h2 style="color: #dc2626;">üéÖ Order Information Updated</h2><p>Hello ${order.customerInfo.name},</p><p>Your order information has been updated.</p><div style="background-color: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0;"><p><strong>Order:</strong> #${order.orderId.slice(-8)}</p><p><strong>Updated:</strong> ${new Date().toLocaleDateString()}</p></div><p style="color: #dc2626;">üéÑ Keep the magic alive!</p></div>`,
        }),
      });
    } catch (error) {
      console.error("‚ùå Failed to send email:", error);
    }
  }

  if (twilioAccountSid && twilioAuthToken && twilioPhoneNumber && order.customerInfo.phone) {
    try {
      const auth = btoa(`${twilioAccountSid}:${twilioAuthToken}`);
      await fetch(`https://api.twilio.com/2010-04-01/Accounts/${twilioAccountSid}/Messages.json`, {
        method: "POST",
        headers: {
          "Authorization": `Basic ${auth}`,
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: new URLSearchParams({
          To: order.customerInfo.phone,
          From: twilioPhoneNumber,
          Body: `üéÖ Your Santa letter order info has been updated. Order #${order.orderId.slice(-8)}`,
        }),
      });
    } catch (error) {
      console.error("‚ùå Failed to send SMS:", error);
    }
  }
}

// Helper function to send subscription canceled notification
async function sendSubscriptionCanceledNotification(order: any) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  const twilioAccountSid = Deno.env.get("TWILIO_ACCOUNT_SID");
  const twilioAuthToken = Deno.env.get("TWILIO_AUTH_TOKEN");
  const twilioPhoneNumber = Deno.env.get("TWILIO_PHONE_NUMBER");

  if (resendApiKey) {
    try {
      await fetch("https://api.resend.com/emails", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${resendApiKey}`,
        },
        body: JSON.stringify({
          from: "Santa's Workshop <noreply@updates.santascertifiedletter.com>",
          to: [order.customerInfo.email],
          subject: "Your Subscription Has Been Canceled",
          html: `<div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;"><h2 style="color: #dc2626;">üéÖ Subscription Canceled</h2><p>Hello ${order.customerInfo.name},</p><p>Your Santa's Magical Adventures subscription has been canceled.</p><div style="background-color: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0;"><p><strong>Order:</strong> #${order.orderId.slice(-8)}</p><p><strong>Subscription ID:</strong> ${order.subscriptionId}</p></div><p>You will not be charged for any future months.</p><p style="color: #dc2626;">üéÑ We hope to see you again next year!</p></div>`,
        }),
      });
    } catch (error) {
      console.error("‚ùå Failed to send email:", error);
    }
  }

  if (twilioAccountSid && twilioAuthToken && twilioPhoneNumber && order.customerInfo.phone) {
    try {
      const auth = btoa(`${twilioAccountSid}:${twilioAuthToken}`);
      await fetch(`https://api.twilio.com/2010-04-01/Accounts/${twilioAccountSid}/Messages.json`, {
        method: "POST",
        headers: {
          "Authorization": `Basic ${auth}`,
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: new URLSearchParams({
          To: order.customerInfo.phone,
          From: twilioPhoneNumber,
          Body: `üéÖ Your Santa subscription has been canceled. No future charges will be made.`,
        }),
      });
    } catch (error) {
      console.error("‚ùå Failed to send SMS:", error);
    }
  }
}

// Helper function to send refund notification
async function sendRefundNotification(order: any, amount: number) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  const twilioAccountSid = Deno.env.get("TWILIO_ACCOUNT_SID");
  const twilioAuthToken = Deno.env.get("TWILIO_AUTH_TOKEN");
  const twilioPhoneNumber = Deno.env.get("TWILIO_PHONE_NUMBER");

  if (resendApiKey) {
    try {
      await fetch("https://api.resend.com/emails", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${resendApiKey}`,
        },
        body: JSON.stringify({
          from: "Santa's Workshop <noreply@updates.santascertifiedletter.com>",
          to: [order.customerInfo.email],
          subject: `Refund Processed: ${amount.toFixed(2)} üíµ`,
          html: `<div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;"><h2 style="color: #dc2626;">üíµ Refund Processed</h2><p>Hello ${order.customerInfo.name},</p><p>Your refund has been processed successfully.</p><div style="background-color: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; border: 2px solid #16a34a;"><p style="font-size: 24px; margin: 0; color: #16a34a;"><strong>${amount.toFixed(2)}</strong></p><p style="margin: 5px 0 0 0;">Refund Amount</p></div><div style="background-color: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0;"><p><strong>Order:</strong> #${order.orderId.slice(-8)}</p><p><strong>Refunded:</strong> ${new Date().toLocaleDateString()}</p></div><p>The refund will appear on your original payment method within 5-10 business days.</p><p style="color: #dc2626;">üéÑ Thank you!</p></div>`,
        }),
      });
    } catch (error) {
      console.error("‚ùå Failed to send refund email:", error);
    }
  }

  if (twilioAccountSid && twilioAuthToken && twilioPhoneNumber && order.customerInfo.phone) {
    try {
      const auth = btoa(`${twilioAccountSid}:${twilioAuthToken}`);
      await fetch(`https://api.twilio.com/2010-04-01/Accounts/${twilioAccountSid}/Messages.json`, {
        method: "POST",
        headers: {
          "Authorization": `Basic ${auth}`,
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: new URLSearchParams({
          To: order.customerInfo.phone,
          From: twilioPhoneNumber,
          Body: `üíµ Refund of ${amount.toFixed(2)} processed for order #${order.orderId.slice(-8)}. Funds will appear in 5-10 business days.`,
        }),
      });
    } catch (error) {
      console.error("‚ùå Failed to send SMS:", error);
    }
  }
}

// Update Next Billing Date (without charging)
app.post("/make-server-cf244566/admin/update-billing-date", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }

  try {
    const { orderId, nextBillingDate } = await c.req.json();
    
    console.log(`üìÖ Updating next billing date for order: ${orderId} to ${nextBillingDate}`);
    
    // Get order
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!order.subscriptionId) {
      return c.json({ error: "Order does not have a subscription" }, 400);
    }
    
    // Validate date
    if (!nextBillingDate) {
      return c.json({ error: "Next billing date is required" }, 400);
    }

    const nextBillingTimestamp = Math.floor(new Date(nextBillingDate).getTime() / 1000);
    const now = Math.floor(Date.now() / 1000);
    
    // Get subscription from Stripe
    const subscription = await stripe.subscriptions.retrieve(order.subscriptionId);
    
    if (subscription.status === "canceled") {
      return c.json({ error: "Subscription is already canceled" }, 400);
    }
    
    // If date is today or in the past, charge immediately
    if (nextBillingTimestamp <= now) {
      console.log(`üîî Billing date is today or past - charging immediately`);
      
      // Get subscription price from order (configurable per subscription)
      const subscriptionPrice = order.subscriptionPrice || 12.00;
      const subscriptionProductName = order.subscriptionProductName || "Santa's Magical Journey";
      
      // Create an invoice item for immediate billing
      await stripe.invoiceItems.create({
        customer: subscription.customer as string,
        amount: Math.round(subscriptionPrice * 100), // Convert to cents
        currency: 'usd',
        description: `${subscriptionProductName} - Monthly Letter`,
      });
      
      // Create and finalize the invoice
      const invoice = await stripe.invoices.create({
        customer: subscription.customer as string,
        auto_advance: true,
        description: `Immediate billing for subscription ${order.subscriptionId}`,
        metadata: {
          orderId: orderId,
          immediateCharge: 'true',
        },
      });
      
      // Finalize the invoice
      const finalizedInvoice = await stripe.invoices.finalizeInvoice(invoice.id);
      
      // Wait for payment to process
      await new Promise(resolve => setTimeout(resolve, 1500));
      
      // Retrieve the invoice to get final payment status
      const paidInvoice = await stripe.invoices.retrieve(finalizedInvoice.id);
      
      if (paidInvoice.status !== 'paid') {
        console.error(`‚ö†Ô∏è Invoice not paid. Status: ${paidInvoice.status}`);
        return c.json({ error: `Payment failed. Invoice status: ${paidInvoice.status}` }, 400);
      }
      
      console.log(`‚úÖ Immediate charge successful: ${(paidInvoice.amount_paid / 100).toFixed(2)}`);
      
      // Calculate next billing date based on billing interval
      const billingIntervalDays = order.billingIntervalDays || 30;
      const nextBilling = new Date();
      nextBilling.setDate(nextBilling.getDate() + billingIntervalDays);
      
      // Update subscription's next billing date
      const nextBillingTimestamp = Math.floor(nextBilling.getTime() / 1000);
      await stripe.subscriptions.update(order.subscriptionId, {
        trial_end: nextBillingTimestamp,
        proration_behavior: 'none',
      });
      
      // Update order in database
      order.subscriptionNextBillingDate = nextBilling.toISOString();
      order.successfulCharges = (order.successfulCharges || 0) + 1;
      order.subscriptionMonthsActive = order.successfulCharges;
      order.updatedAt = new Date().toISOString();
      
      // Add to activity log
      if (!order.activityLog) {
        order.activityLog = [];
      }
      order.activityLog.push({
        timestamp: new Date().toISOString(),
        action: 'Manual Charge - Immediate',
        details: `Charged ${(paidInvoice.amount_paid / 100).toFixed(2)}. Month ${order.successfulCharges}. Next billing: ${nextBilling.toLocaleDateString()}`,
        user: 'Admin',
        stripeUrl: `https://dashboard.stripe.com/invoices/${paidInvoice.id}`
      });
      
      await kv.set(`order:${orderId}`, order);
      
      // Create a new order for this month's fulfillment
      const allOrderIds = (await kv.get("orders:all")) || [];
      const newOrderId = `ord_${Date.now()}_${Math.random().toString(36).substring(7)}`;
      const newOrder = {
        orderId: newOrderId,
        parentOrderId: order.orderId,
        subscriptionId: order.subscriptionId,
        sessionId: paidInvoice.id,
        stripePaymentId: paidInvoice.payment_intent,
        stripeCheckoutUrl: `https://dashboard.stripe.com/invoices/${paidInvoice.id}`,
        orderDate: new Date().toISOString(),
        status: "pending",
        total: paidInvoice.amount_paid / 100,
        customerInfo: order.customerInfo,
        letterPackages: order.letterPackages,
        numberOfPackages: order.numberOfPackages,
        shippingDate: "",
        monthlySubscription: false,
        subscriptionRecurringOrder: true,
        subscriptionMonth: order.successfulCharges,
        subscriptionProductName: subscriptionProductName,
        affiliateId: order.affiliateId,
        affiliateName: order.affiliateName,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        activityLog: [{
          timestamp: new Date().toISOString(),
          action: 'Order Created',
          details: `Recurring subscription order - Month ${order.successfulCharges} (Manual Charge)`,
          user: 'Admin'
        }]
      };
      
      await kv.set(`order:${newOrderId}`, newOrder);
      allOrderIds.push(newOrderId);
      await kv.set("orders:all", allOrderIds);
      
      console.log(`‚úÖ Created new order ${newOrderId} for manual subscription charge`);
      
      // Send notification email
      if (order.customerInfo?.email) {
        try {
          const resendApiKey = Deno.env.get("RESEND_API_KEY");
          if (resendApiKey) {
            await fetch("https://api.resend.com/emails", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${resendApiKey}`,
              },
              body: JSON.stringify({
                from: "Santa's Workshop <noreply@updates.santascertifiedletter.com>",
                to: [order.customerInfo.email],
                subject: "üéÖ Your Monthly Santa Letter is On The Way!",
                html: `
                  <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                    <h2 style="color: #16a34a;">üéÖ Payment Received!</h2>
                    <p>Hello ${order.customerInfo.name},</p>
                    <p>Your monthly subscription payment has been processed successfully.</p>
                    <div style="background-color: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; border: 2px solid #16a34a;">
                      <p style="font-size: 24px; margin: 0; color: #16a34a;"><strong>$12.00</strong></p>
                      <p style="margin: 5px 0 0 0;">Monthly Subscription</p>
                    </div>
                    <p>Your monthly letter from Santa will be on its way soon!</p>
                    <p>Next billing date: <strong>${nextBilling.toLocaleDateString()}</strong></p>
                    <p style="color: #dc2626;">üéÑ Thank you for keeping the magic alive!</p>
                  </div>
                `,
              }),
            });
          }
        } catch (error) {
          console.error("‚ùå Failed to send notification email:", error);
        }
      }
      
      return c.json({ 
        success: true,
        invoiceId: paidInvoice.id,
        amountCharged: (paidInvoice.amount_paid / 100).toFixed(2),
        nextBillingDate: nextBilling.toISOString(),
        message: "Subscription charged successfully"
      });
    }

    // Date is in the future - just update the billing date without charging
    await stripe.subscriptions.update(order.subscriptionId, {
      trial_end: nextBillingTimestamp,
      proration_behavior: 'none',
    });

    console.log(`‚úÖ Updated Stripe subscription billing anchor to: ${nextBillingDate}`);

    // Update order in database
    order.subscriptionNextBillingDate = nextBillingDate;
    order.updatedAt = new Date().toISOString();
    
    // Add to activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Next Billing Date Updated',
      details: `Next billing date set to ${new Date(nextBillingDate).toLocaleDateString()}`,
      user: 'Admin'
    });

    await kv.set(`order:${orderId}`, order);
    
    console.log(`‚úÖ Updated order in database with new billing date: ${nextBillingDate}`);

    return c.json({ 
      success: true,
      nextBillingDate: nextBillingDate,
      amountCharged: "0.00",
      message: "Next billing date updated successfully (no charge)"
    });
  } catch (error: any) {
    console.error("Error updating billing date:", error);
    return c.json({ 
      error: error.message || "Failed to update billing date" 
    }, 500);
  }
});

// Manual Subscription Billing - Charge subscriber immediately
app.post("/make-server-cf244566/admin/charge-subscription", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }

  try {
    const { orderId, customBillingDate, skipRecentChargeCheck } = await c.req.json();
    
    console.log(`üîî Manual billing requested for order: ${orderId}`);
    
    // Get order
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!order.subscriptionId) {
      return c.json({ error: "Order does not have a subscription" }, 400);
    }
    
    // Check if charged in last 30 days (protection against double-charging)
    if (!skipRecentChargeCheck && order.lastChargeDate) {
      const daysSinceLastCharge = (Date.now() - new Date(order.lastChargeDate).getTime()) / (1000 * 60 * 60 * 24);
      if (daysSinceLastCharge < 30) {
        console.warn(`‚ö†Ô∏è Order was charged ${daysSinceLastCharge.toFixed(1)} days ago - within 30 days`);
        return c.json({ 
          error: "RECENT_CHARGE",
          recentCharge: true,
          lastChargeDate: order.lastChargeDate,
          daysSinceCharge: Math.floor(daysSinceLastCharge),
          message: `This subscription was charged ${Math.floor(daysSinceLastCharge)} days ago. Are you sure you want to charge again?`
        }, 400);
      }
    }
    
    // Get subscription from Stripe
    const subscription = await stripe.subscriptions.retrieve(order.subscriptionId);
    
    if (subscription.status === "canceled") {
      return c.json({ error: "Subscription is already canceled" }, 400);
    }
    
    // Get customer to verify default payment method
    const customer = await stripe.customers.retrieve(subscription.customer as string);
    
    // Ensure customer has a default payment method
    if (!subscription.default_payment_method && !customer.deleted && !customer.invoice_settings?.default_payment_method) {
      console.error(`‚ö†ÔøΩÔøΩ No default payment method found for customer ${subscription.customer}`);
      return c.json({ 
        error: "No payment method on file. Customer needs to update their payment information.",
        details: "Customer does not have a default payment method attached."
      }, 400);
    }
    
    // Get subscription price from order (configurable per subscription)
    const subscriptionPrice = order.subscriptionPrice || 12.00;
    const subscriptionProductName = order.subscriptionProductName || "Santa's Magical Journey";
    
    console.log(`üí≥ Charging subscription: ${subscriptionPrice.toFixed(2)}`);
    
    // Get the default payment method
    const defaultPaymentMethod = subscription.default_payment_method || 
                                  (!customer.deleted && customer.invoice_settings?.default_payment_method) || 
                                  null;
    
    if (!defaultPaymentMethod) {
      throw new Error("No default payment method found for customer");
    }
    
    console.log(`üí≥ Using payment method: ${defaultPaymentMethod}`);
    
    // APPROACH: Use PaymentIntent for immediate one-time charge
    // This ensures the exact amount is charged right away (not using invoices which can have $0 issues)
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(subscriptionPrice * 100), // Convert to cents
      currency: 'usd',
      customer: subscription.customer as string,
      payment_method: defaultPaymentMethod as string,
      off_session: true, // Allows charging without customer present
      confirm: true, // Automatically confirm and charge
      description: `${subscriptionProductName} - Manual Charge`,
      metadata: {
        orderId: orderId,
        manualCharge: 'true',
        subscriptionId: order.subscriptionId,
      },
    });
    
    console.log(`üí≥ Payment Intent created: ${paymentIntent.id}`);
    console.log(`üí∞ Payment status: ${paymentIntent.status}, Amount: ${(paymentIntent.amount / 100).toFixed(2)}`);
    
    // Check payment status
    if (paymentIntent.status !== 'succeeded') {
      console.error(`‚ö†Ô∏è Payment did not succeed. Status: ${paymentIntent.status}`);
      
      // Log the declined charge
      order.declinedCharges = (order.declinedCharges || 0) + 1;
      order.updatedAt = new Date().toISOString();
      
      if (!order.activityLog) {
        order.activityLog = [];
      }
      order.activityLog.push({
        timestamp: new Date().toISOString(),
        action: 'Subscription Charge Declined (Charge Now)',
        details: `Charge of ${subscriptionPrice.toFixed(2)} declined. Status: ${paymentIntent.status}. PaymentIntent: ${paymentIntent.id}`,
        user: 'Admin',
        stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntent.id}`
      });
      
      await kv.set(`order:${orderId}`, order);
      
      return c.json({ 
        error: `Payment failed. Status: ${paymentIntent.status}`,
        paymentIntentId: paymentIntent.id,
        stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntent.id}`
      }, 400);
    }
    
    // Create a mock invoice object for the rest of the code
    const paidInvoice = { 
      id: paymentIntent.id, 
      status: 'paid',
      amount_paid: paymentIntent.amount 
    };
    
    // Calculate next billing date
    let nextBillingDate;
    if (customBillingDate) {
      nextBillingDate = customBillingDate;
    } else {
      // Use billing interval to calculate next date
      const billingIntervalDays = order.billingIntervalDays || 30;
      const nextBilling = new Date();
      nextBilling.setDate(nextBilling.getDate() + billingIntervalDays);
      nextBillingDate = nextBilling.toISOString();
    }
    
    const billingTimestamp = Math.floor(new Date(nextBillingDate).getTime() / 1000);
    const now = Math.floor(Date.now() / 1000);
    
    if (billingTimestamp > now) {
      // Set trial_end to update next billing date
      await stripe.subscriptions.update(order.subscriptionId, {
        trial_end: billingTimestamp,
        proration_behavior: 'none',
      });
      
      console.log(`‚úÖ Updated next billing date to: ${nextBillingDate}`);
    }
    
    // Update order with new billing date and increment counters
    order.subscriptionNextBillingDate = nextBillingDate;
    order.successfulCharges = (order.successfulCharges || 0) + 1;
    order.subscriptionMonthsActive = order.successfulCharges;
    order.lastChargeDate = new Date().toISOString(); // Track when last charged for 30-day protection
    order.updatedAt = new Date().toISOString();
    
    // Add to activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Subscription Charged (Charge Now)',
      details: `Charged ${subscriptionPrice.toFixed(2)}. Month ${order.successfulCharges}. Next billing: ${new Date(nextBillingDate).toLocaleDateString()}. PaymentIntent: ${paidInvoice.id}`,
      user: 'Admin',
      stripeUrl: `https://dashboard.stripe.com/payments/${paidInvoice.id}`
    });
    
    await kv.set(`order:${orderId}`, order);
    
    // Create a new order for this month's fulfillment
    console.log(`üì¶ Creating fulfillment order. Subscription letters count: ${(order.subscriptionLetters || []).length}`);
    console.log(`üì¶ Subscription letters data:`, JSON.stringify(order.subscriptionLetters));
    
    const allOrderIds = (await kv.get("orders:all")) || [];
    const newOrderId = `ord_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    const newOrder = {
      orderId: newOrderId,
      parentOrderId: order.orderId,
      subscriptionId: order.subscriptionId,
      sessionId: paidInvoice.id,
      stripePaymentId: paidInvoice.id,
      stripeCheckoutUrl: `https://dashboard.stripe.com/payments/${paidInvoice.id}`,
      orderDate: new Date().toISOString(),
      status: "pending",
      total: paidInvoice.amount_paid / 100,
      customerInfo: order.customerInfo,
      letterPackages: order.letterPackages,
      numberOfPackages: order.numberOfPackages,
      letters: order.subscriptionLetters || [], // Copy subscription letter data for fulfillment
      shippingDate: "",
      monthlySubscription: false,
      subscriptionRecurringOrder: true,
      subscriptionMonth: order.successfulCharges,
      subscriptionProductName: subscriptionProductName,
      affiliateId: order.affiliateId,
      affiliateName: order.affiliateName,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      activityLog: [{
        timestamp: new Date().toISOString(),
        action: 'Order Created',
        details: `Recurring subscription order - Month ${order.successfulCharges} (Charge Now). Copied ${(order.subscriptionLetters || []).length} letter(s) from subscription.`,
        user: 'Admin'
      }]
    };
    
    await kv.set(`order:${newOrderId}`, newOrder);
    allOrderIds.push(newOrderId);
    await kv.set("orders:all", allOrderIds);
    
    console.log(`‚úÖ Created new order ${newOrderId} for "Charge Now"`);
    
    console.log(`‚úÖ Manual charge successful: ${paidInvoice.id}, Amount: ${(paidInvoice.amount_paid / 100).toFixed(2)}`);
    
    // Send notification email
    if (order.customerInfo?.email) {
      try {
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        if (resendApiKey) {
          await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${resendApiKey}`,
            },
            body: JSON.stringify({
              from: "Santa's Workshop <noreply@updates.santascertifiedletter.com>",
              to: [order.customerInfo.email],
              subject: "üéÖ Your Monthly Santa Letter is On The Way!",
              html: `
                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                  <h2 style="color: #16a34a;">üéÖ Payment Received!</h2>
                  <p>Hello ${order.customerInfo.name},</p>
                  <p>Your monthly subscription payment has been processed successfully.</p>
                  <div style="background-color: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; border: 2px solid #16a34a;">
                    <p style="font-size: 24px; margin: 0; color: #16a34a;"><strong>$12.00</strong></p>
                    <p style="margin: 5px 0 0 0;">Monthly Subscription</p>
                  </div>
                  <p>Your monthly letter from Santa will be on its way soon!</p>
                  ${customBillingDate ? `<p>Next billing date: <strong>${new Date(customBillingDate).toLocaleDateString()}</strong></p>` : ''}
                  <p style="color: #dc2626;">üéÑ Thank you for keeping the magic alive!</p>
                </div>
              `,
            }),
          });
        }
      } catch (error) {
        console.error("‚ùå Failed to send notification email:", error);
      }
    }
    
    return c.json({ 
      success: true, 
      paymentIntentId: paidInvoice.id,
      amountCharged: (paidInvoice.amount_paid / 100).toFixed(2),
      nextBillingDate: customBillingDate || order.subscriptionNextBillingDate,
      stripeUrl: `https://dashboard.stripe.com/payments/${paidInvoice.id}`
    });
  } catch (error: any) {
    console.error("ÔøΩÔøΩ Error charging subscription:", error);
    return c.json({ 
      error: error.message || "Failed to charge subscription",
      details: error.toString(),
    }, 500);
  }
});

// Update Billing Interval for Subscription
app.post("/make-server-cf244566/admin/update-billing-interval", async (c) => {
  try {
    const { orderId, billingIntervalDays } = await c.req.json();
    
    console.log(`üîÑ Updating billing interval for order: ${orderId} to ${billingIntervalDays} days`);
    
    // Get order
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!order.subscriptionId) {
      return c.json({ error: "Order does not have a subscription" }, 400);
    }
    
    // Validate interval
    if (!billingIntervalDays || billingIntervalDays < 1 || billingIntervalDays > 365) {
      return c.json({ error: "Billing interval must be between 1 and 365 days" }, 400);
    }
    
    // Update order
    order.billingIntervalDays = billingIntervalDays;
    order.updatedAt = new Date().toISOString();
    
    // Add to activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Billing Interval Updated',
      details: `Billing interval set to ${billingIntervalDays} days`,
      user: 'Admin'
    });
    
    await kv.set(`order:${orderId}`, order);
    
    console.log(`‚úÖ Billing interval updated to ${billingIntervalDays} days`);
    
    return c.json({ 
      success: true,
      billingIntervalDays: billingIntervalDays,
      message: "Billing interval updated successfully"
    });
  } catch (error: any) {
    console.error("Error updating billing interval:", error);
    return c.json({ 
      error: error.message || "Failed to update billing interval" 
    }, 500);
  }
});

// Update Subscription Price
app.post("/make-server-cf244566/admin/update-subscription-price", async (c) => {
  try {
    const { orderId, subscriptionPrice } = await c.req.json();
    
    console.log(`üí∞ Updating subscription price for order: ${orderId} to ${subscriptionPrice}`);
    
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!order.subscriptionId) {
      return c.json({ error: "Order does not have a subscription" }, 400);
    }
    
    if (!subscriptionPrice || subscriptionPrice < 0.50 || subscriptionPrice > 999.99) {
      return c.json({ error: "Subscription price must be between $0.50 and $999.99" }, 400);
    }
    
    const oldPrice = order.subscriptionPrice || 12.00;
    order.subscriptionPrice = parseFloat(subscriptionPrice);
    order.updatedAt = new Date().toISOString();
    
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Subscription Price Updated',
      details: `Price changed from ${oldPrice.toFixed(2)} to ${parseFloat(subscriptionPrice).toFixed(2)}`,
      user: 'Admin'
    });
    
    await kv.set(`order:${orderId}`, order);
    
    console.log(`‚úÖ Subscription price updated to ${subscriptionPrice}`);
    
    return c.json({ 
      success: true,
      subscriptionPrice: parseFloat(subscriptionPrice),
      message: "Subscription price updated successfully"
    });
  } catch (error: any) {
    console.error("Error updating subscription price:", error);
    return c.json({ 
      error: error.message || "Failed to update subscription price" 
    }, 500);
  }
});

// Update Subscription Product Name
app.post("/make-server-cf244566/admin/update-subscription-product", async (c) => {
  try {
    const { orderId, subscriptionProductName } = await c.req.json();
    
    console.log(`üì¶ Updating subscription product name for order: ${orderId}`);
    
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!order.subscriptionId) {
      return c.json({ error: "Order does not have a subscription" }, 400);
    }
    
    if (!subscriptionProductName || subscriptionProductName.trim().length === 0) {
      return c.json({ error: "Product name cannot be empty" }, 400);
    }
    
    if (subscriptionProductName.length > 100) {
      return c.json({ error: "Product name must be 100 characters or less" }, 400);
    }
    
    const oldProductName = order.subscriptionProductName || "Santa's Magical Journey";
    order.subscriptionProductName = subscriptionProductName.trim();
    order.updatedAt = new Date().toISOString();
    
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Subscription Product Updated',
      details: `Product changed from "${oldProductName}" to "${subscriptionProductName.trim()}"`,
      user: 'Admin'
    });
    
    await kv.set(`order:${orderId}`, order);
    
    console.log(`‚úÖ Subscription product name updated`);
    
    return c.json({ 
      success: true,
      subscriptionProductName: subscriptionProductName.trim(),
      message: "Subscription product name updated successfully"
    });
  } catch (error: any) {
    console.error("Error updating subscription product name:", error);
    return c.json({ 
      error: error.message || "Failed to update subscription product name" 
    }, 500);
  }
});

// Admin Affiliate Reporting Endpoint
app.get("/make-server-cf244566/admin/affiliate-reports", async (c) => {
  try {
    const dateRange = c.req.query("dateRange") || "7days";
    const affiliateId = c.req.query("affiliateId");

    // Calculate date range
    const now = new Date();
    let startDate = new Date();
    
    switch (dateRange) {
      case "today":
        startDate.setHours(0, 0, 0, 0);
        break;
      case "yesterday":
        startDate.setDate(startDate.getDate() - 1);
        startDate.setHours(0, 0, 0, 0);
        now.setDate(now.getDate() - 1);
        now.setHours(23, 59, 59, 999);
        break;
      case "7days":
        startDate.setDate(startDate.getDate() - 7);
        break;
      case "30days":
        startDate.setDate(startDate.getDate() - 30);
        break;
      case "thismonth":
        startDate.setDate(1);
        startDate.setHours(0, 0, 0, 0);
        break;
      case "lastmonth":
        const lastMonth = new Date();
        lastMonth.setMonth(lastMonth.getMonth() - 1);
        startDate = new Date(lastMonth.getFullYear(), lastMonth.getMonth(), 1);
        now.setMonth(now.getMonth() - 1);
        now.setDate(1);
        now.setMonth(now.getMonth() + 1);
        now.setDate(0);
        now.setHours(23, 59, 59, 999);
        break;
    }

    // Fetch all orders
    const allOrderIds = (await kv.get("orders:all")) || [];
    const allOrders: any[] = [];
    
    for (const orderId of allOrderIds) {
      const order: any = await kv.get(`order:${orderId}`);
      if (order) {
        allOrders.push(order);
      }
    }

    // Filter orders by date range and affiliate
    const filteredOrders = allOrders.filter((order: any) => {
      const orderDate = new Date(order.orderDate);
      const inDateRange = orderDate >= startDate && orderDate <= now;
      const matchesAffiliate = !affiliateId || affiliateId === "all" || order.affiliateId === affiliateId;
      return inDateRange && matchesAffiliate;
    });

    // Fetch all events
    const allEventIds = (await kv.get("events:all")) || [];
    const allEvents: any[] = [];
    
    for (const eventId of allEventIds) {
      const event: any = await kv.get(`event:${eventId}`);
      if (event) {
        allEvents.push(event);
      }
    }

    // Filter events by date range and affiliate
    const filteredEvents = allEvents.filter((event: any) => {
      const eventDate = new Date(event.timestamp);
      const inDateRange = eventDate >= startDate && eventDate <= now;
      const matchesAffiliate = !affiliateId || affiliateId === "all" || event.affiliateId === affiliateId;
      return inDateRange && matchesAffiliate;
    });

    // Get affiliate names
    const affiliateNames: Record<string, string> = {};
    const allAffiliateIds = (await kv.get("affiliates:all")) || [];
    for (const affId of allAffiliateIds) {
      const affiliate: any = await kv.get(`affiliate:${affId}`);
      if (affiliate) {
        affiliateNames[affId] = affiliate.affiliateName;
      }
    }

    // Fetch chargebacks
    const allChargebacks = (await kv.get("chargebacks:all")) || [];
    const chargebackDetails: any[] = [];
    
    for (const chargebackId of allChargebacks) {
      const chargeback: any = await kv.get(`chargeback:${chargebackId}`);
      if (chargeback) {
        const chargebackDate = new Date(chargeback.chargebackDate);
        const inDateRange = chargebackDate >= startDate && chargebackDate <= now;
        const matchesAffiliate = !affiliateId || affiliateId === "all" || chargeback.affiliateId === affiliateId;
        
        if (inDateRange && matchesAffiliate) {
          chargebackDetails.push(chargeback);
        }
      }
    }

    // Calculate daily reports
    const dailyMap: Record<string, any> = {};
    
    // Process clicks from events
    filteredEvents.forEach((event: any) => {
      const date = new Date(event.timestamp).toISOString().split('T')[0];
      if (!dailyMap[date]) {
        dailyMap[date] = { date, clicks: 0, conversions: 0, revenue: 0, commission: 0, refunds: 0, chargebacks: 0, declines: 0 };
      }
      
      if (event.eventType === "page_view") {
        dailyMap[date].clicks++;
      }
      if (event.eventType === "sale") {
        dailyMap[date].conversions++;
        dailyMap[date].revenue += event.revenue || 0;
        dailyMap[date].commission += event.commission || 0;
      }
    });

    // Process orders
    filteredOrders.forEach((order: any) => {
      const date = new Date(order.orderDate).toISOString().split('T')[0];
      if (!dailyMap[date]) {
        dailyMap[date] = { date, clicks: 0, conversions: 0, revenue: 0, commission: 0, refunds: 0, chargebacks: 0, declines: 0 };
      }
      
      if (order.status === "canceled-refunded") {
        dailyMap[date].refunds++;
      }
      if (order.status === "chargeback") {
        dailyMap[date].chargebacks++;
      }
    });

    const dailyReports = Object.values(dailyMap).sort((a: any, b: any) => 
      new Date(b.date).getTime() - new Date(a.date).getTime()
    );

    // Calculate hourly reports (last 24 hours only)
    const hourlyMap: Record<string, any> = {};
    const last24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);
    
    filteredEvents.forEach((event: any) => {
      const eventDate = new Date(event.timestamp);
      if (eventDate >= last24Hours) {
        const hour = eventDate.getHours().toString().padStart(2, '0') + ':00';
        if (!hourlyMap[hour]) {
          hourlyMap[hour] = { hour, clicks: 0, conversions: 0, revenue: 0, commission: 0 };
        }
        
        if (event.eventType === "page_view") {
          hourlyMap[hour].clicks++;
        }
        if (event.eventType === "sale") {
          hourlyMap[hour].conversions++;
          hourlyMap[hour].revenue += event.revenue || 0;
          hourlyMap[hour].commission += event.commission || 0;
        }
      }
    });

    // Fill in missing hours with zeros
    for (let i = 0; i < 24; i++) {
      const hour = i.toString().padStart(2, '0') + ':00';
      if (!hourlyMap[hour]) {
        hourlyMap[hour] = { hour, clicks: 0, conversions: 0, revenue: 0, commission: 0 };
      }
    }

    const hourlyReports = Object.values(hourlyMap).sort((a: any, b: any) => 
      a.hour.localeCompare(b.hour)
    );

    // Prepare order details
    const orderDetails = filteredOrders.map((order: any) => ({
      orderId: order.orderId,
      sessionId: order.sessionId,
      affiliateId: order.affiliateId || "direct",
      affiliateName: order.affiliateName || affiliateNames[order.affiliateId] || "Direct Sale",
      customerEmail: order.customerInfo?.email || "",
      packageCount: order.numberOfPackages || 0,
      total: order.total || 0,
      commission: order.affiliateCommission || 0,
      status: order.status || "completed",
      orderDate: order.orderDate,
      subIds: order.subIds || {},
    }));

    // Calculate total stats
    const totalStats = {
      totalRevenue: filteredOrders.reduce((sum: number, o: any) => 
        o.status !== "canceled-refunded" && o.status !== "chargeback" ? sum + (o.total || 0) : sum, 0),
      totalCommission: filteredOrders.reduce((sum: number, o: any) => 
        o.status !== "canceled-refunded" && o.status !== "chargeback" ? sum + (o.affiliateCommission || 0) : sum, 0),
      totalRefunds: filteredOrders.filter((o: any) => o.status === "canceled-refunded").reduce((sum: number, o: any) => 
        sum + (o.total || 0), 0),
      totalChargebacks: chargebackDetails.reduce((sum: number, cb: any) => sum + (cb.amount || 0), 0),
      totalDeclines: 0, // Would need to track payment failures
      netRevenue: 0,
    };

    totalStats.netRevenue = totalStats.totalRevenue - totalStats.totalRefunds - totalStats.totalChargebacks;

    return c.json({
      dailyReports,
      hourlyReports,
      orders: orderDetails,
      chargebacks: chargebackDetails,
      totalStats,
    });
  } catch (error: any) {
    console.error("Error generating affiliate reports:", error);
    return c.json({ error: "Failed to generate reports" }, 500);
  }
});

// ========== DECLINED ORDERS ENDPOINTS ==========

// Get all declined orders
app.get("/make-server-cf244566/declined-orders", async (c) => {
  try {
    console.log("üìã Fetching all declined orders...");
    
    // Get all decline IDs
    const allDeclines = (await kv.get("all_declines")) || [];
    
    // Fetch all decline records
    const declines = [];
    for (const declineId of allDeclines) {
      const decline = await kv.get(`decline:${declineId}`);
      if (decline) {
        declines.push(decline);
      }
    }
    
    // Sort by timestamp (newest first)
    declines.sort((a: any, b: any) => {
      return new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime();
    });
    
    console.log(`‚úÖ Found ${declines.length} declined orders`);
    
    return c.json({ declines });
  } catch (error: any) {
    console.error("‚ùå Error fetching declined orders:", error);
    return c.json({ error: "Failed to fetch declined orders" }, 500);
  }
});

// Log a declined payment attempt
app.post("/make-server-cf244566/log-decline", async (c) => {
  try {
    const body = await c.req.json();
    const {
      timestamp,
      paymentIntentId,
      status,
      declineReason,
      declineCode,
      amount,
      customerInfo,
      letterPackages,
      numberOfPackages,
      affiliateId,
      subIds
    } = body;

    console.log("üìù Logging declined payment:", paymentIntentId);

    // Generate unique decline ID
    const declineId = `decline_${Date.now()}_${Math.random().toString(36).substring(7)}`;

    // Create decline record
    const declineRecord = {
      declineId,
      timestamp: timestamp || new Date().toISOString(),
      paymentIntentId: paymentIntentId || 'unknown',
      status: status || 'declined',
      declineReason: declineReason || 'Unknown error',
      declineCode: declineCode || 'unknown',
      amount: amount || 0,
      customerInfo: customerInfo || {},
      letterPackages: letterPackages || [],
      numberOfPackages: numberOfPackages || 0,
      affiliateId: affiliateId || null,
      subIds: subIds || {},
      
      // Email sequence tracking (initialized)
      emailSequence: {
        emailsSent: 0,
        lastEmailSent: null,
        emailDates: []
      },
      
      // Status flags
      unsubscribed: false,
      unsubscribedAt: null,
      converted: false,
      convertedAt: null
    };

    // Initialize activity log
    declineRecord.activityLog = [];

    // Save to database
    await kv.set(`decline:${declineId}`, declineRecord);

    // Add to all declines index
    const allDeclines = (await kv.get("all_declines")) || [];
    allDeclines.push(declineId);
    await kv.set("all_declines", allDeclines);

    console.log("‚úÖ Decline logged successfully:", declineId);

    return c.json({
      success: true,
      declineId: declineId
    });
  } catch (error: any) {
    console.error("‚ùå Error logging decline:", error);
    return c.json({ error: "Failed to log decline" }, 500);
  }
});

// Track email open (via tracking pixel)
app.get("/make-server-cf244566/decline/track/open/:declineId/:emailNumber", async (c) => {
  try {
    const declineId = c.req.param("declineId");
    const emailNumber = parseInt(c.req.param("emailNumber"));
    
    console.log(`ÔøΩÔøΩÔøΩ Email opened: ${declineId}, email #${emailNumber}`);
    
    // Get decline record
    const decline: any = await kv.get(`decline:${declineId}`);
    if (!decline) {
      return c.text("Not found", 404);
    }
    
    // Add to activity log
    if (!decline.activityLog) {
      decline.activityLog = [];
    }
    
    // Check if already logged (prevent duplicate opens)
    const alreadyLogged = decline.activityLog.some(
      (activity: any) => activity.type === 'email_opened' && activity.emailNumber === emailNumber
    );
    
    if (!alreadyLogged) {
      decline.activityLog.push({
        timestamp: new Date().toISOString(),
        type: 'email_opened',
        emailNumber: emailNumber
      });
      
      await kv.set(`decline:${declineId}`, decline);
      console.log(`‚úÖ Logged email open for decline ${declineId}`);
    }
    
    // Return 1x1 transparent pixel
    const pixel = Buffer.from(
      'R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
      'base64'
    );
    
    return c.body(pixel, 200, {
      'Content-Type': 'image/gif',
      'Cache-Control': 'no-store, no-cache, must-revalidate, proxy-revalidate',
      'Pragma': 'no-cache',
      'Expires': '0'
    });
  } catch (error: any) {
    console.error("‚ùå Error tracking email open:", error);
    // Return pixel anyway to avoid broken images
    const pixel = Buffer.from(
      'R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
      'base64'
    );
    return c.body(pixel, 200, { 'Content-Type': 'image/gif' });
  }
});

// Track email open (fallback without email number)
app.get("/make-server-cf244566/decline/track/open/:declineId", async (c) => {
  try {
    const declineId = c.req.param("declineId");
    
    console.log(`üìß Email opened (no email number): ${declineId}`);
    
    // Get decline record
    const decline: any = await kv.get(`decline:${declineId}`);
    if (decline) {
      // Add to activity log
      if (!decline.activityLog) {
        decline.activityLog = [];
      }
      
      decline.activityLog.push({
        timestamp: new Date().toISOString(),
        type: 'email_opened',
        emailNumber: 0,
        details: 'Email opened (unknown email number)'
      });
      
      await kv.set(`decline:${declineId}`, decline);
      console.log(`‚úÖ Logged email open for decline ${declineId}`);
    }
    
    // Return 1x1 transparent pixel
    const pixel = Buffer.from(
      'R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
      'base64'
    );
    
    return c.body(pixel, 200, {
      'Content-Type': 'image/gif',
      'Cache-Control': 'no-store, no-cache, must-revalidate, proxy-revalidate',
      'Pragma': 'no-cache',
      'Expires': '0'
    });
  } catch (error: any) {
    console.error("‚ùå Error tracking email open:", error);
    // Return pixel anyway to avoid broken images
    const pixel = Buffer.from(
      'R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
      'base64'
    );
    return c.body(pixel, 200, { 'Content-Type': 'image/gif' });
  }
});

// Track email click (with email number)
app.get("/make-server-cf244566/decline/track/click/:declineId/:emailNumber", async (c) => {
  try {
    const declineId = c.req.param("declineId");
    const emailNumber = parseInt(c.req.param("emailNumber"));
    
    console.log(`üñ±Ô∏è Email clicked: ${declineId}, email #${emailNumber}`);
    
    // Get decline record
    const decline: any = await kv.get(`decline:${declineId}`);
    if (decline) {
      // Add to activity log
      if (!decline.activityLog) {
        decline.activityLog = [];
      }
      
      decline.activityLog.push({
        timestamp: new Date().toISOString(),
        type: 'email_clicked',
        emailNumber: emailNumber,
        details: 'Recovery link clicked'
      });
      
      await kv.set(`decline:${declineId}`, decline);
      console.log(`‚úÖ Logged email click for decline ${declineId}`);
    }
    
    // Redirect to checkout with special recovery parameter
    // This allows us to track conversions
    const recoveryUrl = `https://santascertifiedletter.com/?recovery=${declineId}`;
    
    return c.redirect(recoveryUrl);
  } catch (error: any) {
    console.error("‚ùå Error tracking email click:", error);
    // Redirect anyway
    return c.redirect('https://santascertifiedletter.com/?recovery=error');
  }
});

// Track email click (fallback without email number for robustness)
app.get("/make-server-cf244566/decline/track/click/:declineId", async (c) => {
  try {
    const declineId = c.req.param("declineId");
    
    console.log(`üñ±Ô∏è Email clicked (no email number): ${declineId}`);
    
    // Get decline record
    const decline: any = await kv.get(`decline:${declineId}`);
    if (decline) {
      // Add to activity log
      if (!decline.activityLog) {
        decline.activityLog = [];
      }
      
      decline.activityLog.push({
        timestamp: new Date().toISOString(),
        type: 'email_clicked',
        emailNumber: 0,
        details: 'Recovery link clicked (unknown email number)'
      });
      
      await kv.set(`decline:${declineId}`, decline);
      console.log(`ÔøΩÔøΩÔøΩ Logged email click for decline ${declineId}`);
    }
    
    // Redirect to checkout with special recovery parameter
    const recoveryUrl = `https://santascertifiedletter.com/?recovery=${declineId}`;
    
    return c.redirect(recoveryUrl);
  } catch (error: any) {
    console.error("‚ùå Error tracking email click:", error);
    // Redirect anyway
    return c.redirect('https://santascertifiedletter.com/?recovery=error');
  }
});

// Unsubscribe from decline emails
app.get("/make-server-cf244566/decline/unsubscribe/:declineId", async (c) => {
  try {
    const declineId = c.req.param("declineId");
    
    console.log(`üö´ Unsubscribe request for: ${declineId}`);
    
    // Get decline record
    const decline: any = await kv.get(`decline:${declineId}`);
    if (!decline) {
      return c.html(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>Unsubscribe</title>
          <style>
            body { font-family: Arial, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; text-align: center; }
            h1 { color: #dc2626; }
          </style>
        </head>
        <body>
          <h1>‚ùå Not Found</h1>
          <p>We couldn't find this unsubscribe link.</p>
        </body>
        </html>
      `);
    }
    
    // Mark as unsubscribed
    decline.unsubscribed = true;
    decline.unsubscribedAt = new Date().toISOString();
    
    // Add to activity log
    if (!decline.activityLog) {
      decline.activityLog = [];
    }
    decline.activityLog.push({
      timestamp: new Date().toISOString(),
      type: 'unsubscribed',
      details: 'Customer unsubscribed from recovery emails'
    });
    
    await kv.set(`decline:${declineId}`, decline);
    
    console.log(`‚úÖ Unsubscribed: ${declineId}`);
    
    // Return confirmation page
    return c.html(`
      <!DOCTYPE html>
      <html>
      <head>
        <title>Unsubscribed</title>
        <style>
          body { font-family: Arial, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; text-align: center; }
          h1 { color: #10b981; }
          p { font-size: 16px; line-height: 1.6; color: #666; }
          .button { display: inline-block; background: #dc2626; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; margin-top: 20px; }
        </style>
      </head>
      <body>
        <h1>‚úÖ You've been unsubscribed</h1>
        <p>You will no longer receive recovery emails for this order.</p>
        <p>If you change your mind and want to complete your order, you can still do so:</p>
        <a href="https://santascertifiedletter.com/?recovery=${declineId}" class="button">Complete My Order</a>
      </body>
      </html>
    `);
  } catch (error: any) {
    console.error("‚ùå Error unsubscribing:", error);
    return c.html(`
      <!DOCTYPE html>
      <html>
      <head>
        <title>Error</title>
        <style>
          body { font-family: Arial, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; text-align: center; }
          h1 { color: #dc2626; }
        </style>
      </head>
      <body>
        <h1>‚ùå Error</h1>
        <p>There was an error processing your request. Please try again later.</p>
      </body>
      </html>
    `);
  }
});

// Mark decline as converted
app.post("/make-server-cf244566/decline/mark-converted", async (c) => {
  try {
    const { declineId, orderId } = await c.req.json();
    
    console.log(`ÔøΩÔøΩÔøΩ Marking decline as converted: ${declineId} -> ${orderId}`);
    
    // Get decline record
    const decline: any = await kv.get(`decline:${declineId}`);
    if (!decline) {
      return c.json({ error: "Decline not found" }, 404);
    }
    
    // Update decline record
    decline.converted = true;
    decline.convertedAt = new Date().toISOString();
    decline.convertedOrderId = orderId;
    
    // Add to activity log
    if (!decline.activityLog) {
      decline.activityLog = [];
    }
    decline.activityLog.push({
      timestamp: new Date().toISOString(),
      type: 'converted',
      details: orderId
    });
    
    await kv.set(`decline:${declineId}`, decline);
    
    console.log(`‚úÖ Decline marked as converted: ${declineId}`);
    
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error marking decline as converted:", error);
    return c.json({ error: "Failed to mark as converted" }, 500);
  }
});

// Send manual recovery email
app.post("/make-server-cf244566/decline/send-recovery", async (c) => {
  try {
    const { declineId } = await c.req.json();
    
    console.log(`üìß Sending manual recovery email for: ${declineId}`);
    
    // Get decline record
    const decline: any = await kv.get(`decline:${declineId}`);
    if (!decline) {
      return c.json({ error: "Decline not found" }, 404);
    }
    
    if (decline.unsubscribed) {
      return c.json({ error: "Customer has unsubscribed" }, 400);
    }
    
    if (decline.converted) {
      return c.json({ error: "Customer has already converted" }, 400);
    }
    
    // Send recovery email
    const emailNumber = Math.max(1, (decline.emailSequence?.emailsSent || 0) + 1);
    const baseUrl = 'https://santascertifiedletter.com';
    
    // Create tracking URLs with validated email number
    const supabaseUrl = Deno.env.get('SUPABASE_URL');
    const trackingPixelUrl = `${supabaseUrl}/functions/v1/make-server-cf244566/decline/track/open/${declineId}/${emailNumber}`;
    const trackingClickUrl = `${supabaseUrl}/functions/v1/make-server-cf244566/decline/track/click/${declineId}/${emailNumber}`;
    const unsubscribeUrl = `${supabaseUrl}/functions/v1/make-server-cf244566/decline/unsubscribe/${declineId}`;
    
    console.log(`üìß Tracking URLs - Pixel: ${trackingPixelUrl}, Click: ${trackingClickUrl}`);
    
    // Send email via Resend
    const resendApiKey = Deno.env.get('RESEND_API_KEY');
    if (!resendApiKey) {
      return c.json({ error: "Resend API key not configured" }, 500);
    }
    
    // Direct link to update payment page (using query parameter)
    const updatePaymentUrl = `${baseUrl}/?page=updatepayment&token=${declineId}`;
    
    const emailHtml = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
        <style>
          body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0; }
          .container { max-width: 600px; margin: 0 auto; padding: 20px; }
          .header { background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
          .header h1 { margin: 0; font-family: 'Pacifico', cursive; font-size: 32px; }
          .content { background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none; }
          .button { display: inline-block; background: #dc2626; color: white !important; padding: 15px 30px; text-decoration: none; border-radius: 8px; font-weight: bold; margin: 20px 0; font-size: 18px; }
          .button:hover { background: #b91c1c; }
          .footer { background: #f9fafb; padding: 20px; text-align: center; color: #6b7280; font-size: 12px; border-radius: 0 0 10px 10px; }
          ul { background: #f3f4f6; padding: 20px; border-radius: 8px; }
          li { margin: 10px 0; }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="header">
            <h1>üéÖ Your Letter From Santa is Waiting!</h1>
          </div>
          <div class="content">
            <p>Hi ${decline.customerInfo.name},</p>
            
            <p>We noticed there was a small issue with your recent order for ${decline.numberOfPackages} Santa Letter${decline.numberOfPackages > 1 ? 's' : ''}.</p>
            
            <p style="font-size: 18px; color: #059669;"><strong>Don't worry - we've reserved your spot!</strong> üéÑ</p>
            
            <p>Simply click the button below to complete your order and give ${decline.letterPackages.map((pkg: any) => pkg.childFirstName).join(' and ')} the magical Christmas experience they deserve!</p>
            
            <div style="text-align: center;">
              <a href="${updatePaymentUrl}" class="button">
                ‚ú® Complete Your Order Now
              </a>
            </div>
            
            <p><strong>Your reserved order includes:</strong></p>
            <ul>
              <li>${decline.numberOfPackages} Personalized Letter${decline.numberOfPackages > 1 ? 's' : ''} from Santa</li>
              <li>North Pole postmark</li>
              <li>Official Nice List Certificate</li>
              <li>Activity sheet and stickers</li>
            </ul>
            
            <p>This is a limited-time offer - complete your order today!</p>
            
            <p>Ho Ho Ho! üéÖ</p>
            <p>Santa's Workshop Team</p>
          </div>
          <div class="footer">
            <p><a href="${unsubscribeUrl}" style="color: #6b7280; text-decoration: underline;">Unsubscribe</a> from these emails</p>
            <p style="margin-top: 10px; color: #9ca3af;">¬© 2025 Letters From Santa. All rights reserved.</p>
          </div>
        </div>
        <img src="${trackingPixelUrl}" width="1" height="1" alt="" style="display:none;" />
      </body>
      </html>
    `;
    
    const emailResponse = await fetch('https://api.resend.com/emails', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${resendApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        from: 'Santa\'s Workshop <noreply@updates.santascertifiedletter.com>',
        to: [decline.customerInfo.email],
        subject: `üéÖ ${decline.customerInfo.name}, Your Santa Letters Are Reserved!`,
        html: emailHtml
      }),
    });
    
    if (!emailResponse.ok) {
      const errorData = await emailResponse.json();
      console.error("‚ùå Resend error:", errorData);
      return c.json({ error: "Failed to send email" }, 500);
    }
    
    // Update decline record
    if (!decline.emailSequence) {
      decline.emailSequence = { emailsSent: 0, lastEmailSent: null, emailDates: [] };
    }
    decline.emailSequence.emailsSent++;
    decline.emailSequence.lastEmailSent = new Date().toISOString();
    decline.emailSequence.emailDates.push(new Date().toISOString());
    
    // Add to activity log
    if (!decline.activityLog) {
      decline.activityLog = [];
    }
    decline.activityLog.push({
      timestamp: new Date().toISOString(),
      type: 'email_sent',
      emailNumber: emailNumber
    });
    
    await kv.set(`decline:${declineId}`, decline);
    
    console.log(`‚úÖ Recovery email sent for decline ${declineId}`);
    
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error sending recovery email:", error);
    return c.json({ error: "Failed to send recovery email" }, 500);
  }
});

// ========== DECLINED ORDERS EMAIL SEQUENCE SYSTEM ==========

// Unsubscribe from decline emails
app.get("/make-server-cf244566/decline/unsubscribe/:declineId", async (c) => {
  try {
    const declineId = c.req.param("declineId");
    
    // Get the decline record
    const decline: any = await kv.get(`decline:${declineId}`);
    
    if (!decline) {
      return c.text("Decline record not found", 404);
    }
    
    // Mark as unsubscribed
    decline.unsubscribed = true;
    decline.unsubscribedAt = new Date().toISOString();
    
    // Add to activity log
    if (!decline.activityLog) {
      decline.activityLog = [];
    }
    decline.activityLog.push({
      timestamp: new Date().toISOString(),
      type: 'unsubscribed'
    });
    
    await kv.set(`decline:${declineId}`, decline);
    
    console.log(`‚úÖ Unsubscribed from decline emails: ${declineId}`);
    
    // Return HTML page
    return c.html(`
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Unsubscribed</title>
        <style>
          body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 50px auto;
            padding: 20px;
            text-align: center;
          }
          .success {
            background: #ecfdf5;
            border: 2px solid #6ee7b7;
            border-radius: 8px;
            padding: 30px;
            margin: 20px 0;
          }
          h1 {
            color: #059669;
            margin: 0 0 15px 0;
          }
          p {
            color: #374151;
            line-height: 1.6;
          }
        </style>
      </head>
      <body>
        <div class="success">
          <h1>‚úÖ Successfully Unsubscribed</h1>
          <p>You will no longer receive follow-up emails about your declined payment.</p>
          <p>If you change your mind and would like to complete your order, you can always visit our website directly.</p>
        </div>
        <p style="color: #6b7280; font-size: 14px; margin-top: 30px;">
          Thank you for your interest in Letters From Santa! üéÖ
        </p>
      </body>
      </html>
    `);
  } catch (error: any) {
    console.error("Error unsubscribing:", error);
    return c.text("Error processing unsubscribe request", 500);
  }
});

// Process declined orders email sequence (to be called daily via cron or manual trigger)
app.post("/make-server-cf244566/decline/process-sequence", async (c) => {
  try {
    console.log("üîÑ Processing declined orders email sequence...");
    
    const resendApiKey = Deno.env.get("RESEND_API_KEY");
    if (!resendApiKey) {
      console.error("RESEND_API_KEY not configured");
      return c.json({ error: "Email service not configured" }, 500);
    }
    
    // Get all declined orders
    const declines = await kv.getByPrefix("decline:");
    const today = new Date();
    
    let emailsSent = 0;
    let emailsSkipped = 0;
    
    for (const decline of declines) {
      // Skip if unsubscribed
      if (decline.unsubscribed) {
        emailsSkipped++;
        continue;
      }
      
      // Skip if converted (check if order with same email exists)
      const orders = await kv.getByPrefix("order:");
      const hasConverted = orders.some((order: any) => 
        order.customerInfo?.email?.toLowerCase() === decline.customerInfo?.email?.toLowerCase()
      );
      
      if (hasConverted) {
        // Mark as converted so we don't check again
        decline.converted = true;
        decline.convertedAt = new Date().toISOString();
        await kv.set(`decline:${decline.declineId}`, decline);
        emailsSkipped++;
        continue;
      }
      
      // Calculate days since decline
      const declineDate = new Date(decline.timestamp);
      const daysSinceDecline = Math.floor((today.getTime() - declineDate.getTime()) / (1000 * 60 * 60 * 24));
      
      // Initialize email tracking if not exists
      if (!decline.emailSequence) {
        decline.emailSequence = {
          emailsSent: 0,
          lastEmailSent: null,
          emailDates: []
        };
      }
      
      // Check if we should send email today
      const lastEmailDate = decline.emailSequence.lastEmailSent ? new Date(decline.emailSequence.lastEmailSent) : null;
      const hoursSinceLastEmail = lastEmailDate ? (today.getTime() - lastEmailDate.getTime()) / (1000 * 60 * 60) : 999;
      
      // Send one email per day (24 hours between emails)
      if (hoursSinceLastEmail < 23) {
        emailsSkipped++;
        continue;
      }
      
      // Limit to 7 emails total
      if (decline.emailSequence.emailsSent >= 7) {
        emailsSkipped++;
        continue;
      }
      
      // Prepare email content based on day number
      const dayNumber = decline.emailSequence.emailsSent + 1;
      const baseUrl = 'https://santascertifiedletter.com';
      const supabaseUrl = Deno.env.get('SUPABASE_URL');
      const trackingPixelUrl = `${supabaseUrl}/functions/v1/make-server-cf244566/decline/track/open/${decline.declineId}/${dayNumber}`;
      const trackingClickUrl = `${supabaseUrl}/functions/v1/make-server-cf244566/decline/track/click/${decline.declineId}/${dayNumber}`;
      const unsubscribeUrl = `${supabaseUrl}/functions/v1/make-server-cf244566/decline/unsubscribe/${decline.declineId}`;
      
      let subject = "";
      let message = "";
      
      switch (dayNumber) {
        case 1:
          subject = "üéÖ Complete Your Santa Letter Order";
          message = `We noticed there was an issue processing your payment for your Santa Letter order. We'd love to help you complete it!`;
          break;
        case 2:
          subject = "Still interested in your Santa Letter? üéÑ";
          message = `Your Santa Letter order is still waiting for you! Let's get those magical letters on their way to the North Pole.`;
          break;
        case 3:
          subject = "Don't miss out on the Christmas magic! ‚ú®";
          message = `Time is running out to get your personalized Letters From Santa delivered before Christmas!`;
          break;
        case 4:
          subject = "Your kids are going to love this! üéÅ";
          message = `Imagine the look on their faces when they receive a personalized letter from Santa himself!`;
          break;
        case 5:
          subject = "Last chance for Christmas delivery üöö";
          message = `We want to make sure your Santa Letters arrive in time for Christmas magic!`;
          break;
        case 6:
          subject = "We're here to help! ü§ù";
          message = `If you had any issues with payment, we're here to assist. Let's make this Christmas special!`;
          break;
        case 7:
          subject = "Final reminder: Santa Letters are waiting üéÖ";
          message = `This is our last reminder about your Santa Letter order. We'd hate for you to miss out!`;
          break;
      }
      
      const emailHtml = `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
        </head>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
          <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
            <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
              <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÖ Letters From Santa</h1>
              <p style="margin: 10px 0 0 0; font-size: 18px;">${subject}</p>
            </div>
            <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
              <p>Hi ${decline.customerInfo.name || 'there'},</p>
              
              <p style="font-size: 18px; color: #059669;"><strong>${message}</strong></p>
              
              <div style="background: #fef2f2; border-left: 4px solid #dc2626; padding: 15px; margin: 20px 0;">
                <p style="margin: 0; font-size: 16px;"><strong>üí≥ What happened:</strong></p>
                <p style="margin: 5px 0 0 0; color: #dc2626;">${decline.declineReason}</p>
              </div>
              
              <p><strong>Your order details:</strong></p>
              <ul style="background: #f3f4f6; padding: 20px; border-radius: 8px;">
                ${decline.letterPackages.map((pkg: any) => `
                  <li style="margin: 10px 0;">
                    Letter for <strong>${pkg.childFirstName} ${pkg.childLastName}</strong><br>
                    <span style="font-size: 14px; color: #6b7280;">to ${pkg.city}, ${pkg.state}</span>
                  </li>
                `).join('')}
              </ul>
              
              <p style="margin-top: 30px; font-size: 16px;"><strong>Total: ${decline.amount.toFixed(2)}</strong></p>
              
              <div style="text-align: center; margin: 30px 0;">
                <a href="${baseUrl}/?page=updatepayment&token=${decline.declineId}" 
                   style="display: inline-block; background: #dc2626; color: white; padding: 15px 40px; text-decoration: none; border-radius: 8px; font-weight: bold; font-size: 18px;">
                  üí≥ Update Payment Method
                </a>
              </div>
              
              <p style="margin-top: 30px; padding: 15px; background: #fef3c7; border-radius: 8px; border-left: 4px solid #f59e0b;">
                <strong>üí° Tip:</strong> Click "Update Payment Method" above to securely add a new card. Your order will be processed automatically once updated.
              </p>
              
              <p style="margin-top: 30px; color: #6b7280; font-size: 14px;">
                Need help? Reply to this email or contact our support team.
              </p>
            </div>
            <div style="background: #f9fafb; padding: 20px; text-align: center; color: #6b7280; font-size: 12px; border-radius: 0 0 10px 10px;">
              <p>Questions? Contact us at support@letterfromsanta.com</p>
              <p style="margin-top: 10px;">
                <a href="${unsubscribeUrl}" style="color: #6b7280; text-decoration: underline;">
                  Unsubscribe from these emails
                </a>
              </p>
              <p style="margin-top: 10px; color: #9ca3af;">¬© 2025 Letters From Santa. All rights reserved.</p>
            </div>
          </div>
        </body>
        </html>
      `;
      
      // Send email
      try {
        const emailResponse = await fetch("https://api.resend.com/emails", {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${resendApiKey}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
            to: decline.customerInfo.email,
            subject: subject,
            html: emailHtml,
          }),
        });
        
        if (emailResponse.ok) {
          // Update email sequence tracking
          decline.emailSequence.emailsSent++;
          decline.emailSequence.lastEmailSent = today.toISOString();
          decline.emailSequence.emailDates.push(today.toISOString());
          
          // Add to activity log
          if (!decline.activityLog) {
            decline.activityLog = [];
          }
          decline.activityLog.push({
            timestamp: today.toISOString(),
            type: 'email_sent',
            emailNumber: dayNumber
          });
          
          await kv.set(`decline:${decline.declineId}`, decline);
          
          emailsSent++;
          console.log(`‚úÖ Sent decline follow-up email #${dayNumber} to ${decline.customerInfo.email}`);
        } else {
          console.error(`‚ùå Failed to send decline email to ${decline.customerInfo.email}`);
        }
      } catch (emailError) {
        console.error(`Error sending decline email:`, emailError);
      }
    }
    
    console.log(`üìß Email sequence complete: ${emailsSent} sent, ${emailsSkipped} skipped`);
    
    return c.json({
      success: true,
      emailsSent,
      emailsSkipped,
      totalDeclines: declines.length
    });
  } catch (error: any) {
    console.error("Error processing decline email sequence:", error);
    return c.json({ error: "Failed to process email sequence" }, 500);
  }
});

// Manual trigger endpoint (for testing)
app.get("/make-server-cf244566/decline/send-test-sequence", async (c) => {
  console.log("üß™ Manually triggering decline email sequence...");
  
  // Call the main sequence endpoint
  const response = await app.request("/make-server-cf244566/decline/process-sequence", {
    method: "POST",
  });
  
  const data = await response.json();
  return c.json(data);
});

// ========== SUBSCRIPTION MANAGEMENT ENDPOINTS ==========

// Cancel a subscription
app.post("/make-server-cf244566/subscriptions/:subscriptionId/cancel", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }

  try {
    const subscriptionId = c.req.param("subscriptionId");
    
    console.log(`üö´ Canceling subscription: ${subscriptionId}`);
    
    // Cancel the subscription in Stripe
    const canceledSubscription = await stripe.subscriptions.cancel(subscriptionId);
    
    console.log(`‚úÖ Subscription canceled: ${subscriptionId}`);
    
    // Find and update the order
    const allOrderIds = (await kv.get("orders:all")) || [];
    for (const orderId of allOrderIds) {
      const order: any = await kv.get(`order:${orderId}`);
      if (order && order.subscriptionId === subscriptionId) {
        order.status = "canceled-refunded";
        order.subscriptionId = null;
        order.updatedAt = new Date().toISOString();
        await kv.set(`order:${orderId}`, order);
        
        // Send notification email
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        if (resendApiKey && order.customerInfo?.email) {
          try {
            await fetch("https://api.resend.com/emails", {
              method: "POST",
              headers: {
                "Authorization": `Bearer ${resendApiKey}`,
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                from: "Santa's Workshop <noreply@updates.santascertifiedletter.com>",
                to: [order.customerInfo.email],
                subject: "Subscription Canceled",
                html: `<div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;"><h2 style="color: #dc2626;">Subscription Canceled</h2><p>Hello ${order.customerInfo.name},</p><p>Your monthly Santa letter subscription has been canceled as requested.</p><p>You will not be charged again.</p><p>If this was done in error, please contact us.</p><p style="color: #dc2626;">üéÑ Thank you!</p></div>`,
              }),
            });
          } catch (error) {
            console.error("Failed to send cancellation email:", error);
          }
        }
        
        // Send SMS notification
        const twilioAccountSid = Deno.env.get("TWILIO_ACCOUNT_SID");
        const twilioAuthToken = Deno.env.get("TWILIO_AUTH_TOKEN");
        const twilioPhoneNumber = Deno.env.get("TWILIO_PHONE_NUMBER");
        
        if (twilioAccountSid && twilioAuthToken && twilioPhoneNumber && order.customerInfo?.phone) {
          try {
            const auth = btoa(`${twilioAccountSid}:${twilioAuthToken}`);
            await fetch(`https://api.twilio.com/2010-04-01/Accounts/${twilioAccountSid}/Messages.json`, {
              method: "POST",
              headers: {
                "Authorization": `Basic ${auth}`,
                "Content-Type": "application/x-www-form-urlencoded",
              },
              body: new URLSearchParams({
                To: order.customerInfo.phone,
                From: twilioPhoneNumber,
                Body: `Your Santa letter subscription has been canceled. You will not be charged again.`,
              }),
            });
          } catch (error) {
            console.error("Failed to send SMS:", error);
          }
        }
        
        break;
      }
    }
    
    return c.json({ 
      success: true,
      subscriptionId: canceledSubscription.id,
      status: canceledSubscription.status
    });
  } catch (error: any) {
    console.error("‚ùå Error canceling subscription:", error);
    return c.json({ error: "Failed to cancel subscription", details: error.message }, 500);
  }
});

// Create a new monthly order for a subscription (for testing/manual creation)
app.post("/make-server-cf244566/subscriptions/:subscriptionId/create-order", async (c) => {
  try {
    const subscriptionId = c.req.param("subscriptionId");
    
    console.log(`üì¶ Creating manual monthly order for subscription: ${subscriptionId}`);
    
    // Find the parent order with this subscription ID
    const allOrderIds = (await kv.get("orders:all")) || [];
    let parentOrder: any = null;
    
    for (const orderId of allOrderIds) {
      const order: any = await kv.get(`order:${orderId}`);
      if (order && order.subscriptionId === subscriptionId && order.monthlySubscription) {
        parentOrder = order;
        break;
      }
    }
    
    if (!parentOrder) {
      return c.json({ error: "Parent subscription order not found" }, 404);
    }
    
    // Increment successful charges on parent order
    parentOrder.successfulCharges = (parentOrder.successfulCharges || 0) + 1;
    parentOrder.subscriptionMonthsActive = parentOrder.successfulCharges;
    parentOrder.updatedAt = new Date().toISOString();
    
    // Add activity log
    if (!parentOrder.activityLog) {
      parentOrder.activityLog = [];
    }
    parentOrder.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Manual Order Created',
      details: `Created manual fulfillment order for month ${parentOrder.successfulCharges}`,
      user: 'Admin'
    });
    
    await kv.set(`order:${parentOrder.orderId}`, parentOrder);
    
    // Create new order ID
    const newOrderId = `ord_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    
    // Get subscription price from parent order
    const subscriptionPrice = parentOrder.subscriptionPrice || 12.00;
    const subscriptionProductName = parentOrder.subscriptionProductName || "Santa's Magical Journey";
    
    // Create new order for fulfillment
    const newOrder = {
      orderId: newOrderId,
      parentOrderId: parentOrder.orderId,
      subscriptionId: parentOrder.subscriptionId,
      sessionId: `manual_${newOrderId}`,
      stripePaymentId: null,
      stripeCheckoutUrl: null,
      orderDate: new Date().toISOString(),
      status: "pending",
      total: subscriptionPrice,
      customerInfo: parentOrder.customerInfo,
      letterPackages: parentOrder.letterPackages,
      numberOfPackages: parentOrder.numberOfPackages,
      shippingDate: "",
      monthlySubscription: false,
      subscriptionRecurringOrder: true,
      subscriptionMonth: parentOrder.successfulCharges,
      subscriptionProductName: subscriptionProductName,
      affiliateId: parentOrder.affiliateId,
      affiliateName: parentOrder.affiliateName,
      trackingNumber: null,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      activityLog: [{
        timestamp: new Date().toISOString(),
        action: 'Order Created',
        details: `Recurring subscription order - Month ${parentOrder.successfulCharges} (Manual)`,
        user: 'Admin'
      }]
    };
    
    // Save new order
    await kv.set(`order:${newOrderId}`, newOrder);
    
    // Add to orders index
    allOrderIds.push(newOrderId);
    await kv.set("orders:all", allOrderIds);
    
    console.log(`‚úÖ Created manual monthly order: ${newOrderId} for ${subscriptionProductName} at ${subscriptionPrice}`);
    
    return c.json({ 
      success: true,
      newOrderId,
      monthsActive: parentOrder.successfulCharges,
      productName: subscriptionProductName,
      price: subscriptionPrice
    });
  } catch (error: any) {
    console.error("‚ùå Error creating monthly order:", error);
    return c.json({ error: "Failed to create monthly order", details: error.message }, 500);
  }
});

// Alias endpoint for admin declined orders (matches frontend expectation)
app.get("/make-server-cf244566/admin/declined-orders", async (c) => {
  try {
    console.log("üìã Fetching declined orders (admin alias)...");
    
    const allDeclines = (await kv.get("all_declines")) || [];
    const declinedOrders = [];
    
    for (const declineId of allDeclines) {
      const decline = await kv.get(`decline:${declineId}`);
      if (decline) {
        declinedOrders.push(decline);
      }
    }
    
    declinedOrders.sort((a: any, b: any) => {
      return new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime();
    });
    
    console.log(`‚úÖ Found ${declinedOrders.length} declined orders`);
    
    return c.json({ declinedOrders });
  } catch (error: any) {
    console.error("‚ùå Error fetching declined orders:", error);
    return c.json({ error: "Failed to fetch declined orders", details: error.message }, 500);
  }
});

// ========== SUBSCRIPTION MANAGEMENT ENDPOINTS ==========

// Cancel subscription
app.post("/make-server-cf244566/subscriptions/:subscriptionId/cancel", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 500);
  }

  try {
    const subscriptionId = c.req.param("subscriptionId");
    const { orderId } = await c.req.json();
    
    console.log(`üö´ Canceling subscription: ${subscriptionId}`);
    
    // Get the order
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!order.subscriptionId) {
      return c.json({ error: "Order does not have a subscription" }, 400);
    }
    
    // Cancel subscription in Stripe
    const canceledSubscription = await stripe.subscriptions.cancel(subscriptionId);
    
    console.log(`‚úÖ Subscription canceled in Stripe: ${canceledSubscription.id}`);
    
    // Update order status but don't mark as canceled-refunded (only cancel future billing)
    order.subscriptionId = null; // Remove subscription ID
    order.subscriptionNextBillingDate = null;
    order.updatedAt = new Date().toISOString();
    
    // Add to activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Subscription Canceled',
      details: `Monthly subscription canceled by admin. Subscription ID: ${subscriptionId}`,
      user: 'Admin'
    });
    
    await kv.set(`order:${orderId}`, order);
    
    // Send notification
    await sendCancelSubscriptionNotification(order);
    
    return c.json({ 
      success: true,
      message: "Subscription canceled successfully",
      subscriptionId: canceledSubscription.id,
      status: canceledSubscription.status
    });
  } catch (error: any) {
    console.error("‚ùå Error canceling subscription:", error);
    return c.json({ 
      error: error.message || "Failed to cancel subscription",
      details: error.toString(),
    }, 500);
  }
});

// ========== DECLINED CHARGE RETRY AND DOWNSELL SYSTEM ==========

// Process declined charge retries (to be called daily via cron)
app.post("/make-server-cf244566/admin/process-retries", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 500);
  }

  try {
    console.log("üîÑ Processing declined charge retries...");
    
    const now = new Date();
    const allOrderIds = (await kv.get("orders:all")) || [];
    let retriesAttempted = 0;
    let retriesSucceeded = 0;
    let retriesFailed = 0;
    let downsellOffersSent = 0;
    
    for (const orderId of allOrderIds) {
      const order: any = await kv.get(`order:${orderId}`);
      
      // Skip if no subscription or no retry needed
      if (!order || !order.subscriptionId || !order.nextRetryDate) continue;
      
      // Skip if already offered downsell
      if (order.downsellOffered) continue;
      
      // Check if it's time to retry
      const nextRetry = new Date(order.nextRetryDate);
      if (nextRetry > now) continue;
      
      retriesAttempted++;
      
      console.log(`üîÅ Retrying charge for order ${orderId} (Attempt ${order.retryAttempts + 1})`);
      
      try {
        // Get subscription from Stripe
        const subscription = await stripe.subscriptions.retrieve(order.subscriptionId);
        
        if (subscription.status === "canceled") {
          console.log(`‚è≠Ô∏è Subscription canceled, skipping retry`);
          continue;
        }
        
        // Get payment method
        const defaultPaymentMethod = subscription.default_payment_method || 
                                      subscription.default_source;
        
        if (!defaultPaymentMethod) {
          console.log(`‚ö†Ô∏è No payment method on file`);
          retriesFailed++;
          continue;
        }
        
        const subscriptionPrice = order.subscriptionPrice || 12.00;
        
        // Attempt to charge
        const paymentIntent = await stripe.paymentIntents.create({
          amount: Math.round(subscriptionPrice * 100),
          currency: 'usd',
          customer: subscription.customer as string,
          payment_method: defaultPaymentMethod as string,
          off_session: true,
          confirm: true,
          description: `${order.subscriptionProductName || "Santa's Magical Journey"} - Retry Attempt ${order.retryAttempts + 1}`,
          metadata: {
            orderId: orderId,
            retryAttempt: String(order.retryAttempts + 1),
            subscriptionId: order.subscriptionId,
          },
        });
        
        if (paymentIntent.status === 'succeeded') {
          // Success! Reset retry counters
          retriesSucceeded++;
          order.retryAttempts = 0;
          order.firstFailureDate = null;
          order.lastFailureDate = null;
          order.nextRetryDate = null;
          order.lastChargeDate = new Date().toISOString();
          order.successfulCharges = (order.successfulCharges || 0) + 1;
          
          // Calculate next billing date
          const billingIntervalDays = order.billingIntervalDays || 30;
          const nextBilling = new Date();
          nextBilling.setDate(nextBilling.getDate() + billingIntervalDays);
          order.subscriptionNextBillingDate = nextBilling.toISOString();
          
          if (!order.activityLog) order.activityLog = [];
          order.activityLog.push({
            timestamp: new Date().toISOString(),
            action: 'Retry Charge Successful',
            details: `Retry attempt ${order.retryAttempts + 1} succeeded. Charged ${subscriptionPrice.toFixed(2)}`,
            user: 'System - Auto Retry'
          });
          
          await kv.set(`order:${orderId}`, order);
          
          // Send success email
          if (order.customerInfo?.email) {
            const childNames = order.letterPackages?.map((pkg: any) => pkg.childFirstName).join(' and ') || 'your child';
            await sendRetrySuccessEmail(order, childNames);
          }
          
          console.log(`‚úÖ Retry successful for order ${orderId}`);
        } else {
          // Failed again
          retriesFailed++;
          order.retryAttempts++;
          order.lastFailureDate = new Date().toISOString();
          
          // Check if we've hit 3 failures - send downsell offer
          if (order.retryAttempts >= 3 && !order.downsellOffered) {
            order.downsellOffered = true;
            order.downsellOfferedDate = new Date().toISOString();
            
            if (!order.activityLog) order.activityLog = [];
            order.activityLog.push({
              timestamp: new Date().toISOString(),
              action: 'Downsell Offer Sent',
              details: `After 3 failed attempts, sent downsell offer email`,
              user: 'System - Auto Retry'
            });
            
            await kv.set(`order:${orderId}`, order);
            
            // Send downsell offer email
            if (order.customerInfo?.email) {
              const childNames = order.letterPackages?.map((pkg: any) => pkg.childFirstName).join(' and ') || 'your child';
              await sendDownsellOfferEmail(order, childNames);
              downsellOffersSent++;
            }
            
            console.log(`üìß Downsell offer sent for order ${orderId}`);
          } else {
            // Schedule next retry in 2 days
            order.nextRetryDate = new Date(Date.now() + (48 * 60 * 60 * 1000)).toISOString();
            
            if (!order.activityLog) order.activityLog = [];
            order.activityLog.push({
              timestamp: new Date().toISOString(),
              action: 'Retry Charge Failed',
              details: `Retry attempt ${order.retryAttempts} failed. Next retry: ${new Date(order.nextRetryDate).toLocaleDateString()}`,
              user: 'System - Auto Retry'
            });
            
            await kv.set(`order:${orderId}`, order);
            
            // Send retry email
            if (order.customerInfo?.email) {
              const childNames = order.letterPackages?.map((pkg: any) => pkg.childFirstName).join(' and ') || 'your child';
              await sendRetryEmail(order, childNames, order.retryAttempts);
            }
            
            console.log(`‚ùå Retry failed for order ${orderId}, will retry again in 2 days`);
          }
        }
      } catch (error: any) {
        console.error(`‚ùå Error retrying charge for order ${orderId}:`, error);
        retriesFailed++;
        
        // Don't give up - schedule another retry
        order.nextRetryDate = new Date(Date.now() + (48 * 60 * 60 * 1000)).toISOString();
        await kv.set(`order:${orderId}`, order);
      }
    }
    
    console.log(`‚úÖ Retry processing complete: ${retriesAttempted} attempted, ${retriesSucceeded} succeeded, ${retriesFailed} failed, ${downsellOffersSent} downsell offers sent`);
    
    return c.json({
      success: true,
      retriesAttempted,
      retriesSucceeded,
      retriesFailed,
      downsellOffersSent
    });
  } catch (error: any) {
    console.error("‚ùå Error processing retries:", error);
    return c.json({ error: "Failed to process retries" }, 500);
  }
});

// Accept downsell offer
app.post("/make-server-cf244566/accept-downsell/:orderId", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 500);
  }

  try {
    const orderId = c.req.param("orderId");
    const { newPrice } = await c.req.json();
    
    console.log(`üí∞ Processing downsell acceptance for order ${orderId}: ${newPrice}`);
    
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!order.subscriptionId) {
      return c.json({ error: "No active subscription" }, 400);
    }
    
    // Validate price (must be between $8 and $12)
    const price = parseFloat(newPrice);
    if (isNaN(price) || price < 8 || price > 12) {
      return c.json({ error: "Invalid price. Must be between $8 and $12" }, 400);
    }
    
    // Update the order's subscription price
    const oldPrice = order.subscriptionPrice || 12.00;
    order.subscriptionPrice = price;
    order.downsellAccepted = true;
    order.downsellAcceptedDate = new Date().toISOString();
    order.downsellAcceptedPrice = price;
    order.retryAttempts = 0; // Reset retry counter
    order.nextRetryDate = null;
    
    if (!order.activityLog) order.activityLog = [];
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Downsell Accepted',
      details: `Customer accepted downsell from ${oldPrice.toFixed(2)} to ${price.toFixed(2)}/month`,
      user: 'Customer'
    });
    
    await kv.set(`order:${orderId}`, order);
    
    // Now try to charge the new lower price
    try {
      const subscription = await stripe.subscriptions.retrieve(order.subscriptionId);
      const defaultPaymentMethod = subscription.default_payment_method || subscription.default_source;
      
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(price * 100),
        currency: 'usd',
        customer: subscription.customer as string,
        payment_method: defaultPaymentMethod as string,
        off_session: true,
        confirm: true,
        description: `${order.subscriptionProductName || "Santa's Magical Journey"} - Downsell Accepted at ${price}`,
        metadata: {
          orderId: orderId,
          downsellPrice: String(price),
          subscriptionId: order.subscriptionId,
        },
      });
      
      if (paymentIntent.status === 'succeeded') {
        order.lastChargeDate = new Date().toISOString();
        order.successfulCharges = (order.successfulCharges || 0) + 1;
        
        // Calculate next billing
        const billingIntervalDays = order.billingIntervalDays || 30;
        const nextBilling = new Date();
        nextBilling.setDate(nextBilling.getDate() + billingIntervalDays);
        order.subscriptionNextBillingDate = nextBilling.toISOString();
        
        order.activityLog.push({
          timestamp: new Date().toISOString(),
          action: 'Downsell Payment Successful',
          details: `Charged ${price.toFixed(2)} after downsell acceptance`,
          user: 'System'
        });
        
        await kv.set(`order:${orderId}`, order);
        
        console.log(`‚úÖ Downsell payment successful for order ${orderId}`);
        
        return c.json({
          success: true,
          message: `Subscription updated to ${price.toFixed(2)}/month`,
          nextBillingDate: nextBilling.toISOString()
        });
      } else {
        return c.json({
          error: "Payment failed. Please update your payment method and try again.",
          paymentStatus: paymentIntent.status
        }, 400);
      }
    } catch (error: any) {
      console.error("‚ùå Error charging downsell price:", error);
      return c.json({
        error: "Failed to process payment. Please try again or contact support.",
        details: error.message
      }, 500);
    }
  } catch (error: any) {
    console.error("‚ùå Error accepting downsell:", error);
    return c.json({ error: "Failed to accept downsell offer" }, 500);
  }
});

// Helper function to send retry email
async function sendRetryEmail(order: any, childNames: string, attemptNumber: number) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  if (!resendApiKey) return;
  
  const emailHtml = `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
      <div style="background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
        <h1 style="margin: 0;">üéÖ Payment Issue - Action Needed</h1>
      </div>
      <div style="background: #ffffff; padding: 30px; border-radius: 0 0 10px 10px;">
        <p>Hi ${order.customerInfo.name},</p>
        
        <p>We tried to process your monthly subscription for <strong>${childNames}'s</strong> Letters from Santa, but we encountered a payment issue.</p>
        
        <div style="background: #fef3c7; padding: 20px; border-radius: 8px; border-left: 4px solid #f59e0b; margin: 20px 0;">
          <p style="margin: 0;"><strong>‚ö†Ô∏è We want to ship ${childNames}'s package!</strong></p>
          <p style="margin: 10px 0 0 0;">Please update your payment method so we can send this month's magical letter.</p>
        </div>
        
        <p>What to do:</p>
        <ul>
          <li>Check that your card hasn't expired</li>
          <li>Verify there are sufficient funds available</li>
          <li>Try a different payment method if needed</li>
        </ul>
        
        <div style="text-align: center; margin: 30px 0;">
          <a href="https://billing.stripe.com/p/login/${order.stripeCustomerId || ''}" 
             style="display: inline-block; background: #16a34a; color: white; padding: 15px 40px; text-decoration: none; border-radius: 8px; font-weight: bold; font-size: 18px;">
            üéÑ Update Payment Method
          </a>
        </div>
        
        <p style="color: #dc2626;"><strong>Don't let ${childNames} miss out on the magic!</strong></p>
        
        <p style="margin-top: 30px; color: #6b7280; font-size: 14px;">
          Need help? Reply to this email or contact our support team.
        </p>
      </div>
    </div>
  `;
  
  try {
    await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${resendApiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
        to: [order.customerInfo.email],
        subject: `üéÖ Payment Issue - ${childNames}'s Letter is Waiting!`,
        html: emailHtml,
      }),
    });
    console.log(`üìß Retry email sent to ${order.customerInfo.email}`);
  } catch (error) {
    console.error("‚ùå Failed to send retry email:", error);
  }
}

// Helper function to send retry success email
async function sendRetrySuccessEmail(order: any, childNames: string) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  if (!resendApiKey) return;
  
  const emailHtml = `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
      <div style="background: linear-gradient(135deg, #16a34a 0%, #15803d 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
        <h1 style="margin: 0;">‚úÖ Payment Successful!</h1>
      </div>
      <div style="background: #ffffff; padding: 30px; border-radius: 0 0 10px 10px;">
        <p>Hi ${order.customerInfo.name},</p>
        
        <p>Great news! Your payment has been processed successfully and <strong>${childNames}'s</strong> monthly letter from Santa is being prepared! üéÖ</p>
        
        <div style="background: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: center;">
          <p style="font-size: 24px; margin: 0; color: #16a34a;"><strong>${(order.subscriptionPrice || 12).toFixed(2)}</strong></p>
          <p style="margin: 5px 0 0 0;">Monthly Subscription</p>
        </div>
        
        <p>The magic continues! Your letter will be shipped soon.</p>
        
        <p style="color: #16a34a;"><strong>üéÑ Thank you for keeping the Christmas spirit alive!</strong></p>
      </div>
    </div>
  `;
  
  try {
    await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${resendApiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
        to: [order.customerInfo.email],
        subject: `üéÖ Payment Received - ${childNames}'s Letter is On The Way!`,
        html: emailHtml,
      }),
    });
    console.log(`üìß Success email sent to ${order.customerInfo.email}`);
  } catch (error) {
    console.error("‚ùå Failed to send success email:", error);
  }
}

// Helper function to send downsell offer email
async function sendDownsellOfferEmail(order: any, childNames: string) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  if (!resendApiKey) return;
  
  const currentPrice = order.subscriptionPrice || 12;
  const option1Price = 10;
  const option2Price = 8;
  
  const emailHtml = `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
      <div style="background: linear-gradient(135deg, #7c3aed 0%, #5b21b6 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
        <h1 style="margin: 0;">üéÅ Special Offer Just For You!</h1>
      </div>
      <div style="background: #ffffff; padding: 30px; border-radius: 0 0 10px 10px;">
        <p>Hi ${order.customerInfo.name},</p>
        
        <p>We really want ${childNames} to continue receiving magical letters from Santa! üéÖ</p>
        
        <p>We've noticed you've had some payment issues. We understand that sometimes budgets are tight, especially during the holidays.</p>
        
        <div style="background: #ede9fe; padding: 20px; border-radius: 8px; border-left: 4px solid #7c3aed; margin: 20px 0;">
          <p style="margin: 0;"><strong>üíú We'd like to offer you a special discount!</strong></p>
        </div>
        
        <p><strong>Choose the price that works best for you:</strong></p>
        
        <div style="background: #f9fafb; border: 2px solid #e5e7eb; border-radius: 8px; padding: 20px; margin: 15px 0;">
          <div style="text-align: center; margin-bottom: 15px;">
            <p style="font-size: 28px; color: #16a34a; margin: 0;"><strong>${option1Price}/month</strong></p>
            <p style="margin: 5px 0; color: #6b7280;">Save ${currentPrice - option1Price}/month</p>
          </div>
          <div style="text-align: center;">
            <a href="https://santascertifiedletter.com/accept-downsell/${order.orderId}?price=${option1Price}" 
               style="display: inline-block; background: #16a34a; color: white; padding: 12px 30px; text-decoration: none; border-radius: 8px; font-weight: bold;">
              Choose ${option1Price}/month
            </a>
          </div>
        </div>
        
        <div style="background: #f9fafb; border: 2px solid #e5e7eb; border-radius: 8px; padding: 20px; margin: 15px 0;">
          <div style="text-align: center; margin-bottom: 15px;">
            <p style="font-size: 28px; color: #dc2626; margin: 0;"><strong>${option2Price}/month</strong></p>
            <p style="margin: 5px 0; color: #6b7280;">Save ${currentPrice - option2Price}/month (Best Deal!)</p>
          </div>
          <div style="text-align: center;">
            <a href="https://santascertifiedletter.com/accept-downsell/${order.orderId}?price=${option2Price}" 
               style="display: inline-block; background: #dc2626; color: white; padding: 12px 30px; text-decoration: none; border-radius: 8px; font-weight: bold;">
              Choose ${option2Price}/month
            </a>
          </div>
        </div>
        
        <p style="text-align: center; margin-top: 30px; color: #6b7280; font-size: 14px;">
          <em>This special offer is only available for a limited time.</em>
        </p>
        
        <p style="color: #7c3aed;"><strong>üéÑ Keep the magic alive for ${childNames}!</strong></p>
        
        <p style="margin-top: 30px; color: #6b7280; font-size: 14px;">
          Questions? Reply to this email - we're here to help!
        </p>
      </div>
    </div>
  `;
  
  try {
    await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${resendApiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        from: "Letters From Santa <noreply@updates.santascertifiedletter.com>",
        to: [order.customerInfo.email],
        subject: `üéÅ Special Offer: Discounted Letters from Santa for ${childNames}!`,
        html: emailHtml,
      }),
    });
    console.log(`üìß Downsell offer email sent to ${order.customerInfo.email}`);
  } catch (error) {
    console.error("‚ùå Failed to send downsell offer email:", error);
  }
}

// ========== STRIPE WEBHOOK FOR AUTO-BILLING ==========

// Webhook endpoint for Stripe events (handles automatic monthly billing)
app.post("/make-server-cf244566/stripe-webhook", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 500);
  }

  try {
    const body = await c.req.text();
    const signature = c.req.header("stripe-signature");
    const webhookSecret = Deno.env.get("STRIPE_WEBHOOK_SECRET");

    if (!webhookSecret) {
      console.error("‚ùå STRIPE_WEBHOOK_SECRET not configured");
      return c.json({ error: "Webhook secret not configured" }, 400);
    }

    // Verify webhook signature
    let event;
    try {
      event = stripe.webhooks.constructEvent(body, signature!, webhookSecret);
    } catch (err) {
      console.error("‚ùå Webhook signature verification failed:", err);
      return c.json({ error: "Invalid signature" }, 400);
    }

    console.log(`üîî Stripe webhook received: ${event.type}`);

    // Handle successful subscription invoice payment (monthly billing)
    if (event.type === "invoice.payment_succeeded") {
      const invoice = event.data.object as any;
      
      // Only process subscription invoices (not one-time payments)
      if (invoice.subscription) {
        console.log(`üí≥ Processing subscription payment: ${invoice.subscription}`);
        
        // Find the order with this subscription
        const allOrderIds = (await kv.get("orders:all")) || [];
        let subscriptionOrder = null;
        
        for (const orderId of allOrderIds) {
          const order: any = await kv.get(`order:${orderId}`);
          if (order && order.subscriptionId === invoice.subscription) {
            subscriptionOrder = order;
            break;
          }
        }
        
        if (subscriptionOrder) {
          // Create a new monthly order (copy of original but for this month)
          console.log(`üì¶ [Auto-Billing Webhook] Creating fulfillment order. Subscription letters count: ${(subscriptionOrder.subscriptionLetters || []).length}`);
          console.log(`üì¶ [Auto-Billing Webhook] Subscription letters data:`, JSON.stringify(subscriptionOrder.subscriptionLetters));
          
          const newOrderId = `order_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          const currentDate = new Date().toISOString();
          
          // Generate new secure access token
          const accessToken = `oat_${Array.from(crypto.getRandomValues(new Uint8Array(32)))
            .map(b => b.toString(16).padStart(2, '0'))
            .join('')}`;
          
          const monthlyOrder = {
            ...subscriptionOrder,
            orderId: newOrderId,
            orderDate: currentDate,
            accessToken: accessToken,
            status: 'pending',
            total: 12.00, // Monthly subscription amount
            letters: subscriptionOrder.subscriptionLetters || [], // Copy subscription letter data for fulfillment
            stripePaymentId: invoice.payment_intent,
            stripeCheckoutUrl: `https://dashboard.stripe.com/${invoice.payment_intent?.startsWith('pi_test') ? 'test' : 'live'}/payments/${invoice.payment_intent}`,
            subscriptionMonthsActive: (subscriptionOrder.subscriptionMonthsActive || 0) + 1,
            activityLog: [{
              timestamp: currentDate,
              action: 'Monthly Order Created',
              details: `Automatic monthly billing processed. Amount: $12.00. Copied ${(subscriptionOrder.subscriptionLetters || []).length} letter(s) from subscription.`,
              user: 'System'
            }],
            createdAt: currentDate,
            updatedAt: currentDate
          };
          
          // Save new monthly order
          await kv.set(`order:${newOrderId}`, monthlyOrder);
          await kv.set(`token:${accessToken}`, newOrderId);
          
          // Add to orders index
          const allOrderIds = (await kv.get("orders:all")) || [];
          allOrderIds.push(newOrderId);
          await kv.set("orders:all", allOrderIds);
          
          // Update original subscription order
          subscriptionOrder.subscriptionMonthsActive = (subscriptionOrder.subscriptionMonthsActive || 0) + 1;
          subscriptionOrder.updatedAt = currentDate;
          await kv.set(`order:${subscriptionOrder.orderId}`, subscriptionOrder);
          
          console.log(`‚úÖ Created automatic monthly order: ${newOrderId}`);
          
          // Send customer notification about their monthly letter
          await sendMonthlyLetterNotification(monthlyOrder);
        }
      }
    }
    
    // Handle failed subscription invoice payment (declined charges)
    if (event.type === "invoice.payment_failed") {
      const invoice = event.data.object as any;
      
      // Only process subscription invoices
      if (invoice.subscription) {
        console.log(`‚ùå Subscription payment failed: ${invoice.subscription}`);
        
        // Find the order with this subscription
        const allOrderIds = (await kv.get("orders:all")) || [];
        let subscriptionOrder = null;
        
        for (const orderId of allOrderIds) {
          const order: any = await kv.get(`order:${orderId}`);
          if (order && order.subscriptionId === invoice.subscription) {
            subscriptionOrder = order;
            break;
          }
        }
        
        if (subscriptionOrder) {
          // Initialize retry tracking if not exists
          if (!subscriptionOrder.retryAttempts) {
            subscriptionOrder.retryAttempts = 0;
            subscriptionOrder.firstFailureDate = new Date().toISOString();
          }
          
          subscriptionOrder.retryAttempts++;
          subscriptionOrder.lastFailureDate = new Date().toISOString();
          subscriptionOrder.nextRetryDate = new Date(Date.now() + (48 * 60 * 60 * 1000)).toISOString(); // Retry in 2 days
          
          // Add to activity log
          if (!subscriptionOrder.activityLog) {
            subscriptionOrder.activityLog = [];
          }
          subscriptionOrder.activityLog.push({
            timestamp: new Date().toISOString(),
            action: 'Payment Failed',
            details: `Subscription payment declined. Attempt ${subscriptionOrder.retryAttempts}. Next retry: ${new Date(subscriptionOrder.nextRetryDate).toLocaleDateString()}`,
            user: 'System - Webhook'
          });
          
          await kv.set(`order:${subscriptionOrder.orderId}`, subscriptionOrder);
          
          console.log(`üìù Tracked failed payment for order ${subscriptionOrder.orderId} - Attempt ${subscriptionOrder.retryAttempts}`);
          
          // Schedule retry email (will be sent by cron job)
        }
      }
    }

    return c.json({ received: true });
  } catch (error: any) {
    console.error("‚ùå Error processing webhook:", error);
    return c.json({ error: "Webhook processing failed" }, 500);
  }
});

// Helper function to send monthly letter notification
async function sendMonthlyLetterNotification(order: any) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  const twilioAccountSid = Deno.env.get("TWILIO_ACCOUNT_SID");
  const twilioAuthToken = Deno.env.get("TWILIO_AUTH_TOKEN");
  const twilioPhoneNumber = Deno.env.get("TWILIO_PHONE_NUMBER");

  if (resendApiKey) {
    try {
      await fetch("https://api.resend.com/emails", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${resendApiKey}`,
        },
        body: JSON.stringify({
          from: "Santa's Workshop <noreply@updates.santascertifiedletter.com>",
          to: [order.customerInfo.email],
          subject: "üéÖ Your Monthly Letter from Santa is Coming!",
          html: `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
              <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÖ Santa's Magical Adventures</h1>
                <p style="margin: 10px 0 0 0; font-size: 18px;">Your Monthly Letter is On Its Way!</p>
              </div>
              <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                <p>Ho ho ho! ${order.customerInfo.name},</p>
                
                <p style="font-size: 18px;"><span style="font-size: 24px;">üéâ</span> Your monthly subscription has been renewed and your Santa letter is being prepared!</p>
                
                <div style="background-color: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0;">
                  <p><strong>Order:</strong> #${order.orderId.slice(-8)}</p>
                  <p><strong>Date:</strong> ${new Date(order.orderDate).toLocaleDateString()}</p>
                  <p><strong>Amount:</strong> ${order.total.toFixed(2)}</p>
                  <p><strong>Month:</strong> ${order.subscriptionMonthsActive}</p>
                </div>
                
                <p><strong>What's happening next?</strong></p>
                <ul style="line-height: 1.8;">
                  <li>‚ú® Santa is writing your personalized letter</li>
                  <li>üìù It will include updates on your good behavior and special activities</li>
                  <li>üìÆ Your letter will be mailed within the next few days</li>
                  <li>üìß You'll get tracking information once it ships</li>
                </ul>
                
                <p style="margin-top: 30px; text-align: center;">
                  <span style="font-size: 24px;">üéÑ</span> <strong>Keep up the great work!</strong> <span style="font-size: 24px;">üéÑ</span>
                </p>
              </div>
            </div>
          `,
        }),
      });
    } catch (error) {
      console.error("‚ùå Failed to send monthly notification email:", error);
    }
  }

  if (twilioAccountSid && twilioAuthToken && twilioPhoneNumber && order.customerInfo.phone) {
    try {
      const auth = btoa(`${twilioAccountSid}:${twilioAuthToken}`);
      await fetch(`https://api.twilio.com/2010-04-01/Accounts/${twilioAccountSid}/Messages.json`, {
        method: "POST",
        headers: {
          "Authorization": `Basic ${auth}`,
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: new URLSearchParams({
          To: order.customerInfo.phone,
          From: twilioPhoneNumber,
          Body: `üéÖ Ho ho ho! Your monthly Santa letter has been renewed and is being prepared. Order #${order.orderId.slice(-8)} - Month ${order.subscriptionMonthsActive}`,
        }),
      });
    } catch (error) {
      console.error("‚ùå Failed to send monthly notification SMS:", error);
    }
  }
}

// ========== PAYMENT METHOD UPDATE ENDPOINTS ==========

// Get order/subscription details for payment update (by encrypted token)
app.get("/make-server-cf244566/get-order-for-update/:token", async (c) => {
  try {
    const token = c.req.param("token");
    console.log(`üîç Looking up order for payment update with token: ${token}`);
    
    // Token could be either:
    // 1. A decline ID (starts with "decline_")
    // 2. An order access token (starts with "oat_")
    // 3. A special update token (starts with "upt_")
    
    let orderData: any = null;
    let declineData: any = null;
    
    // Try to find by decline ID
    if (token.startsWith("decline_")) {
      declineData = await kv.get(`decline:${token}`);
      if (declineData) {
        console.log(`‚úÖ Found decline record: ${token}`);
        
        // Return order details from decline data
        const packageCount = declineData.letterPackages?.length || 1;
        const totalAmount = declineData.amount || 0;
        const pricePerPackage = packageCount > 0 ? (totalAmount / packageCount) : 17.95;
        
        return c.json({
          success: true,
          order: {
            orderId: token,
            customerInfo: {
              name: declineData.customerInfo?.name || "",
              email: declineData.customerInfo?.email || "",
              phone: declineData.customerInfo?.phone || "",
              address: declineData.customerInfo?.address || "",
              city: declineData.customerInfo?.city || "",
              state: declineData.customerInfo?.state || "",
              zip: declineData.customerInfo?.zip || "",
            },
            letterPackages: declineData.letterPackages || [],
            total: totalAmount,
            packagePrice: pricePerPackage,
            monthlySubscription: declineData.monthlySubscription || false,
            subscriptionId: declineData.subscriptionId || null,
            stripeCustomerId: declineData.stripeCustomerId || null,
            lastFourCard: declineData.lastFourCard || null,
            declineReason: declineData.declineReason || "Payment failed",
          }
        });
      }
    }
    
    // Try to find by order access token
    if (token.startsWith("oat_")) {
      const allOrderIds = (await kv.get("orders:all")) || [];
      for (const orderId of allOrderIds) {
        const order: any = await kv.get(`order:${orderId}`);
        if (order && order.accessToken === token) {
          orderData = order;
          break;
        }
      }
    }
    
    // Try to find by custom update token
    if (token.startsWith("upt_")) {
      const updateTokenData = await kv.get(`update_token:${token}`);
      if (updateTokenData) {
        const orderId = (updateTokenData as any).orderId;
        orderData = await kv.get(`order:${orderId}`);
      }
    }
    
    if (!orderData) {
      console.log(`‚ùå Order not found for token: ${token}`);
      return c.json({ error: "Order not found or link expired" }, 404);
    }
    
    console.log(`‚úÖ Found order: ${orderData.orderId}`);
    
    // Return sanitized order details
    const packageCount = orderData.letterPackages?.length || 1;
    const totalAmount = orderData.subscriptionPrice || orderData.total || 0;
    const pricePerPackage = packageCount > 0 ? (totalAmount / packageCount) : 17.95;
    
    return c.json({
      success: true,
      order: {
        orderId: orderData.orderId,
        customerInfo: {
          name: orderData.customerInfo?.name || "",
          email: orderData.customerInfo?.email || "",
          phone: orderData.customerInfo?.phone || "",
          address: orderData.customerInfo?.address || "",
          city: orderData.customerInfo?.city || "",
          state: orderData.customerInfo?.state || "",
          zip: orderData.customerInfo?.zip || "",
        },
        letterPackages: orderData.letterPackages || [],
        total: totalAmount,
        packagePrice: pricePerPackage,
        monthlySubscription: orderData.monthlySubscription || false,
        subscriptionId: orderData.subscriptionId || null,
        stripeCustomerId: orderData.stripeCustomerId || null,
        lastFourCard: orderData.lastFourCard || null,
        nextBillingDate: orderData.subscriptionNextBillingDate || null,
      }
    });
  } catch (error: any) {
    console.error("‚ùå Error fetching order for update:", error);
    return c.json({ error: "Failed to load order details" }, 500);
  }
});

// Update payment method and charge
app.post("/make-server-cf244566/update-payment-method", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }
  
  try {
    const { token, paymentMethodId, updatedOrderData } = await c.req.json();
    
    console.log(`üí≥ Updating payment method for token: ${token}`);
    console.log(`üìù Updated order data received:`, updatedOrderData ? 'Yes' : 'No');
    
    // Get order/decline details
    let orderData: any = null;
    let declineData: any = null;
    let isDecline = false;
    
    // Check if it's a decline
    if (token.startsWith("decline_")) {
      declineData = await kv.get(`decline:${token}`);
      isDecline = true;
      
      if (!declineData) {
        return c.json({ error: "Decline record not found" }, 404);
      }
      
      // Find associated order if exists
      const allOrderIds = (await kv.get("orders:all")) || [];
      for (const orderId of allOrderIds) {
        const order: any = await kv.get(`order:${orderId}`);
        if (order && order.customerInfo?.email === declineData.customerInfo?.email && 
            order.subscriptionId === declineData.subscriptionId) {
          orderData = order;
          break;
        }
      }
    } else {
      // Get order by token
      if (token.startsWith("oat_")) {
        const allOrderIds = (await kv.get("orders:all")) || [];
        for (const orderId of allOrderIds) {
          const order: any = await kv.get(`order:${orderId}`);
          if (order && order.accessToken === token) {
            orderData = order;
            break;
          }
        }
      } else if (token.startsWith("upt_")) {
        const updateTokenData = await kv.get(`update_token:${token}`);
        if (updateTokenData) {
          const orderId = (updateTokenData as any).orderId;
          orderData = await kv.get(`order:${orderId}`);
        }
      }
      
      if (!orderData) {
        return c.json({ error: "Order not found" }, 404);
      }
    }
    
    // Apply updates to order/decline data if provided
    if (updatedOrderData) {
      console.log(`üìù Applying order updates...`);
      
      if (updatedOrderData.letterPackages) {
        if (orderData) {
          orderData.letterPackages = updatedOrderData.letterPackages;
          // Use provided total or keep existing price per package calculation
          if (updatedOrderData.total) {
            orderData.total = updatedOrderData.total;
            orderData.subscriptionPrice = updatedOrderData.total;
          }
        }
        if (declineData) {
          declineData.letterPackages = updatedOrderData.letterPackages;
          if (updatedOrderData.total) {
            declineData.amount = updatedOrderData.total;
          }
        }
      }
      
      if (updatedOrderData.customerInfo) {
        if (orderData) {
          orderData.customerInfo = { ...orderData.customerInfo, ...updatedOrderData.customerInfo };
        }
        if (declineData) {
          declineData.customerInfo = { ...declineData.customerInfo, ...updatedOrderData.customerInfo };
        }
      }
      
      // Save updated data
      if (orderData) {
        await kv.set(`order:${orderData.orderId}`, orderData);
        console.log(`‚úÖ Updated order data saved with total: ${orderData.total}`);
      }
      if (declineData && isDecline) {
        await kv.set(`decline:${token}`, declineData);
        console.log(`‚úÖ Updated decline data saved with amount: ${declineData.amount}`);
      }
    }
    
    // Get customer ID
    let customerId = orderData?.stripeCustomerId || declineData?.stripeCustomerId;
    const customerEmail = orderData?.customerInfo?.email || declineData?.customerInfo?.email;
    const customerName = orderData?.customerInfo?.name || declineData?.customerInfo?.name;
    
    // If no customer exists, create one
    if (!customerId) {
      console.log(`üÜï Creating new Stripe customer for: ${customerEmail}`);
      const customer = await stripe.customers.create({
        email: customerEmail,
        name: customerName,
        payment_method: paymentMethodId,
        invoice_settings: {
          default_payment_method: paymentMethodId,
        },
      });
      customerId = customer.id;
      
      // Update order with customer ID
      if (orderData) {
        orderData.stripeCustomerId = customerId;
        await kv.set(`order:${orderData.orderId}`, orderData);
      }
    } else {
      // Attach payment method to existing customer
      console.log(`üîó Attaching payment method to customer: ${customerId}`);
      await stripe.paymentMethods.attach(paymentMethodId, {
        customer: customerId,
      });
      
      // Set as default payment method
      await stripe.customers.update(customerId, {
        invoice_settings: {
          default_payment_method: paymentMethodId,
        },
      });
    }
    
    // Get payment method details for last 4
    const paymentMethod = await stripe.paymentMethods.retrieve(paymentMethodId);
    const lastFourCard = paymentMethod.card?.last4 || null;
    
    // Determine amount to charge
    const amount = isDecline ? (declineData.amount || 12) : (orderData.subscriptionPrice || orderData.total || 12);
    
    console.log(`üí∞ Creating payment intent for ${amount}`);
    
    // Create payment intent
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(amount * 100),
      currency: "usd",
      customer: customerId,
      payment_method: paymentMethodId,
      off_session: false,
      confirm: true,
      description: isDecline ? 
        `Recovery payment for declined order` : 
        `Subscription payment - Payment method update`,
      metadata: {
        orderId: orderData?.orderId || token,
        paymentUpdate: "true",
        declineId: isDecline ? token : undefined,
      },
      return_url: `https://santascertifiedletter.com/?page=updatepayment&token=${token}`,
    });
    
    // Check if requires additional action
    if (paymentIntent.status === "requires_action" && paymentIntent.client_secret) {
      console.log(`‚ö†Ô∏è Payment requires additional authentication`);
      return c.json({
        success: false,
        requiresAction: true,
        clientSecret: paymentIntent.client_secret,
        paymentIntentId: paymentIntent.id,
      });
    }
    
    // If payment succeeded immediately
    if (paymentIntent.status === "succeeded") {
      console.log(`‚úÖ Payment succeeded immediately`);
      
      // Create new order or update existing
      const newOrderId = await createOrderFromPaymentUpdate(
        orderData,
        declineData,
        paymentIntent,
        customerId,
        lastFourCard,
        amount
      );
      
      // Update decline record if applicable
      if (isDecline && declineData) {
        declineData.status = "converted";
        declineData.convertedDate = new Date().toISOString();
        declineData.convertedOrderId = newOrderId;
        await kv.set(`decline:${token}`, declineData);
      }
      
      // Update order if applicable
      if (orderData) {
        orderData.lastFourCard = lastFourCard;
        orderData.updatedAt = new Date().toISOString();
        
        // Reset retry counters
        orderData.retryAttempts = 0;
        orderData.firstFailureDate = null;
        orderData.lastFailureDate = null;
        orderData.nextRetryDate = null;
        
        if (!orderData.activityLog) orderData.activityLog = [];
        orderData.activityLog.push({
          timestamp: new Date().toISOString(),
          action: "Payment Method Updated",
          details: `Customer updated payment method. New card: ****${lastFourCard}. Charged ${amount.toFixed(2)}`,
          user: "Customer"
        });
        
        await kv.set(`order:${orderData.orderId}`, orderData);
      }
      
      // Send payment method update confirmation email
      try {
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        const emailTo = customerEmail || orderData?.customerInfo?.email;
        
        if (resendApiKey && emailTo) {
          const emailHtml = `
            <!DOCTYPE html>
            <html>
            <head>
              <meta charset="utf-8">
              <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
            </head>
            <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
              <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                  <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">‚úÖ Payment Method Updated!</h1>
                </div>
                <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                  <p>Hi ${customerName || 'there'},</p>
                  
                  <p style="font-size: 18px; color: #059669;"><strong>‚úÖ Your payment method has been successfully updated!</strong></p>
                  
                  <div style="background: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #16a34a;">
                    <p style="margin: 0 0 10px 0;"><strong>üí≥ New Payment Method:</strong></p>
                    <p style="font-size: 18px; margin: 0; color: #16a34a;">Card ending in ****${lastFourCard}</p>
                    <p style="margin: 10px 0 0 0; font-size: 14px; color: #166534;">
                      Amount charged: ${amount.toFixed(2)}
                    </p>
                  </div>
                  
                  ${orderData?.monthlySubscription || declineData?.subscriptionId ? `
                    <div style="background: #dbeafe; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #3b82f6;">
                      <p style="margin: 0 0 10px 0;"><strong>üéÖ Subscription Active</strong></p>
                      <p style="margin: 5px 0; font-size: 14px;">Your monthly subscription is now active and will be charged to your new payment method.</p>
                      ${orderData?.subscriptionNextBillingDate ? `
                        <p style="margin: 10px 0 0 0; font-size: 13px; color: #1e40af;">
                          Next billing date: ${new Date(orderData.subscriptionNextBillingDate).toLocaleDateString()}
                        </p>
                      ` : ''}
                    </div>
                  ` : ''}
                  
                  <div style="background: #f9fafb; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <p style="margin: 0 0 10px 0;"><strong>üìã What This Means:</strong></p>
                    <ul style="margin: 10px 0; padding-left: 20px; font-size: 14px;">
                      <li>Your new card is now saved and set as default</li>
                      <li>All future charges will use this payment method</li>
                      <li>You're all set - no further action needed!</li>
                    </ul>
                  </div>
                  
                  <div style="background: #fef2f2; padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #dc2626;">
                    <p style="margin: 0; font-size: 13px;">
                      <strong>üîí Security:</strong> For your protection, we never store your full card number. Only the last 4 digits are kept for reference.
                    </p>
                  </div>
                  
                  <p style="margin-top: 30px;">Thank you for keeping your payment information up to date!</p>
                  
                  <p style="margin-top: 20px;">Questions? Contact us at support@letterfromsanta.com</p>
                  
                  <p style="margin-top: 30px;">Merry Christmas! ‚ú®<br>The Santa Letters Team</p>
                </div>
                <div style="background: #f9fafb; padding: 20px; text-align: center; color: #6b7280; font-size: 14px; border-radius: 0 0 10px 10px;">
                  <p style="margin: 0;">¬© ${new Date().getFullYear()} Letter From Santa. All rights reserved.</p>
                </div>
              </div>
            </body>
            </html>
          `;

          const response = await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${resendApiKey}`,
            },
            body: JSON.stringify({
              from: "Santa's Workshop <noreply@letterfromsanta.com>",
              to: [emailTo],
              subject: "‚úÖ Payment Method Updated Successfully",
              html: emailHtml,
            }),
          });

          if (response.ok) {
            console.log("‚úÖ Payment method update email sent to:", emailTo);
          } else {
            const errorText = await response.text();
            console.error("‚ùå Failed to send payment update email:", errorText);
          }
        }
      } catch (emailError) {
        console.error("‚ùå Error sending payment method update email:", emailError);
      }
      
      return c.json({
        success: true,
        orderId: newOrderId,
        message: "Payment method updated and charged successfully"
      });
    }
    
    // If payment failed
    if (paymentIntent.status === "requires_payment_method" || paymentIntent.status === "canceled") {
      console.log(`‚ùå Payment failed: ${paymentIntent.status}`);
      
      // Get detailed error message
      const errorMessage = paymentIntent.last_payment_error?.message || 
                          paymentIntent.last_payment_error?.decline_code || 
                          "Your payment was declined. Please try a different card.";
      
      const declineCode = paymentIntent.last_payment_error?.decline_code;
      
      console.log(`‚ùå Decline reason: ${errorMessage}`);
      console.log(`‚ùå Decline code: ${declineCode}`);
      
      return c.json({
        success: false,
        error: errorMessage,
        declineCode: declineCode,
        paymentIntentId: paymentIntent.id
      }, 402);
    }
    
    // If payment is still processing
    return c.json({
      success: false,
      error: "Payment is processing. Please wait...",
      paymentIntentId: paymentIntent.id
    }, 202);
    
  } catch (error: any) {
    console.error("‚ùå Error updating payment method:", error);
    return c.json({ 
      error: error.message || "Failed to update payment method",
      details: error.raw?.message 
    }, 500);
  }
});

// Confirm payment after 3D Secure
app.post("/make-server-cf244566/confirm-payment-update", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }
  
  try {
    const { token, paymentIntentId } = await c.req.json();
    
    console.log(`‚úÖ Confirming payment update: ${paymentIntentId}`);
    
    // Retrieve payment intent
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
    
    if (paymentIntent.status !== "succeeded") {
      return c.json({ error: "Payment not completed" }, 400);
    }
    
    // Get order/decline details
    let orderData: any = null;
    let declineData: any = null;
    let isDecline = false;
    
    if (token.startsWith("decline_")) {
      declineData = await kv.get(`decline:${token}`);
      isDecline = true;
    } else {
      const allOrderIds = (await kv.get("orders:all")) || [];
      for (const orderId of allOrderIds) {
        const order: any = await kv.get(`order:${orderId}`);
        if (order && order.accessToken === token) {
          orderData = order;
          break;
        }
      }
    }
    
    // Get payment method details
    const paymentMethod = await stripe.paymentMethods.retrieve(paymentIntent.payment_method as string);
    const lastFourCard = paymentMethod.card?.last4 || null;
    const customerId = paymentIntent.customer as string;
    const amount = paymentIntent.amount / 100;
    
    // Create order
    const newOrderId = await createOrderFromPaymentUpdate(
      orderData,
      declineData,
      paymentIntent,
      customerId,
      lastFourCard,
      amount
    );
    
    // Update records
    if (isDecline && declineData) {
      declineData.status = "converted";
      declineData.convertedDate = new Date().toISOString();
      declineData.convertedOrderId = newOrderId;
      await kv.set(`decline:${token}`, declineData);
    }
    
    if (orderData) {
      orderData.lastFourCard = lastFourCard;
      orderData.updatedAt = new Date().toISOString();
      orderData.retryAttempts = 0;
      orderData.firstFailureDate = null;
      orderData.lastFailureDate = null;
      orderData.nextRetryDate = null;
      
      if (!orderData.activityLog) orderData.activityLog = [];
      orderData.activityLog.push({
        timestamp: new Date().toISOString(),
        action: "Payment Method Updated",
        details: `Customer updated payment method after 3DS. New card: ****${lastFourCard}. Charged ${amount.toFixed(2)}`,
        user: "Customer"
      });
      
      await kv.set(`order:${orderData.orderId}`, orderData);
    }
    
    return c.json({
      success: true,
      orderId: newOrderId,
      message: "Payment confirmed and order created"
    });
    
  } catch (error: any) {
    console.error("‚ùå Error confirming payment update:", error);
    return c.json({ error: error.message || "Failed to confirm payment" }, 500);
  }
});

// Helper function to create order from payment update
async function createOrderFromPaymentUpdate(
  existingOrder: any,
  declineData: any,
  paymentIntent: any,
  customerId: string,
  lastFourCard: string | null,
  amount: number
): Promise<string> {
  const orderId = `order_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const orderDate = new Date().toISOString();
  
  // Generate access token
  const accessToken = `oat_${Array.from(crypto.getRandomValues(new Uint8Array(32)))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('')}`;
  
  // Use existing order data or decline data
  const sourceData = existingOrder || declineData;
  
  const orderData = {
    orderId,
    orderDate,
    accessToken,
    stripePaymentId: paymentIntent.id,
    stripeCheckoutUrl: `https://dashboard.stripe.com/${paymentIntent.id.startsWith('pi_test') ? 'test' : 'live'}/payments/${paymentIntent.id}`,
    status: "unfulfilled",
    total: amount,
    customerInfo: sourceData.customerInfo,
    letterPackages: sourceData.letterPackages || [],
    numberOfPackages: sourceData.letterPackages?.length || 0,
    shippingDate: sourceData.shippingDate || "",
    monthlySubscription: sourceData.monthlySubscription || false,
    subscriptionId: sourceData.subscriptionId || null,
    stripeCustomerId: customerId,
    subscriptionMonthsActive: existingOrder ? (existingOrder.subscriptionMonthsActive || 0) + 1 : 0,
    subscriptionStartDate: existingOrder?.subscriptionStartDate || orderDate,
    subscriptionNextBillingDate: existingOrder ? calculateNextBillingDate(existingOrder.billingIntervalDays || 30) : undefined,
    billingIntervalDays: existingOrder?.billingIntervalDays || 30,
    affiliateId: existingOrder?.affiliateId || null,
    affiliateName: existingOrder?.affiliateName || null,
    affiliateCommission: existingOrder?.affiliateId ? amount * 0.10 : null,
    lastFourCard: lastFourCard,
    trafficSource: existingOrder?.trafficSource || "direct",
    parentOrderId: existingOrder?.orderId || null,
    activityLog: [{
      timestamp: orderDate,
      action: "Order Created",
      details: `Payment method updated and charged ${amount.toFixed(2)}`,
      user: "Customer"
    }],
    archived: false,
    createdAt: orderDate,
    updatedAt: orderDate
  };
  
  await kv.set(`order:${orderId}`, orderData);
  
  // Add to orders list
  const allOrderIds = (await kv.get("orders:all")) || [];
  allOrderIds.push(orderId);
  await kv.set("orders:all", allOrderIds);
  
  // Send confirmation email
  await sendPaymentUpdateConfirmationEmail(orderData);
  
  console.log(`‚úÖ Created order from payment update: ${orderId}`);
  
  return orderId;
}

// Helper to calculate next billing date
function calculateNextBillingDate(intervalDays: number): string {
  const nextDate = new Date();
  nextDate.setDate(nextDate.getDate() + intervalDays);
  return nextDate.toISOString();
}

// Helper to send payment update confirmation email
async function sendPaymentUpdateConfirmationEmail(order: any) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  if (!resendApiKey) return;
  
  const emailHtml = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
    </head>
    <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
      <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
          <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÖ Payment Updated Successfully!</h1>
        </div>
        <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
          <p>Hi ${order.customerInfo.name},</p>
          
          <p style="font-size: 18px; color: #059669;"><strong>‚úÖ Your payment method has been updated and your order is being processed!</strong></p>
          
          <div style="background: #f0fdf4; border-left: 4px solid #059669; padding: 15px; margin: 20px 0;">
            <p style="margin: 0; font-size: 16px;"><strong>Order Details:</strong></p>
            <p style="margin: 5px 0 0 0;">Order #${order.orderId.slice(-8)}</p>
            <p style="margin: 5px 0 0 0;">Amount: ${order.total.toFixed(2)}</p>
          </div>
          
          <p><strong>Your letter packages:</strong></p>
          <ul style="background: #f3f4f6; padding: 20px; border-radius: 8px;">
            ${order.letterPackages.map((pkg: any) => `
              <li style="margin: 10px 0;">
                Letter for <strong>${pkg.childFirstName} ${pkg.childLastName}</strong>
              </li>
            `).join('')}
          </ul>
          
          ${order.monthlySubscription ? `
            <div style="background: #dbeafe; border-left: 4px solid #3b82f6; padding: 15px; margin: 20px 0;">
              <p style="margin: 0; font-size: 16px;"><strong>üìÖ Monthly Subscription Active</strong></p>
              <p style="margin: 5px 0 0 0;">You'll continue receiving magical letters monthly.</p>
            </div>
          ` : ''}
          
          <p style="margin-top: 30px; color: #6b7280; font-size: 14px;">
            Your letters are being prepared and will ship soon. We'll send you tracking information shortly!
          </p>
        </div>
        <div style="background: #f9fafb; padding: 20px; text-align: center; color: #6b7280; font-size: 12px; border-radius: 0 0 10px 10px;">
          <p>Questions? Contact us at support@santascertifiedletter.com</p>
          <p style="margin-top: 10px; color: #9ca3af;">¬© 2025 Letters From Santa. All rights reserved.</p>
        </div>
      </div>
    </body>
    </html>
  `;
  
  try {
    await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${resendApiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        from: EMAIL_FROM,
        to: [order.customerInfo.email],
        subject: "üéÖ Payment Updated - Your Santa Letters Are On The Way!",
        html: emailHtml,
      }),
    });
    console.log(`üìß Payment update confirmation email sent to ${order.customerInfo.email}`);
  } catch (error) {
    console.error("‚ùå Failed to send payment update email:", error);
  }
}

// ============================================
// UPSELL FUNNEL ROUTES
// ============================================

// Get active upsells for admin
app.get("/make-server-cf244566/admin/upsells", async (c) => {
  try {
    const allUpsellIds = (await kv.get("upsells:all")) || [];
    const upsells = [];
    
    // If no upsells exist, create the default products
    if (allUpsellIds.length === 0) {
      const defaultSnowUpsell = {
        id: "upsell_north_pole_snow",
        name: "Certified North Pole Snow",
        description: "Authentic snow from the North Pole! Our premium certified snow powder expands up to 100x its size when water is added. Direct from Santa's workshop - perfect for Christmas decorations, crafts, and creating memorable Santa experiences!",
        price: 9.99,
        imageUrl: "figma:asset/17a13766bc697fc8dd73632f6223611df59e7213.png",
        active: true,
        promoText: "üéÑ SPECIAL OFFER: Add authentic North Pole snow to your Santa experience!",
        features: [
          "Certified authentic from the North Pole",
          "Expands up to 100x its original size",
          "Looks and feels like real snow",
          "Safe, non-toxic, and reusable",
          "Perfect for Christmas decorations and photos",
          "Makes approximately 2 gallons of snow"
        ],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
      
      const subscriptionUpsell = {
        id: "upsell_magical_journey",
        name: "Santa's Magical Journey",
        description: "Join Santa's Magical Journey and receive a personalized letter every month! Watch your child's excitement grow as Santa shares his adventures from around the world.",
        price: 12.00,
        imageUrl: "",
        active: true,
        isSubscription: true,
        promoText: "üéÖ SPECIAL OFFER: Continue the magic all year long!",
        features: [
          "FREE: Welcome package with your first letter",
          "Monthly personalized letters from Santa",
          "Santa shares his travels from around the world",
          "Unique stories and adventures each month",
          "Customized for each child by name",
          "Cancel anytime - no commitments!"
        ],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
      
      await kv.set(`upsell:${defaultSnowUpsell.id}`, defaultSnowUpsell);
      await kv.set(`upsell:${subscriptionUpsell.id}`, subscriptionUpsell);
      await kv.set("upsells:all", [defaultSnowUpsell.id, subscriptionUpsell.id]);
      
      console.log("‚úÖ Created default upsells: North Pole Snow + Santa's Magical Journey");
      
      return c.json({ success: true, upsells: [defaultSnowUpsell, subscriptionUpsell] });
    }
    
    for (const id of allUpsellIds) {
      const upsell = await kv.get(`upsell:${id}`);
      if (upsell) {
        upsells.push(upsell);
      }
    }
    
    return c.json({ success: true, upsells });
  } catch (error: any) {
    console.error("‚ùå Error fetching upsells:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Create or update upsell product
app.post("/make-server-cf244566/admin/upsell/save", async (c) => {
  try {
    const upsellData = await c.req.json();
    
    const allUpsellIds = (await kv.get("upsells:all")) || [];
    
    if (!upsellData.id) {
      // Create new upsell with generated ID
      upsellData.id = `upsell_${Date.now()}`;
      upsellData.createdAt = new Date().toISOString();
      allUpsellIds.push(upsellData.id);
      await kv.set("upsells:all", allUpsellIds);
    } else {
      // Check if this ID already exists in the list
      if (!allUpsellIds.includes(upsellData.id)) {
        // Add to the list if it's a new ID
        allUpsellIds.push(upsellData.id);
        await kv.set("upsells:all", allUpsellIds);
      }
      // Preserve createdAt if updating existing upsell
      const existingUpsell = await kv.get(`upsell:${upsellData.id}`);
      if (existingUpsell && (existingUpsell as any).createdAt) {
        upsellData.createdAt = (existingUpsell as any).createdAt;
      } else {
        upsellData.createdAt = new Date().toISOString();
      }
    }
    
    upsellData.updatedAt = new Date().toISOString();
    
    await kv.set(`upsell:${upsellData.id}`, upsellData);
    
    console.log(`‚úÖ Upsell saved: ${upsellData.id}`, upsellData);
    
    return c.json({ success: true, upsell: upsellData });
  } catch (error: any) {
    console.error("‚ùå Error saving upsell:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Delete upsell
app.delete("/make-server-cf244566/admin/upsell/:id", async (c) => {
  try {
    const id = c.req.param("id");
    
    await kv.del(`upsell:${id}`);
    
    const allUpsellIds = (await kv.get("upsells:all")) || [];
    const updatedIds = allUpsellIds.filter((uid: string) => uid !== id);
    await kv.set("upsells:all", updatedIds);
    
    console.log(`‚úÖ Upsell deleted: ${id}`);
    
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error deleting upsell:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Get next upsell offer for customer
app.get("/make-server-cf244566/upsell/get-offer/:token", async (c) => {
  try {
    const token = c.req.param("token");
    
    // Get order by access token
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === token) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    // Get all active upsells
    const allUpsellIds = (await kv.get("upsells:all")) || [];
    const activeUpsells = [];
    
    for (const id of allUpsellIds) {
      const upsell: any = await kv.get(`upsell:${id}`);
      if (upsell && upsell.active) {
        activeUpsells.push(upsell);
      }
    }
    
    // Sort upsells: non-subscriptions first, subscriptions last
    activeUpsells.sort((a, b) => {
      if (a.isSubscription && !b.isSubscription) return 1;
      if (!a.isSubscription && b.isSubscription) return -1;
      return 0;
    });
    
    if (activeUpsells.length === 0) {
      return c.json({ noMoreUpsells: true });
    }
    
    // Initialize upsell tracking if not exists
    if (!order.upsellsOffered) {
      order.upsellsOffered = [];
      order.upsellsAccepted = [];
      order.upsellDeclineAttempts = {}; // Track decline attempts per upsell
    }
    if (!order.upsellDeclineAttempts) {
      order.upsellDeclineAttempts = {};
    }
    
    // Find next upsell that hasn't been fully declined (max 2 attempts)
    let nextUpsell = null;
    let currentPrice = null;
    let attemptNumber = 1;
    
    for (const upsell of activeUpsells) {
      const attempts = order.upsellDeclineAttempts[upsell.id] || 0;
      
      // If already accepted or declined 2 times, skip
      if (order.upsellsAccepted?.some((a: any) => a.upsellId === upsell.id)) {
        continue;
      }
      if (attempts >= 2) {
        continue;
      }
      
      // Special handling for subscription upsell
      if (upsell.isSubscription) {
        // Skip if customer already has an active subscription (they checked the box on checkout)
        if (order.monthlySubscription && order.subscriptionId) {
          console.log(`‚è≠Ô∏è Skipping subscription upsell - customer already subscribed on checkout`);
          continue;
        }
      }
      
      nextUpsell = upsell;
      attemptNumber = attempts + 1;
      
      // Calculate downsell pricing based on product type
      if (upsell.isSubscription) {
        // Santa's Magical Journey: $12 -> $10 (ONLY 2 attempts)
        if (attemptNumber === 1) {
          currentPrice = upsell.price; // $12
        } else {
          currentPrice = 10.00; // Final downsell
        }
      } else {
        // Regular products (North Pole Snow): $9.99 -> $7.99 (ONLY 2 attempts)
        if (attemptNumber === 1) {
          currentPrice = upsell.price; // Original price
        } else {
          currentPrice = 7.99; // Final downsell
        }
      }
      
      break;
    }
    
    if (!nextUpsell) {
      return c.json({ noMoreUpsells: true });
    }
    
    // Mark as offered if first attempt
    if (attemptNumber === 1 && !order.upsellsOffered.includes(nextUpsell.id)) {
      order.upsellsOffered.push(nextUpsell.id);
    }
    
    await kv.set(`order:${order.orderId}`, order);
    
    // Suggested quantity: for subscriptions default to 1, for products match letter packages
    const suggestedQuantity = nextUpsell.isSubscription ? 1 : (order.letterPackages?.length || 1);
    
    console.log(`üì¶ Offering upsell ${nextUpsell.id} to order ${order.orderId} (Attempt ${attemptNumber}, Price: ${currentPrice})`);
    
    return c.json({
      success: true,
      upsell: {
        ...nextUpsell,
        price: currentPrice // Override with downsell price
      },
      suggestedQuantity,
      attemptNumber,
      isDownsell: attemptNumber > 1
    });
  } catch (error: any) {
    console.error("‚ùå Error getting upsell offer:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Accept upsell and charge customer
app.post("/make-server-cf244566/upsell/accept", async (c) => {
  try {
    const { orderToken, upsellId, quantity, source = "upsell_funnel" } = await c.req.json();
    
    if (!orderToken || !upsellId || !quantity || quantity < 1) {
      return c.json({ error: "Invalid request" }, 400);
    }
    
    // Get order
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === orderToken) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    // Get upsell product
    const upsell: any = await kv.get(`upsell:${upsellId}`);
    if (!upsell) {
      return c.json({ error: "Upsell product not found" }, 404);
    }
    
    // Get the actual price (may be downsell price)
    const attempts = order.upsellDeclineAttempts?.[upsellId] || 0;
    let actualPrice = upsell.price;
    
    if (upsell.isSubscription) {
      if (attempts === 1) actualPrice = 10.00;
    } else {
      if (attempts === 1) actualPrice = 7.99;
    }
    
    const totalAmount = actualPrice * quantity;
    
    console.log(`üí≥ Processing upsell: ${totalAmount.toFixed(2)} for ${quantity}x ${upsell.name} (${upsell.isSubscription ? 'Subscription' : 'One-time'})`);
    
    // Initialize Stripe
    const stripe = Stripe(Deno.env.get("STRIPE_SECRET_KEY") || "", {
      apiVersion: "2023-10-16",
    });
    
    if (!order.stripeCustomerId) {
      return c.json({ error: "No customer on file" }, 400);
    }
    
    // If no payment method stored, try to get it from Stripe customer
    if (!order.stripePaymentMethodId) {
      console.log("‚ö†Ô∏è No payment method stored, retrieving from Stripe customer...");
      try {
        const customer: any = await stripe.customers.retrieve(order.stripeCustomerId);
        const defaultPaymentMethod = customer.invoice_settings?.default_payment_method || customer.default_source;
        
        if (!defaultPaymentMethod) {
          // Try to get the first attached payment method
          const paymentMethods = await stripe.paymentMethods.list({
            customer: order.stripeCustomerId,
            type: 'card',
            limit: 1
          });
          
          if (paymentMethods.data.length > 0) {
            order.stripePaymentMethodId = paymentMethods.data[0].id;
            console.log("‚úÖ Found payment method from customer:", order.stripePaymentMethodId);
            // Save it back to order for future use
            await kv.set(`order:${order.orderId}`, order);
          } else {
            return c.json({ error: "No payment method on file" }, 400);
          }
        } else {
          order.stripePaymentMethodId = defaultPaymentMethod as string;
          console.log("‚úÖ Retrieved default payment method:", order.stripePaymentMethodId);
          // Save it back to order for future use
          await kv.set(`order:${order.orderId}`, order);
        }
      } catch (error: any) {
        console.error("‚ùå Error retrieving payment method:", error);
        return c.json({ error: "Unable to retrieve payment method" }, 400);
      }
    }
    
    let paymentIntent: any = null;
    let subscriptionId = null;
    
    if (upsell.isSubscription) {
      // Create subscription for Santa's Magical Journey
      console.log(`üìÖ Creating subscription at ${actualPrice}/month for ${quantity} kid(s)`);
      
      // First, create or get the product
      let product;
      try {
        // Try to retrieve existing product by metadata
        const products = await stripe.products.search({
          query: `metadata['upsell_id']:'${upsell.id}'`,
          limit: 1
        });
        
        if (products.data.length > 0) {
          product = products.data[0];
          console.log(`‚úÖ Using existing product: ${product.id}`);
        } else {
          // Create new product
          product = await stripe.products.create({
            name: `${upsell.name} - Monthly Letters`,
            description: `Personalized monthly letters from Santa`,
            metadata: {
              upsell_id: upsell.id,
              type: 'subscription'
            }
          });
          console.log(`‚úÖ Created new product: ${product.id}`);
        }
      } catch (productError: any) {
        console.error('Error with product:', productError);
        // Fallback: create product without search
        product = await stripe.products.create({
          name: `${upsell.name} - Monthly Letters`,
          description: `Personalized monthly letters from Santa`,
          metadata: {
            upsell_id: upsell.id,
            type: 'subscription'
          }
        });
      }
      
      // Create a price for this product
      const price = await stripe.prices.create({
        product: product.id,
        unit_amount: Math.round(actualPrice * 100),
        currency: 'usd',
        recurring: {
          interval: 'month',
        },
      });
      
      const subscription = await stripe.subscriptions.create({
        customer: order.stripeCustomerId,
        items: [{
          price: price.id,
          quantity: quantity,
        }],
        payment_behavior: 'default_incomplete',
        payment_settings: { 
          save_default_payment_method: 'on_subscription',
          payment_method_types: ['card']
        },
        expand: ['latest_invoice.payment_intent'],
        metadata: {
          orderId: order.orderId,
          packageType: 'magical_journey',
          numberOfKids: quantity.toString(),
          pricePerKid: actualPrice.toString()
        }
      });
      
      subscriptionId = subscription.id;
      
      // Confirm the payment
      const invoice: any = subscription.latest_invoice;
      paymentIntent = invoice.payment_intent;
      
      if (paymentIntent.status === 'requires_payment_method' || paymentIntent.status === 'requires_confirmation') {
        const confirmed = await stripe.paymentIntents.confirm(paymentIntent.id, {
          payment_method: order.stripePaymentMethodId
        });
        paymentIntent = confirmed;
      }
      
      if (paymentIntent.status !== 'succeeded') {
        console.error(`‚ùå Subscription payment failed: ${paymentIntent.status}`);
        // Cancel the subscription
        await stripe.subscriptions.cancel(subscriptionId);
        return c.json({ 
          error: "Payment was declined. Please contact support.",
          declineCode: paymentIntent.last_payment_error?.code
        }, 402);
      }
      
      // Update order with subscription info
      order.subscription = {
        subscriptionId: subscription.id,
        status: subscription.status,
        currentPeriodEnd: new Date(subscription.current_period_end * 1000).toISOString(),
        pricePerMonth: actualPrice,
        numberOfKids: quantity,
        createdAt: new Date().toISOString()
      };
      
      console.log(`‚úÖ Subscription created: ${subscriptionId}`);
    } else {
      // One-time charge for regular products
      paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(totalAmount * 100),
        currency: 'usd',
        customer: order.stripeCustomerId,
        payment_method: order.stripePaymentMethodId,
        off_session: true,
        confirm: true,
        description: `Upsell: ${quantity}x ${upsell.name} - Order ${order.orderId}`,
        metadata: {
          orderId: order.orderId,
          upsellId: upsell.id,
          quantity: quantity.toString(),
          type: 'upsell'
        }
      });
      
      if (paymentIntent.status !== 'succeeded') {
        console.error(`‚ùå Upsell payment failed: ${paymentIntent.status}`);
        return c.json({ 
          error: "Payment was declined. Please contact support.",
          declineCode: paymentIntent.last_payment_error?.code
        }, 402);
      }
    }
    
    // Add upsell to order
    if (!order.upsellsAccepted) {
      order.upsellsAccepted = [];
    }
    
    order.upsellsAccepted.push({
      upsellId: upsell.id,
      name: upsell.name,
      quantity,
      price: actualPrice,
      total: totalAmount,
      chargedAt: new Date().toISOString(),
      stripePaymentIntentId: paymentIntent.id,
      isSubscription: upsell.isSubscription || false,
      subscriptionId: subscriptionId,
      source: source // Track where the upsell was accepted: "checkout", "upsell_funnel", or "success_page"
    });
    
    // Update order total
    order.total = (order.total || 0) + totalAmount;
    order.updatedAt = new Date().toISOString();
    
    // Add activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: upsell.isSubscription ? 'Subscription Upsell Accepted' : 'Upsell Accepted',
      details: upsell.isSubscription 
        ? `${quantity}x ${upsell.name} - ${actualPrice}/month subscription started - First payment: ${totalAmount.toFixed(2)}`
        : `${quantity}x ${upsell.name} - ${totalAmount.toFixed(2)} charged`,
      user: 'Customer',
      stripeUrl: subscriptionId 
        ? `https://dashboard.stripe.com/subscriptions/${subscriptionId}`
        : `https://dashboard.stripe.com/payments/${paymentIntent.id}`
    });
    
    await kv.set(`order:${order.orderId}`, order);
    
    console.log(`‚úÖ Upsell accepted and charged: ${upsellId}`);
    
    // Send upsell confirmation email
    try {
      const resendApiKey = Deno.env.get("RESEND_API_KEY");
      if (resendApiKey && order.customerInfo?.email) {
        const emailHtml = `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
          </head>
          <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÅ ${upsell.isSubscription ? 'Subscription Started!' : 'Item Added to Your Order!'}</h1>
              </div>
              <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                <p>Hi ${order.customerInfo.name || 'there'},</p>
                
                <p style="font-size: 18px; color: #059669;"><strong>‚úÖ Great choice! Your order has been updated.</strong></p>
                
                <div style="background: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #16a34a;">
                  <p style="margin: 0 0 10px 0;"><strong>Item Added:</strong></p>
                  <p style="font-size: 20px; margin: 0; color: #16a34a;"><strong>${quantity}x ${upsell.name}</strong></p>
                  ${upsell.isSubscription ? `
                    <p style="margin: 10px 0 0 0; font-size: 14px; color: #166534;">
                      üí≥ Monthly subscription at ${actualPrice.toFixed(2)}/month per child<br>
                      üìÖ First payment charged today: ${totalAmount.toFixed(2)}<br>
                      üîÑ Next billing: ${new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toLocaleDateString()}
                    </p>
                  ` : `
                    <p style="margin: 10px 0 0 0; font-size: 14px; color: #166534;">
                      üí≥ Amount charged: ${totalAmount.toFixed(2)}
                    </p>
                  `}
                </div>
                
                ${upsell.isSubscription ? `
                  <div style="background: #dbeafe; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #3b82f6;">
                    <p style="margin: 0 0 10px 0;"><strong>üéÖ Welcome to Santa's Magical Journey!</strong></p>
                    <p style="margin: 5px 0; font-size: 14px;">You're now subscribed to receive monthly personalized letters from Santa. Each month includes:</p>
                    <ul style="margin: 10px 0; padding-left: 20px; font-size: 14px;">
                      <li>A personalized letter from Santa</li>
                      <li>A postcard from his latest destination</li>
                      <li>Enchanting stories and cultural insights</li>
                      <li>Fun activities and illustrations</li>
                    </ul>
                    <p style="margin: 10px 0 0 0; font-size: 13px; color: #1e40af;">
                      You can manage or cancel your subscription anytime from your order confirmation email.
                    </p>
                  </div>
                ` : ''}
                
                <div style="background: #f9fafb; padding: 20px; border-radius: 8px; margin: 20px 0;">
                  <p style="margin: 0 0 10px 0;"><strong>üìã Order Summary:</strong></p>
                  <p style="margin: 5px 0;"><strong>Order #:</strong> ${order.orderId.slice(-8)}</p>
                  <p style="margin: 5px 0;"><strong>Updated Total:</strong> ${order.total.toFixed(2)}</p>
                </div>
                
                <p style="margin-top: 30px;">Thank you for your purchase! The magic continues... ‚ú®</p>
              </div>
              <div style="background: #f9fafb; padding: 20px; text-align: center; color: #6b7280; font-size: 14px; border-radius: 0 0 10px 10px;">
                <p>Questions? Contact us at support@letterfromsanta.com</p>
                <p style="margin: 5px 0 0 0;">¬© ${new Date().getFullYear()} Letter From Santa. All rights reserved.</p>
              </div>
            </div>
          </body>
          </html>
        `;

        const response = await fetch("https://api.resend.com/emails", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${resendApiKey}`,
          },
          body: JSON.stringify({
            from: EMAIL_FROM,
            to: [order.customerInfo.email],
            subject: upsell.isSubscription 
              ? `üéÖ Subscription Started - Santa's Magical Journey!`
              : `üéÅ Item Added to Your Order - ${upsell.name}`,
            html: emailHtml,
          }),
        });

        if (response.ok) {
          console.log("‚úÖ Upsell confirmation email sent to:", order.customerInfo.email);
        } else {
          const errorText = await response.text();
          console.error("ÔøΩÔøΩ Failed to send upsell email:", errorText);
        }
      }
    } catch (emailError) {
      console.error("‚ùå Error sending upsell confirmation email:", emailError);
    }
    
    return c.json({ 
      success: true,
      chargedAmount: totalAmount,
      paymentIntentId: paymentIntent.id,
      subscriptionId: subscriptionId,
      isSubscription: upsell.isSubscription || false
    });
  } catch (error: any) {
    console.error("‚ùå Error accepting upsell:", error);
    
    // Check if it's a Stripe error
    if (error.type === 'StripeCardError' || error.code) {
      return c.json({ 
        error: error.message || "Payment was declined",
        declineCode: error.code
      }, 402);
    }
    
    return c.json({ error: error.message }, 500);
  }
});

// Accept snow upsell (funnel - $9.99)
app.post("/make-server-cf244566/upsell/accept-snow", async (c) => {
  try {
    const { orderToken, quantity } = await c.req.json();
    
    if (!orderToken || !quantity || quantity < 1) {
      return c.json({ error: "Invalid request" }, 400);
    }
    
    // Get order
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === orderToken) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!stripe) {
      return c.json({ error: "Payment system not configured" }, 503);
    }
    
    const pricePerUnit = 9.99;
    const totalAmount = pricePerUnit * quantity;
    
    try {
      // Charge using saved payment method
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(totalAmount * 100),
        currency: 'usd',
        customer: order.stripeCustomerId,
        payment_method: order.stripePaymentMethodId,
        off_session: true,
        confirm: true,
        description: `Certified North Pole Snow (${quantity}x) - Order ${order.orderId}`,
        metadata: {
          orderId: order.orderId,
          upsellType: 'snow',
          quantity: quantity.toString(),
          price: pricePerUnit.toString(),
          source: 'funnel_upsell'
        }
      });
      
      // Add to order
      if (!order.acceptedUpsells) {
        order.acceptedUpsells = [];
      }
      
      order.acceptedUpsells.push({
        id: 'snow_upsell',
        name: 'Certified North Pole Snow',
        price: pricePerUnit,
        quantity,
        total: totalAmount,
        acceptedAt: new Date().toISOString(),
        paymentIntentId: paymentIntent.id,
        source: 'funnel_upsell'
      });
      
      order.total += totalAmount;
      order.updatedAt = new Date().toISOString();
      
      // Add activity log entry
      if (!order.activityLog) {
        order.activityLog = [];
      }
      order.activityLog.push({
        timestamp: new Date().toISOString(),
        action: 'Upsell Accepted - Certified North Pole Snow',
        details: `Certified North Pole Snow - Quantity: ${quantity}, Amount: ${totalAmount.toFixed(2)}`,
        user: 'Customer',
        stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntent.id}`
      });
      
      await kv.set(`order:${order.orderId}`, order);
      
      console.log(`‚úÖ Snow upsell accepted: Order ${order.orderId}, Quantity: ${quantity}, Amount: ${totalAmount}`);
      
      return c.json({ 
        success: true,
        chargedAmount: totalAmount,
        paymentIntentId: paymentIntent.id
      });
    } catch (error: any) {
      console.error("‚ùå Error charging for snow upsell:", error);
      
      if (error.type === 'StripeCardError' || error.code) {
        return c.json({ 
          error: error.message || "Payment was declined",
          declineCode: error.code
        }, 402);
      }
      
      throw error;
    }
  } catch (error: any) {
    console.error("‚ùå Error accepting snow upsell:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Accept snow downsell (funnel - $7.99)
app.post("/make-server-cf244566/upsell/accept-snow-downsell", async (c) => {
  try {
    const { orderToken, quantity } = await c.req.json();
    
    if (!orderToken || !quantity || quantity < 1) {
      return c.json({ error: "Invalid request" }, 400);
    }
    
    // Get order
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === orderToken) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!stripe) {
      return c.json({ error: "Payment system not configured" }, 503);
    }
    
    const pricePerUnit = 7.99;
    const totalAmount = pricePerUnit * quantity;
    
    try {
      // Charge using saved payment method
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(totalAmount * 100),
        currency: 'usd',
        customer: order.stripeCustomerId,
        payment_method: order.stripePaymentMethodId,
        off_session: true,
        confirm: true,
        description: `Certified North Pole Snow - SPECIAL DISCOUNT (${quantity}x) - Order ${order.orderId}`,
        metadata: {
          orderId: order.orderId,
          upsellType: 'snow_downsell',
          quantity: quantity.toString(),
          price: pricePerUnit.toString(),
          source: 'funnel_downsell'
        }
      });
      
      // Add to order
      if (!order.acceptedUpsells) {
        order.acceptedUpsells = [];
      }
      
      order.acceptedUpsells.push({
        id: 'snow_downsell',
        name: 'Certified North Pole Snow (Special Discount)',
        price: pricePerUnit,
        quantity,
        total: totalAmount,
        acceptedAt: new Date().toISOString(),
        paymentIntentId: paymentIntent.id,
        source: 'funnel_downsell',
        originalPrice: 9.99,
        discount: 2.00
      });
      
      order.total += totalAmount;
      order.updatedAt = new Date().toISOString();
      
      // Add activity log entry
      if (!order.activityLog) {
        order.activityLog = [];
      }
      const savings = 2.00 * quantity;
      order.activityLog.push({
        timestamp: new Date().toISOString(),
        action: 'Upsell Accepted - Snow Downsell',
        details: `Certified North Pole Snow (Special Discount) - Quantity: ${quantity}, Amount: ${totalAmount.toFixed(2)} (saved ${savings.toFixed(2)})`,
        user: 'Customer',
        stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntent.id}`
      });
      
      await kv.set(`order:${order.orderId}`, order);
      
      console.log(`‚úÖ Snow downsell accepted: Order ${order.orderId}, Quantity: ${quantity}, Amount: ${totalAmount}`);
      
      return c.json({ 
        success: true,
        chargedAmount: totalAmount,
        paymentIntentId: paymentIntent.id
      });
    } catch (error: any) {
      console.error("‚ùå Error charging for snow downsell:", error);
      
      if (error.type === 'StripeCardError' || error.code) {
        return c.json({ 
          error: error.message || "Payment was declined",
          declineCode: error.code
        }, 402);
      }
      
      throw error;
    }
  } catch (error: any) {
    console.error("‚ùå Error accepting snow downsell:", error);
    return c.json({ error: error.message }, 500);
  }
});

// OLD ROUTE - DISABLED - Duplicate route that doesn't handle subscriptions properly
// The correct route with subscription support is further down in the file (line ~11007)
/*
// Create payment intent for upsell from success page
app.post("/make-server-cf244566/order/:token/create-upsell-payment", async (c) => {
  try {
    const token = c.req.param("token");
    const { upsellId, upsellName, price, quantity } = await c.req.json();
    
    if (!token || !upsellId || !upsellName || !price || !quantity || quantity < 1) {
      return c.json({ error: "Invalid request" }, 400);
    }
    
    // Get order by token
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === token) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      console.error("‚ùå Order not found for token:", token);
      return c.json({ error: "Order not found" }, 404);
    }
    
    // AUTO-FIX: If customer ID is missing, try to retrieve or create it
    if (!order.stripeCustomerId && stripe) {
      console.log("üîß AUTO-FIXING: Missing customer ID for order:", order.orderId);
      try {
        let customerId = null;
        
        // Try to get customer from payment intent first
        if (order.stripePaymentId) {
          try {
            const paymentIntent = await stripe.paymentIntents.retrieve(order.stripePaymentId);
            if (paymentIntent.customer) {
              customerId = paymentIntent.customer as string;
              console.log("‚úÖ Found customer ID from payment intent:", customerId);
              
              // Also get payment method if available
              if (paymentIntent.payment_method && !order.stripePaymentMethodId) {
                order.stripePaymentMethodId = paymentIntent.payment_method as string;
              }
            }
          } catch (piError: any) {
            console.log("‚ö†Ô∏è Could not retrieve payment intent:", piError.message);
          }
        }
        
        // If still no customer, create a new one from order data
        if (!customerId && order.customerInfo?.email) {
          console.log("üÜï Creating new Stripe customer for order:", order.orderId);
          const customer = await stripe.customers.create({
            email: order.customerInfo.email,
            name: order.customerInfo.name || "Customer",
            phone: order.customerInfo.phone || undefined,
            address: order.customerInfo.address ? {
              line1: order.customerInfo.address.line1 || undefined,
              line2: order.customerInfo.address.line2 || undefined,
              city: order.customerInfo.address.city || undefined,
              state: order.customerInfo.address.state || undefined,
              postal_code: order.customerInfo.address.postal_code || undefined,
              country: order.customerInfo.address.country || "US"
            } : undefined,
            metadata: {
              orderId: order.orderId,
              source: "auto-fix-upsell"
            }
          });
          customerId = customer.id;
          console.log("‚úÖ Created new Stripe customer:", customerId);
        }
        
        // Save customer ID to order
        if (customerId) {
          order.stripeCustomerId = customerId;
          await kv.set(`order:${order.orderId}`, order);
          console.log("‚úÖ AUTO-FIXED: Saved customer ID to order");
        }
      } catch (error: any) {
        console.error("‚ùå Auto-fix failed:", error.message);
      }
    }
    
    console.log("üì¶ Order found for upsell payment:", {
      orderId: order.orderId,
      hasCustomerId: !!order.stripeCustomerId,
      customerId: order.stripeCustomerId ? `${order.stripeCustomerId.substring(0, 15)}...` : 'MISSING',
      hasCustomerInfo: !!order.customerInfo,
      customerEmail: order.customerInfo?.email || 'MISSING'
    });
    
    if (!stripe) {
      return c.json({ error: "Payment system not configured" }, 503);
    }
    
    // If still missing customer ID after auto-fix attempt, log but continue
    if (!order.stripeCustomerId) {
      console.error("‚ùå Order still missing customer ID after auto-fix. This shouldn't happen but continuing anyway:", order.orderId);
      // Don't return error - let Stripe handle it when creating payment intent
    }
    
    const totalAmount = price * quantity;
    
    console.log(`üí≥ Creating payment intent for customer: ${order.stripeCustomerId}`);
    
    // Create payment intent with customer
    const paymentIntentData: any = {
      amount: Math.round(totalAmount * 100),
      currency: 'usd',
      description: `${upsellName} (${quantity}x) - Order ${order.orderId}`,
      metadata: {
        orderId: order.orderId,
        upsellId: upsellId,
        upsellName: upsellName,
        quantity: quantity.toString(),
        price: price.toString(),
        type: 'upsell_from_success_page',
        customerEmail: order.customerInfo?.email || '',
        customerName: order.customerInfo?.name || ''
      }
    };
    
    // Only add customer if we have a valid ID
    if (order.stripeCustomerId && order.stripeCustomerId.trim() !== '') {
      paymentIntentData.customer = order.stripeCustomerId;
    }
    
    const paymentIntent = await stripe.paymentIntents.create(paymentIntentData);
    
    console.log(`‚úÖ Created payment intent for upsell: ${paymentIntent.id}`);
    
    return c.json({ clientSecret: paymentIntent.client_secret });
  } catch (error: any) {
    console.error("‚ùå Error creating upsell payment intent:", error);
    return c.json({ error: error.message || "Failed to create payment intent" }, 500);
  }
});

// Confirm upsell after payment success
app.post("/make-server-cf244566/order/:token/confirm-upsell", async (c) => {
  try {
    const token = c.req.param("token");
    const { paymentIntentId } = await c.req.json();
    
    if (!token || !paymentIntentId) {
      return c.json({ error: "Invalid request" }, 400);
    }
    
    // Get order by token
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === token) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!stripe) {
      return c.json({ error: "Payment system not configured" }, 503);
    }
    
    // Retrieve payment intent to get metadata
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
    
    if (paymentIntent.status !== 'succeeded') {
      return c.json({ error: "Payment not completed" }, 400);
    }
    
    const { upsellId, upsellName, quantity, price } = paymentIntent.metadata;
    const totalAmount = parseFloat(price) * parseInt(quantity);
    
    // Add upsell to order's accepted upsells
    if (!order.acceptedUpsells) {
      order.acceptedUpsells = [];
    }
    
    order.acceptedUpsells.push({
      id: upsellId,
      name: upsellName,
      price: parseFloat(price),
      quantity: parseInt(quantity),
      total: totalAmount,
      addedAt: new Date().toISOString(),
      paymentIntentId: paymentIntentId,
      source: 'success_page'
    });
    
    // Update total
    order.total = (order.total || 0) + totalAmount;
    
    // Save updated order
    await kv.set(`order:${order.orderId}`, order);
    
    console.log(`‚úÖ Upsell confirmed for order ${order.orderId}: ${upsellName} x${quantity}`);
    
    // Send confirmation email
    try {
      const resendApiKey = Deno.env.get("RESEND_API_KEY");
      if (resendApiKey) {
        await fetch("https://api.resend.com/emails", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${resendApiKey}`,
          },
          body: JSON.stringify({
            from: EMAIL_FROM,
            to: order.customerInfo.email,
            subject: `üéÅ ${upsellName} Added to Your Order!`,
            html: `
              <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                <h1 style="color: #c41e3a;">‚úÖ Purchase Confirmed!</h1>
                <p>Great news! We've successfully added the following to your order:</p>
                
                <div style="background: #f0f9ff; padding: 20px; border-radius: 8px; margin: 20px 0;">
                  <h2 style="color: #0369a1; margin-top: 0;">${upsellName}</h2>
                  <p style="font-size: 18px; margin: 10px 0;">
                    <strong>Quantity:</strong> ${quantity}<br>
                    <strong>Total:</strong> ${totalAmount.toFixed(2)}
                  </p>
                </div>
                
                <p>This item will be shipped with your Santa letter package.</p>
                
                <div style="margin-top: 30px; padding: 15px; background: #fef3c7; border-radius: 8px;">
                  <p style="margin: 0; color: #92400e;">
                    <strong>Order #${order.orderId}</strong><br>
                    Your order has been updated and will be processed together.
                  </p>
                </div>
                
                <p style="margin-top: 30px;">
                  Thank you for your purchase!<br>
                  üéÖ Santa's Workshop Team
                </p>
              </div>
            `,
          }),
        });
        console.log(`‚úÖ Upsell confirmation email sent to ${order.customerInfo.email}`);
      }
    } catch (emailError) {
      console.error("‚ùå Failed to send upsell confirmation email:", emailError);
    }
    
    return c.json({ 
      success: true, 
      upsellName,
      quantity: parseInt(quantity),
      total: totalAmount 
    });
  } catch (error: any) {
    console.error("‚ùå Error confirming upsell:", error);
    return c.json({ error: error.message || "Failed to confirm upsell" }, 500);
  }
});
*/
// END OF DISABLED OLD ROUTES

// Legacy endpoint - kept for backwards compatibility
app.post("/make-server-cf244566/order/:token/add-upsell", async (c) => {
  try {
    const token = c.req.param("token");
    const { upsellId, upsellName, price, quantity, cardDetails } = await c.req.json();
    
    if (!token || !upsellId || !upsellName || !price || !quantity || quantity < 1) {
      return c.json({ error: "Invalid request" }, 400);
    }
    
    if (!cardDetails || !cardDetails.number || !cardDetails.expMonth || !cardDetails.expYear || !cardDetails.cvc) {
      return c.json({ error: "Card details required" }, 400);
    }
    
    // Get order by token
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === token) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    if (!stripe) {
      return c.json({ error: "Payment system not configured" }, 503);
    }
    
    const totalAmount = price * quantity;
    
    // Create a payment method from card details
    const paymentMethod = await stripe.paymentMethods.create({
      type: 'card',
      card: {
        number: cardDetails.number,
        exp_month: cardDetails.expMonth,
        exp_year: cardDetails.expYear,
        cvc: cardDetails.cvc,
      },
      billing_details: {
        address: {
          postal_code: cardDetails.zip,
        },
      },
    });
    
    // Attach the payment method to the customer
    await stripe.paymentMethods.attach(paymentMethod.id, {
      customer: order.stripeCustomerId,
    });
    
    // Charge customer for the upsell using the new payment method
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(totalAmount * 100),
      currency: 'usd',
      customer: order.stripeCustomerId,
      payment_method: paymentMethod.id,
      off_session: false,
      confirm: true,
      description: `${upsellName} (${quantity}x) - Order ${order.orderId}`,
      metadata: {
        orderId: order.orderId,
        upsellId: upsellId,
        quantity: quantity.toString(),
        type: 'upsell_from_success_page'
      }
    });
    
    if (paymentIntent.status !== 'succeeded') {
      console.error(`‚ùå Payment failed: ${paymentIntent.status}`);
      return c.json({ 
        error: "Payment was declined. Please check your card.",
        declineCode: paymentIntent.last_payment_error?.code
      }, 402);
    }
    
    // Add upsell to order's accepted upsells
    if (!order.acceptedUpsells) {
      order.acceptedUpsells = [];
    }
    
    order.acceptedUpsells.push({
      name: upsellName,
      quantity: quantity,
      price: price,
      total: totalAmount
    });
    
    // Update order total
    order.total = (order.total || 0) + totalAmount;
    order.updatedAt = new Date().toISOString();
    
    // Add activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: 'Upsell Added from Success Page',
      details: `${quantity}x ${upsellName} - ${totalAmount.toFixed(2)} charged`,
      user: 'Customer',
      stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntent.id}`
    });
    
    await kv.set(`order:${order.orderId}`, order);
    
    console.log(`‚úÖ Upsell added from success page: ${upsellName} x${quantity}`);
    
    // Send confirmation email
    try {
      const resendApiKey = Deno.env.get("RESEND_API_KEY");
      if (resendApiKey && order.customerInfo?.email) {
        const emailHtml = `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
          </head>
          <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÅ Item Added!</h1>
              </div>
              <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                <p>Hi ${order.customerInfo.name || 'there'},</p>
                
                <p style="font-size: 18px; color: #059669;"><strong>‚úÖ We're adding ${upsellName} to your order!</strong></p>
                
                <div style="background: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #16a34a;">
                  <p style="margin: 0 0 10px 0;"><strong>Item Added:</strong></p>
                  <p style="font-size: 20px; margin: 0; color: #16a34a;"><strong>${quantity}x ${upsellName}</strong></p>
                  <p style="margin: 10px 0 0 0; font-size: 14px; color: #166534;">
                    üí≥ Amount charged: ${totalAmount.toFixed(2)}
                  </p>
                </div>
                
                <div style="background: #f9fafb; padding: 20px; border-radius: 8px; margin: 20px 0;">
                  <p style="margin: 0 0 10px 0;"><strong>üìã Order Summary:</strong></p>
                  <p style="margin: 5px 0;"><strong>Order #:</strong> ${order.orderId.slice(-8)}</p>
                  <p style="margin: 5px 0;"><strong>Updated Total:</strong> ${order.total.toFixed(2)}</p>
                </div>
                
                <div style="background: #dbeafe; padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #3b82f6;">
                  <p style="margin: 0; font-size: 14px; color: #1e40af;">
                    <strong>‚ú® Your ${upsellName} will be shipped with your letter package!</strong>
                  </p>
                </div>
                
                <p style="margin-top: 30px;">Thank you for your purchase! The magic continues... ‚ú®</p>
                
                <p>With Christmas cheer,<br>The Santa's Letters Team üéÑ</p>
              </div>
              <div style="background: #f9fafb; padding: 20px; text-align: center; color: #6b7280; font-size: 14px; border-radius: 0 0 10px 10px;">
                <p>Questions? Contact us at support@letterfromsanta.com</p>
                <p style="margin: 5px 0 0 0;">¬© ${new Date().getFullYear()} Letter From Santa. All rights reserved.</p>
              </div>
            </div>
          </body>
          </html>
        `;

        const response = await fetch("https://api.resend.com/emails", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${resendApiKey}`,
          },
          body: JSON.stringify({
            from: EMAIL_FROM,
            to: [order.customerInfo.email],
            subject: `üéÅ ${upsellName} Added to Your Order!`,
            html: emailHtml,
          }),
        });

        if (response.ok) {
          console.log("‚úÖ Upsell confirmation email sent to:", order.customerInfo.email);
        } else {
          const errorText = await response.text();
          console.error("‚ùå Failed to send email:", errorText);
        }
      }
    } catch (emailError) {
      console.error("‚ùå Error sending email:", emailError);
    }
    
    return c.json({ 
      success: true,
      message: `${upsellName} added to your order!`,
      order: {
        orderId: order.orderId,
        total: order.total,
        acceptedUpsells: order.acceptedUpsells
      }
    });
  } catch (error: any) {
    console.error("‚ùå Error adding upsell from success page:", error);
    return c.json({ error: error.message || "Failed to add item" }, 500);
  }
});

// Decline upsell
app.post("/make-server-cf244566/upsell/decline", async (c) => {
  try {
    const { orderToken, upsellId } = await c.req.json();
    
    // Get order
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === orderToken) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    // Track decline attempts
    if (!order.upsellDeclineAttempts) {
      order.upsellDeclineAttempts = {};
    }
    if (!order.upsellsDeclined) {
      order.upsellsDeclined = [];
    }
    
    // Increment decline attempts
    if (upsellId) {
      const currentAttempts = order.upsellDeclineAttempts[upsellId] || 0;
      order.upsellDeclineAttempts[upsellId] = currentAttempts + 1;
      
      // If declined 2 times, add to fully declined list
      if (order.upsellDeclineAttempts[upsellId] >= 2) {
        if (!order.upsellsDeclined.includes(upsellId)) {
          order.upsellsDeclined.push(upsellId);
        }
      }
    }
    
    order.updatedAt = new Date().toISOString();
    await kv.set(`order:${order.orderId}`, order);
    
    const attempts = order.upsellDeclineAttempts[upsellId] || 0;
    console.log(`üëé Upsell declined: ${upsellId} (Attempt ${attempts}/2)`);
    
    return c.json({ 
      success: true,
      shouldRetry: attempts < 2 // Tell frontend if we should show downsell
    });
  } catch (error: any) {
    console.error("‚ùå Error declining upsell:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Mark upsell flow complete and send confirmation email
app.post("/make-server-cf244566/upsell/complete", async (c) => {
  try {
    const { orderToken } = await c.req.json();
    
    // Get order
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;
    
    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === orderToken) {
        order = orderData;
        break;
      }
    }
    
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }
    
    // Mark upsell flow as complete
    order.upsellFlowCompleted = true;
    order.upsellFlowCompletedAt = new Date().toISOString();
    await kv.set(`order:${order.orderId}`, order);
    
    // Send confirmation email with upsells
    await sendOrderConfirmationWithUpsells(order);
    
    console.log(`‚úÖ Upsell flow completed for order: ${order.orderId}`);
    
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error completing upsell flow:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Helper function to send order confirmation with upsells
async function sendOrderConfirmationWithUpsells(order: any) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  if (!resendApiKey) {
    console.log("‚ö†Ô∏è No Resend API key - skipping email");
    return;
  }
  
  const hasUpsells = order.upsellsAccepted && order.upsellsAccepted.length > 0;
  
  // Build upsells HTML
  let upsellsHtml = '';
  if (hasUpsells) {
    upsellsHtml = `
      <div style="background: #f0fdf4; border: 2px solid #059669; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <h3 style="margin-top: 0; color: #059669; font-family: 'Pacifico', cursive;">üéÅ Bonus Items Added</h3>
        ${order.upsellsAccepted.map((upsell: any) => `
          <div style="padding: 10px 0; border-bottom: 1px solid #d1fae5;">
            <div style="display: flex; justify-content: space-between;">
              <span>${upsell.quantity}x ${upsell.name}</span>
              <span style="font-weight: bold;">${upsell.total.toFixed(2)}</span>
            </div>
          </div>
        `).join('')}
      </div>
    `;
  }
  
  const emailHtml = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
    </head>
    <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
      <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
          <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÖ Order Confirmed!</h1>
        </div>
        <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
          <p>Hi ${order.customerInfo.name},</p>
          
          <p style="font-size: 18px; color: #059669;"><strong>‚úÖ Your order has been confirmed and is being processed!</strong></p>
          
          <div style="background: #f9fafb; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <p style="margin: 0 0 10px 0;"><strong>Order #:</strong> ${order.orderId}</p>
            <p style="margin: 0 0 10px 0;"><strong>Letter Packages:</strong> ${order.letterPackages?.length || 0}</p>
            ${order.monthlySubscription ? `<p style="margin: 0;"><strong>Subscription:</strong> Monthly Letters</p>` : ''}
          </div>
          
          ${upsellsHtml}
          
          <div style="background: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: center;">
            <p style="font-size: 24px; margin: 0; color: #16a34a;"><strong>${order.total.toFixed(2)}</strong></p>
            <p style="margin: 5px 0 0 0;">Total Paid</p>
          </div>
          
          <p>Your magical letters from Santa are being prepared and will be mailed soon!</p>
          
          ${order.monthlySubscription ? `
          <div style="background: #dbeafe; border-left: 4px solid #3b82f6; padding: 15px; margin: 20px 0;">
            <p style="margin: 0;"><strong>üìÖ Monthly Subscription Active</strong></p>
            <p style="margin: 5px 0 0 0;">You'll receive new letters every month. Manage your subscription anytime.</p>
          </div>
          ` : ''}
          
          <p style="margin-top: 30px;">Thank you for choosing Santa's Letters!</p>
          
          <p>With Christmas cheer,<br>The Santa's Letters Team üéÑ</p>
        </div>
      </div>
    </body>
    </html>
  `;
  
  try {
    const response = await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${resendApiKey}`,
      },
      body: JSON.stringify({
        from: EMAIL_FROM,
        to: order.customerInfo.email,
        subject: `üéÖ Order Confirmed - Santa's Letters`,
        html: emailHtml,
      }),
    });

    if (!response.ok) {
      console.error("‚ùå Failed to send confirmation email:", await response.text());
    } else {
      console.log(`‚úÖ Confirmation email sent to ${order.customerInfo.email}`);
    }
  } catch (error) {
    console.error("‚ùå Error sending confirmation email:", error);
  }
}

// ============================================
// ADMIN ALERTS SYSTEM
// ============================================

// Get all alerts
app.get("/make-server-cf244566/admin/alerts", async (c) => {
  try {
    const allAlertIds = (await kv.get("alerts:all")) || [];
    const alerts = [];
    let unreadCount = 0;
    
    for (const id of allAlertIds) {
      const alert = await kv.get(`alert:${id}`);
      if (alert) {
        alerts.push(alert);
        if ((alert as any).status === "unread") {
          unreadCount++;
        }
      }
    }
    
    // Sort by created date, newest first
    alerts.sort((a: any, b: any) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
    
    return c.json({ success: true, alerts, unreadCount });
  } catch (error: any) {
    console.error("‚ùå Error fetching alerts:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Mark alert as read
app.patch("/make-server-cf244566/admin/alerts/:alertId/read", async (c) => {
  try {
    const alertId = c.req.param("alertId");
    const alert: any = await kv.get(`alert:${alertId}`);
    
    if (!alert) {
      return c.json({ error: "Alert not found" }, 404);
    }
    
    alert.status = "read";
    alert.readAt = new Date().toISOString();
    
    await kv.set(`alert:${alertId}`, alert);
    
    return c.json({ success: true, alert });
  } catch (error: any) {
    console.error("‚ùå Error marking alert as read:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Mark all alerts as read
app.post("/make-server-cf244566/admin/alerts/read-all", async (c) => {
  try {
    const allAlertIds = (await kv.get("alerts:all")) || [];
    
    for (const id of allAlertIds) {
      const alert: any = await kv.get(`alert:${id}`);
      if (alert && alert.status === "unread") {
        alert.status = "read";
        alert.readAt = new Date().toISOString();
        await kv.set(`alert:${id}`, alert);
      }
    }
    
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error marking all alerts as read:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Delete alert
app.delete("/make-server-cf244566/admin/alerts/:alertId", async (c) => {
  try {
    const alertId = c.req.param("alertId");
    
    await kv.del(`alert:${alertId}`);
    
    const allAlertIds = (await kv.get("alerts:all")) || [];
    const updatedIds = allAlertIds.filter((id: string) => id !== alertId);
    await kv.set("alerts:all", updatedIds);
    
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error deleting alert:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Helper function to create an admin alert
async function createAdminAlert(
  type: string,
  orderId: string,
  message: string,
  details: any,
  priority: "low" | "medium" | "high" = "low",
  relatedOrderId?: string
) {
  try {
    const alertId = `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    const alert = {
      id: alertId,
      type,
      orderId,
      relatedOrderId,
      message,
      details,
      status: "unread",
      priority,
      createdAt: new Date().toISOString(),
    };
    
    await kv.set(`alert:${alertId}`, alert);
    
    const allAlertIds = (await kv.get("alerts:all")) || [];
    allAlertIds.push(alertId);
    await kv.set("alerts:all", allAlertIds);
    
    console.log(`‚úÖ Admin alert created: ${type} for order ${orderId}`);
  } catch (error) {
    console.error("‚ùå Error creating admin alert:", error);
  }
}

// ============================================
// DECLINED CHARGE AUTO-RETRY SYSTEM
// ============================================

// Stripe webhook handler for declined charges
app.post("/make-server-cf244566/stripe-webhook", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }

  try {
    const signature = c.req.header("stripe-signature");
    const webhookSecret = Deno.env.get("STRIPE_WEBHOOK_SECRET");
    
    if (!webhookSecret) {
      console.error("‚ùå STRIPE_WEBHOOK_SECRET not configured");
      return c.json({ error: "Webhook secret not configured" }, 500);
    }

    if (!signature) {
      console.error("‚ùå No signature provided");
      return c.json({ error: "No signature" }, 400);
    }

    const body = await c.req.text();
    let event: Stripe.Event;

    try {
      event = stripe.webhooks.constructEvent(body, signature, webhookSecret);
    } catch (err: any) {
      console.error("‚ùå Webhook signature verification failed:", err.message);
      return c.json({ error: `Webhook Error: ${err.message}` }, 400);
    }

    console.log(`üì• Webhook received: ${event.type}`);

    // Handle invoice.payment_failed for subscription declines
    if (event.type === "invoice.payment_failed") {
      const invoice = event.data.object as Stripe.Invoice;
      const subscriptionId = invoice.subscription as string;

      if (!subscriptionId) {
        console.log("‚ö†Ô∏è Invoice has no subscription, skipping");
        return c.json({ received: true });
      }

      console.log(`üí≥‚ùå Subscription payment failed: ${subscriptionId}`);

      // Find order with this subscription
      const allOrderIds = (await kv.get("orders:all")) || [];
      let targetOrder = null;
      let targetOrderId = null;

      for (const orderId of allOrderIds) {
        const order = await kv.get(`order:${orderId}`);
        if (order && (order as any).subscriptionId === subscriptionId) {
          targetOrder = order;
          targetOrderId = orderId;
          break;
        }
      }

      if (!targetOrder) {
        console.error(`‚ùå No order found for subscription ${subscriptionId}`);
        return c.json({ received: true });
      }

      const order = targetOrder as any;

      // Create or update decline record
      const declineId = `decline_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const now = new Date().toISOString();

      const declineData = {
        declineId,
        timestamp: now,
        orderId: targetOrderId,
        subscriptionId,
        stripeInvoiceId: invoice.id,
        status: "payment_failed",
        declineReason: invoice.last_finalization_error?.message || "Payment failed",
        declineCode: invoice.last_finalization_error?.code || "unknown",
        amount: invoice.amount_due / 100,
        customerInfo: order.customerInfo,
        letterPackages: order.letterPackages,
        numberOfPackages: order.letterPackages?.length || 0,
        affiliateId: order.affiliateId || null,
        // Retry tracking fields
        retryAttempts: 0,
        firstFailureDate: now,
        lastFailureDate: now,
        nextRetryDate: new Date(Date.now() + 12 * 60 * 60 * 1000).toISOString(), // 12 hours from now
        emailsSent: [],
        retryHistory: [
          {
            timestamp: now,
            event: "Initial decline",
            details: invoice.last_finalization_error?.message || "Payment failed",
          },
        ],
      };

      await kv.set(`decline:${declineId}`, declineData);
      console.log(`‚úÖ Decline tracked: ${declineId}`);

      // Create admin alert
      await createAdminAlert(
        "payment_failed",
        targetOrderId as string,
        `Subscription payment failed for ${order.customerInfo.name}`,
        {
          subscriptionId,
          amount: declineData.amount,
          reason: declineData.declineReason,
        },
        "high"
      );

      return c.json({ received: true });
    }

    return c.json({ received: true });
  } catch (error: any) {
    console.error("‚ùå Webhook error:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Process declined charge retries (called by cron or manually)
app.post("/make-server-cf244566/admin/process-retries", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }

  try {
    console.log("üîÑ Processing declined charge retries...");

    // Get all decline records
    const allDeclines = await kv.getByPrefix("decline:");
    const now = new Date();

    let retriesAttempted = 0;
    let retriesSucceeded = 0;
    let retriesFailed = 0;
    let emailsSent = 0;

    for (const decline of allDeclines) {
      const declineData = decline as any;

      // Skip if already attempted 3 times
      if (declineData.retryAttempts >= 3) {
        continue;
      }

      // Check if it's time to retry
      const nextRetryDate = new Date(declineData.nextRetryDate);
      if (now < nextRetryDate) {
        continue; // Not time yet
      }

      console.log(`üîÑ Processing retry for decline ${declineData.declineId}`);
      retriesAttempted++;

      // Get the order
      const order = await kv.get(`order:${declineData.orderId}`);
      if (!order) {
        console.error(`‚ùå Order not found: ${declineData.orderId}`);
        continue;
      }

      const orderData = order as any;

      // Try to charge the subscription
      try {
        const subscription = await stripe.subscriptions.retrieve(declineData.subscriptionId);

        if (!subscription.latest_invoice) {
          console.error(`‚ùå No invoice found for subscription ${declineData.subscriptionId}`);
          retriesFailed++;
          continue;
        }

        // Retry the invoice payment
        const invoice = await stripe.invoices.retrieve(subscription.latest_invoice as string);
        
        if (invoice.status === "paid") {
          console.log(`‚úÖ Invoice already paid: ${invoice.id}`);
          
          // Mark decline as resolved
          declineData.status = "resolved";
          declineData.resolvedDate = new Date().toISOString();
          declineData.retryHistory.push({
            timestamp: new Date().toISOString(),
            event: "Resolved - payment successful",
            details: "Invoice was paid",
          });
          await kv.set(`decline:${declineData.declineId}`, declineData);
          
          retriesSucceeded++;
          continue;
        }

        // Try to pay the invoice
        const paidInvoice = await stripe.invoices.pay(invoice.id);

        if (paidInvoice.status === "paid") {
          console.log(`‚úÖ Retry successful for ${declineData.declineId}`);
          retriesSucceeded++;

          // Mark decline as resolved
          declineData.status = "resolved";
          declineData.resolvedDate = new Date().toISOString();
          declineData.retryHistory.push({
            timestamp: new Date().toISOString(),
            event: "Retry successful",
            details: `Payment processed successfully. Invoice: ${paidInvoice.id}`,
          });
          await kv.set(`decline:${declineData.declineId}`, declineData);

          // Send success email
          const childNames = orderData.letterPackages
            .map((pkg: any) => pkg.childFirstName)
            .join(' and ');
          await sendRetrySuccessEmail(orderData, childNames);

          continue;
        }
      } catch (error: any) {
        console.error(`‚ùå Retry failed for ${declineData.declineId}:`, error.message);
        retriesFailed++;

        // Update retry attempt
        declineData.retryAttempts++;
        declineData.lastFailureDate = new Date().toISOString();
        
        // Calculate next retry date based on attempt number
        // Attempt 1: 12h + 24h = 36h total (1.5 days)
        // Attempt 2: 36h + 24h = 60h total (2.5 days)
        // Attempt 3: stop
        if (declineData.retryAttempts < 3) {
          declineData.nextRetryDate = new Date(now.getTime() + 24 * 60 * 60 * 1000).toISOString();
        }

        declineData.retryHistory.push({
          timestamp: new Date().toISOString(),
          event: `Retry attempt ${declineData.retryAttempts} failed`,
          details: error.message,
        });

        // Send recovery email
        await sendRecoveryEmail(orderData, declineData);
        emailsSent++;

        declineData.emailsSent.push({
          timestamp: new Date().toISOString(),
          attemptNumber: declineData.retryAttempts,
          type: "recovery",
        });

        await kv.set(`decline:${declineData.declineId}`, declineData);

        // If this was the 3rd attempt, create admin alert
        if (declineData.retryAttempts >= 3) {
          await createAdminAlert(
            "payment_retry_exhausted",
            declineData.orderId,
            `All retry attempts exhausted for ${orderData.customerInfo.name}`,
            {
              declineId: declineData.declineId,
              amount: declineData.amount,
              attempts: declineData.retryAttempts,
            },
            "high"
          );
        }
      }
    }

    console.log(`‚úÖ Retry processing complete:`);
    console.log(`   Attempted: ${retriesAttempted}`);
    console.log(`   Succeeded: ${retriesSucceeded}`);
    console.log(`   Failed: ${retriesFailed}`);
    console.log(`   Emails sent: ${emailsSent}`);

    return c.json({
      success: true,
      retriesAttempted,
      retriesSucceeded,
      retriesFailed,
      emailsSent,
    });
  } catch (error: any) {
    console.error("‚ùå Error processing retries:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Send recovery email when payment fails
async function sendRecoveryEmail(order: any, decline: any) {
  const resendApiKey = Deno.env.get("RESEND_API_KEY");
  if (!resendApiKey || !order.customerInfo?.email) {
    console.log("‚ö†Ô∏è Cannot send recovery email - missing API key or email");
    return;
  }

  // Get child names from letter packages
  const childNames = order.letterPackages
    .map((pkg: any) => pkg.childFirstName)
    .join(", ");

  const emailHtml = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
    </head>
    <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
      <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background: linear-gradient(135deg, #dc2626 0%, #ea580c 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
          <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÖ Payment Issue</h1>
        </div>
        <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
          <p>Hi ${order.customerInfo.name},</p>
          
          <p style="font-size: 18px; color: #dc2626;"><strong>‚ö†Ô∏è ${childNames}'s Letter is Waiting!</strong></p>
          
          <p>We tried to process your monthly subscription payment, but it didn't go through.</p>
          
          <div style="background: #fef2f2; border-left: 4px solid #dc2626; padding: 15px; margin: 20px 0;">
            <p style="margin: 0;"><strong>What happened?</strong></p>
            <p style="margin: 5px 0 0 0;">Your card may have expired, reached its limit, or there might be insufficient funds.</p>
          </div>
          
          <div style="background: #dcfce7; border: 2px solid #16a34a; border-radius: 8px; padding: 20px; margin: 20px 0; text-align: center;">
            <p style="margin: 0 0 15px 0;"><strong>Don't let ${childNames} miss out on their magical letter!</strong></p>
            <a href="https://billing.stripe.com/p/login/test_placeholder" 
               style="display: inline-block; background: #16a34a; color: white; padding: 12px 30px; text-decoration: none; border-radius: 6px; font-weight: bold;">
              Update Payment Method
            </a>
          </div>
          
          <p><strong>Attempt ${decline.retryAttempts} of 3</strong></p>
          <p style="font-size: 14px; color: #6b7280;">We'll automatically try again in 24 hours. After 3 failed attempts, your subscription will be cancelled.</p>
          
          <p style="margin-top: 30px;">Questions? Reply to this email and we'll help!</p>
          
          <p>With Christmas cheer,<br>The Santa's Letters Team üéÑ</p>
        </div>
      </div>
    </body>
    </html>
  `;

  try {
    const response = await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${resendApiKey}`,
      },
      body: JSON.stringify({
        from: EMAIL_FROM,
        to: order.customerInfo.email,
        subject: `üéÖ Payment Issue - ${childNames}'s Letter is Waiting!`,
        html: emailHtml,
      }),
    });

    if (!response.ok) {
      console.error("‚ùå Failed to send recovery email:", await response.text());
    } else {
      console.log(`‚úÖ Recovery email sent to ${order.customerInfo.email}`);
    }
  } catch (error) {
    console.error("‚ùå Error sending recovery email:", error);
  }
}

// Migration endpoint - backfill customer IDs for existing orders
app.post("/make-server-cf244566/admin/migrate-customer-ids", async (c) => {
  try {
    const { adminPassword } = await c.req.json();
    
    // Verify admin password
    const correctPassword = Deno.env.get("ADMIN_PASSWORD");
    if (!correctPassword || adminPassword !== correctPassword) {
      return c.json({ error: "Unauthorized" }, 401);
    }
    
    if (!stripe) {
      return c.json({ error: "Stripe not configured" }, 503);
    }
    
    const allOrderIds = (await kv.get("orders:all")) || [];
    let updated = 0;
    let skipped = 0;
    let errors = 0;
    
    console.log(`üîÑ Starting migration for ${allOrderIds.length} orders...`);
    
    for (const orderId of allOrderIds) {
      const order: any = await kv.get(`order:${orderId}`);
      
      if (!order) {
        skipped++;
        continue;
      }
      
      // Skip if already has customer ID
      if (order.stripeCustomerId) {
        skipped++;
        continue;
      }
      
      // Try to get customer ID from payment intent
      if (order.stripePaymentId) {
        try {
          const paymentIntent = await stripe.paymentIntents.retrieve(order.stripePaymentId);
          
          if (paymentIntent.customer) {
            order.stripeCustomerId = paymentIntent.customer as string;
            
            // Also get payment method if available
            if (paymentIntent.payment_method && !order.stripePaymentMethodId) {
              order.stripePaymentMethodId = paymentIntent.payment_method as string;
            }
            
            await kv.set(`order:${orderId}`, order);
            updated++;
            console.log(`‚úÖ Updated order ${orderId} with customer ID`);
          } else {
            skipped++;
            console.log(`‚è≠Ô∏è Order ${orderId} has no customer in payment intent`);
          }
        } catch (error: any) {
          errors++;
          console.error(`‚ùå Error processing order ${orderId}:`, error.message);
        }
      } else {
        skipped++;
      }
    }
    
    console.log(`‚úÖ Migration complete: ${updated} updated, ${skipped} skipped, ${errors} errors`);
    
    return c.json({ 
      success: true, 
      updated, 
      skipped, 
      errors,
      total: allOrderIds.length 
    });
  } catch (error: any) {
    console.error("‚ùå Migration error:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Retry Payment - Manual admin action to force charge existing payment method
app.post("/make-server-cf244566/decline/retry-payment", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not initialized" }, 500);
  }

  try {
    const { declineId, paymentIntentId } = await c.req.json();

    if (!declineId || !paymentIntentId) {
      return c.json({ error: "Missing declineId or paymentIntentId" }, 400);
    }

    console.log(`üîÑ Admin retry payment: ${paymentIntentId}`);

    // Get the payment intent
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);

    // Try to confirm/retry the payment
    let result;
    if (paymentIntent.status === 'requires_payment_method') {
      // Cannot retry - needs new payment method
      return c.json({ 
        error: "Card declined. Please update payment method first.",
        details: "This payment requires a new payment method before it can be retried."
      }, 400);
    } else if (paymentIntent.status === 'requires_confirmation') {
      result = await stripe.paymentIntents.confirm(paymentIntentId);
    } else if (paymentIntent.status === 'requires_action') {
      // Might need 3D secure - just return current status
      return c.json({
        error: "Payment requires customer action (3D Secure)",
        details: "Customer must complete authentication",
        paymentIntentId
      }, 400);
    } else {
      // Try to create a new payment intent with same payment method
      const newPaymentIntent = await stripe.paymentIntents.create({
        amount: paymentIntent.amount,
        currency: paymentIntent.currency,
        customer: paymentIntent.customer as string,
        payment_method: paymentIntent.payment_method as string,
        confirm: true,
        description: `Retry of ${paymentIntentId}`,
        metadata: paymentIntent.metadata,
      });
      result = newPaymentIntent;
    }

    if (result.status === 'succeeded') {
      // Update decline record to resolved
      const declineData = await kv.get(`decline:${declineId}`);
      if (declineData) {
        declineData.status = 'resolved';
        declineData.resolvedDate = new Date().toISOString();
        declineData.retryHistory = declineData.retryHistory || [];
        declineData.retryHistory.push({
          timestamp: new Date().toISOString(),
          event: 'Admin Manual Retry - Success',
          details: `Payment succeeded: ${result.id}`
        });
        await kv.set(`decline:${declineId}`, declineData);
      }

      console.log(`‚úÖ Payment retry successful: ${result.id}`);
      return c.json({ success: true, paymentIntentId: result.id });
    } else {
      console.log(`‚ùå Payment retry failed: ${result.status}`);
      return c.json({ 
        error: "Payment retry failed", 
        details: result.last_payment_error?.message || result.status 
      }, 400);
    }
  } catch (error: any) {
    console.error("‚ùå Retry payment error:", error);
    return c.json({ error: error.message, details: error.raw?.message }, 500);
  }
});

// Update Payment Method - Admin adds new card from phone call
app.post("/make-server-cf244566/decline/update-payment-method", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not initialized" }, 500);
  }

  try {
    const { declineId, paymentIntentId, cardNumber, expMonth, expYear, cvc } = await c.req.json();

    if (!declineId || !paymentIntentId || !cardNumber || !expMonth || !expYear || !cvc) {
      return c.json({ error: "Missing required card details" }, 400);
    }

    console.log(`üí≥ Admin updating payment method for: ${paymentIntentId}`);

    // Get the payment intent to get customer ID
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
    const customerId = paymentIntent.customer as string;

    if (!customerId) {
      return c.json({ error: "No customer found for this payment" }, 400);
    }

    // Create a payment method from card details
    const paymentMethod = await stripe.paymentMethods.create({
      type: 'card',
      card: {
        number: cardNumber,
        exp_month: parseInt(expMonth),
        exp_year: parseInt(expYear),
        cvc: cvc,
      },
    });

    // Attach payment method to customer
    await stripe.paymentMethods.attach(paymentMethod.id, {
      customer: customerId,
    });

    // Set as default payment method
    await stripe.customers.update(customerId, {
      invoice_settings: {
        default_payment_method: paymentMethod.id,
      },
    });

    // Update the payment intent with new payment method
    await stripe.paymentIntents.update(paymentIntentId, {
      payment_method: paymentMethod.id,
    });

    // Update decline record
    const declineData = await kv.get(`decline:${declineId}`);
    if (declineData) {
      declineData.retryHistory = declineData.retryHistory || [];
      declineData.retryHistory.push({
        timestamp: new Date().toISOString(),
        event: 'Admin Updated Payment Method',
        details: `New card ending in ${cardNumber.slice(-4)}`
      });
      await kv.set(`decline:${declineId}`, declineData);
    }

    console.log(`‚úÖ Payment method updated for customer: ${customerId}`);
    return c.json({ success: true, paymentMethodId: paymentMethod.id });
  } catch (error: any) {
    console.error("‚ùå Update payment method error:", error);
    return c.json({ 
      error: error.message || "Failed to update payment method",
      details: error.raw?.message 
    }, 500);
  }
});

// Stop Recovery - Remove from retry queue and stop emails
app.post("/make-server-cf244566/decline/stop-recovery", async (c) => {
  try {
    const { declineId } = await c.req.json();

    if (!declineId) {
      return c.json({ error: "Missing declineId" }, 400);
    }

    console.log(`üõë Admin stopping recovery for: ${declineId}`);

    // Update decline record
    const declineData = await kv.get(`decline:${declineId}`);
    if (!declineData) {
      return c.json({ error: "Decline not found" }, 404);
    }

    // Mark as stopped
    declineData.status = 'stopped';
    declineData.unsubscribed = true;
    declineData.unsubscribedAt = new Date().toISOString();
    declineData.retryHistory = declineData.retryHistory || [];
    declineData.retryHistory.push({
      timestamp: new Date().toISOString(),
      event: 'Admin Stopped Recovery',
      details: 'All recovery attempts and emails stopped by admin'
    });

    await kv.set(`decline:${declineId}`, declineData);

    console.log(`‚úÖ Recovery stopped for: ${declineId}`);
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Stop recovery error:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Create payment intent for upsell from success page (requires new card input)
app.post("/make-server-cf244566/order/:token/create-upsell-payment", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not initialized" }, 500);
  }

  try {
    const token = c.req.param("token");
    const { upsellId, upsellName, price, quantity } = await c.req.json();

    if (!token || !upsellId || !price || !quantity) {
      return c.json({ error: "Missing required fields" }, 400);
    }

    console.log(`üí≥ Creating payment intent for upsell: ${upsellName} x${quantity}`);

    // Find order by access token
    const allOrderIds = (await kv.get("orders:all")) || [];
    let order: any = null;

    for (const orderId of allOrderIds) {
      const orderData: any = await kv.get(`order:${orderId}`);
      if (orderData && orderData.accessToken === token) {
        order = orderData;
        break;
      }
    }

    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    // For subscriptions, charge $0 initially (billing starts January 1st)
    const isSubscription = upsellId === "upsell_subscription";
    const totalAmount = isSubscription ? 0 : (price * quantity);

    // For subscriptions, use SetupIntent (can't charge $0 with PaymentIntent)
    // For regular upsells, use PaymentIntent
    if (isSubscription) {
      // Create SetupIntent for subscription (saves payment method for future use)
      const setupIntent = await stripe.setupIntents.create({
        customer: order.stripeCustomerId,
        description: `Santa's Magical Journey Subscription Setup (${quantity} ${quantity === 1 ? 'child' : 'children'}) - Billing starts Jan 1st`,
        metadata: {
          orderId: order.orderId,
          upsellId,
          upsellName,
          quantity: quantity.toString(),
          price: price.toString(),
          source: "success_page",
          type: "success_page_upsell",
          isSubscription: "true",
        },
        automatic_payment_methods: {
          enabled: true,
        },
      });

      console.log(`‚úÖ SetupIntent created for subscription: ${setupIntent.id}`);
      return c.json({ clientSecret: setupIntent.client_secret });
    }

    // Create payment intent for regular upsells
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(totalAmount * 100),
      currency: "usd",
      customer: order.stripeCustomerId,
      description: `${quantity}x ${upsellName} - Order ${order.orderId}`,
      metadata: {
        orderId: order.orderId,
        upsellId,
        upsellName,
        quantity: quantity.toString(),
        price: price.toString(),
        source: "success_page",
        type: "success_page_upsell",
        isSubscription: "false",
      },
      automatic_payment_methods: {
        enabled: true,
      },
    });

    console.log(`‚úÖ Payment intent created: ${paymentIntent.id}`);

    return c.json({ clientSecret: paymentIntent.client_secret });
  } catch (error: any) {
    console.error("‚ùå Error creating upsell payment intent:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Confirm upsell payment and add to order (after successful payment)
app.post("/make-server-cf244566/order/:token/confirm-upsell", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not initialized" }, 500);
  }

  try {
    const token = c.req.param("token");
    const { paymentIntentId } = await c.req.json();

    if (!token || !paymentIntentId) {
      return c.json({ error: "Missing required fields" }, 400);
    }

    console.log(`‚úÖ Confirming upsell payment: ${paymentIntentId}`);

    // Determine if this is a SetupIntent (subscription) or PaymentIntent (regular upsell)
    let metadata: any;
    let paymentMethodId: string | null = null;
    
    if (paymentIntentId.startsWith('seti_')) {
      // This is a SetupIntent (subscription)
      const setupIntent = await stripe.setupIntents.retrieve(paymentIntentId);
      
      if (setupIntent.status !== "succeeded") {
        return c.json({ error: "Setup not completed" }, 400);
      }
      
      metadata = setupIntent.metadata;
      paymentMethodId = setupIntent.payment_method as string;
    } else {
      // This is a PaymentIntent (regular upsell)
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
      
      if (paymentIntent.status !== "succeeded") {
        return c.json({ error: "Payment not completed" }, 400);
      }
      
      metadata = paymentIntent.metadata;
      paymentMethodId = paymentIntent.payment_method as string;
    }

    const { orderId, upsellId, upsellName, quantity, price, source } = metadata;

    // Find order
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    // Verify token
    if (order.accessToken !== token) {
      return c.json({ error: "Invalid access token" }, 403);
    }

    const qty = parseInt(quantity);
    const unitPrice = parseFloat(price);
    const total = unitPrice * qty;

    // HANDLE SUBSCRIPTION UPSELL - Same logic as pre-checkout
    if (upsellId === "upsell_subscription") {
      console.log(`üéÖ Creating subscription from success page for ${qty} children`);
      
      // Calculate trial end date: January 1st of next year
      const january1st = new Date(new Date().getFullYear() + 1, 0, 1);
      const trialEndTimestamp = Math.floor(january1st.getTime() / 1000);
      
      console.log(`üìÖ Setting trial_end to January 1st: ${january1st.toISOString()}`);

      try {
        // Attach payment method to customer (if not already attached)
        if (paymentMethodId) {
          try {
            await stripe.paymentMethods.attach(paymentMethodId, {
              customer: order.stripeCustomerId,
            });
          } catch (e: any) {
            // Payment method might already be attached, that's OK
            if (!e.message?.includes('already been attached')) {
              throw e;
            }
          }
          
          // Set as default payment method
          await stripe.customers.update(order.stripeCustomerId, {
            invoice_settings: {
              default_payment_method: paymentMethodId,
            },
          });
        }

        // Get the subscription price ID from environment variable
        const subscriptionPriceId = Deno.env.get('STRIPE_SUBSCRIPTION_PRICE_ID');
        if (!subscriptionPriceId) {
          console.error('‚ùå STRIPE_SUBSCRIPTION_PRICE_ID environment variable not set!');
          throw new Error('Subscription price not configured. Please create a Stripe Price for $12/month and set STRIPE_SUBSCRIPTION_PRICE_ID environment variable.');
        }

        // Create the subscription with trial period until January 1st
        const subscription = await stripe.subscriptions.create({
          customer: order.stripeCustomerId,
          items: [
            {
              price: subscriptionPriceId, // $12/month subscription price from env
              quantity: qty,
            },
          ],
          trial_end: trialEndTimestamp, // Use trial_end instead of billing_cycle_anchor
          proration_behavior: "none",
          default_payment_method: paymentMethodId,
          metadata: {
            orderId: order.orderId,
            source: "success_page_subscription",
            numberOfChildren: qty.toString(),
          },
        });

        console.log(`‚úÖ Subscription created: ${subscription.id} for ${qty} children, billing starts January 1st`);

        // CREATE A NEW SEPARATE SUBSCRIPTION ORDER (no letters sent immediately)
        const subscriptionOrderId = `SUB-${Date.now()}-${Math.random().toString(36).substring(7)}`;
        
        // Copy letter data from original order for subscription letters (up to qty)
        const subscriptionLetters = [];
        if (order.letterPackages && order.letterPackages.length > 0) {
          // Copy up to qty letters from the original order
          for (let i = 0; i < qty; i++) {
            const sourceLetter = order.letterPackages[i] || order.letterPackages[0]; // Use first letter as template if not enough
            subscriptionLetters.push({
              childFirstName: sourceLetter.childFirstName || "",
              childLastName: sourceLetter.childLastName || "",
              friendName: sourceLetter.friendName || "",
              streetAddress: sourceLetter.streetAddress || "",
              unitApt: sourceLetter.unitApt || "",
              city: sourceLetter.city || "",
              state: sourceLetter.state || "",
              zipCode: sourceLetter.zipCode || "",
              letterIndex: i + 1, // Track which letter this is
            });
          }
        } else {
          // Create blank letter data if no original order data
          for (let i = 0; i < qty; i++) {
            subscriptionLetters.push({
              childFirstName: "",
              childLastName: "",
              friendName: "",
              streetAddress: "",
              unitApt: "",
              city: "",
              state: "",
              zipCode: "",
              letterIndex: i + 1,
            });
          }
        }
        
        const subscriptionOrder: any = {
          orderId: subscriptionOrderId,
          orderDate: new Date().toISOString(),
          status: "subscription_active",
          total: 0, // $0 initial charge
          customerInfo: order.customerInfo,
          stripeCustomerId: order.stripeCustomerId,
          stripePaymentMethodId: paymentMethodId,
          stripePaymentId: paymentIntentId,
          stripeCheckoutUrl: `https://dashboard.stripe.com/subscriptions/${subscription.id}`,
          letterPackages: [], // NO LETTERS sent in this order - subscription only
          subscriptionLetters: subscriptionLetters, // Store subscription letter data separately
          numberOfPackages: 0,
          shippingDate: order.shippingDate || "", // Copy shipping date from original order
          monthlySubscription: true,
          subscriptionId: subscription.id,
          subscriptionQuantity: qty,
          subscriptionStartDate: new Date(january1st).toISOString(),
          subscriptionNextBillingDate: new Date(january1st).toISOString(),
          subscriptionMonthsActive: 0,
          subscriptionPrice: 12.00 * qty, // Total monthly price: $12 per child
          subscriptionProductName: "Santa's Magical Journey",
          billingIntervalDays: 30,
          subscriptionSource: "success_page_upsell",
          originalOrderId: order.orderId, // Reference to the original order
          accessToken: `sub_${Date.now()}_${Math.random().toString(36).substring(7)}`,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          activityLog: [
            {
              timestamp: new Date().toISOString(),
              action: "Subscription Order Created",
              details: `Subscription activated from success page for ${qty} ${qty === 1 ? 'child' : 'children'}. First billing: January 1st, ${january1st.getFullYear()} (${(12 * qty).toFixed(2)}/month). Letter data copied from original order. No immediate letters sent.`,
              user: "Customer",
              stripeUrl: `https://dashboard.stripe.com/subscriptions/${subscription.id}`,
            }
          ],
        };

        // Save the NEW subscription order
        await kv.set(`order:${subscriptionOrderId}`, subscriptionOrder);
        
        // Add to global orders list
        const allOrderIds = (await kv.get("orders:all")) || [];
        allOrderIds.push(subscriptionOrderId);
        await kv.set("orders:all", allOrderIds);

        console.log(`‚úÖ Created separate subscription order: ${subscriptionOrderId}`);

        // Update ORIGINAL order to reference the subscription order
        if (!order.activityLog) {
          order.activityLog = [];
        }
        order.activityLog.push({
          timestamp: new Date().toISOString(),
          action: "Subscription Upsell Accepted",
          details: `Customer added Santa's Magical Journey subscription (${qty} ${qty === 1 ? 'child' : 'children'}). Separate subscription order created: ${subscriptionOrderId}`,
          user: "Customer",
          stripeUrl: `https://dashboard.stripe.com/subscriptions/${subscription.id}`,
        });
        
        order.linkedSubscriptionOrderId = subscriptionOrderId;
        order.updatedAt = new Date().toISOString();
        await kv.set(`order:${orderId}`, order);
        
        console.log(`‚úÖ Original order ${orderId} updated with subscription reference`);

        // Return subscription-specific data
        return c.json({
          success: true,
          isSubscription: true,
          subscriptionId: subscription.id,
          subscriptionOrderId: subscriptionOrderId,
          upsellName: "Santa's Magical Journey",
          quantity: qty,
          total: 0,
          billingStart: january1st.toISOString(),
          monthlyPrice: 12 * qty,
        });

      } catch (subError: any) {
        console.error("‚ùå Failed to create subscription from success page:", subError);
        throw new Error(`Subscription creation failed: ${subError.message}`);
      }
    } else {
      // Regular upsell (non-subscription)
      if (!order.upsellsAccepted) {
        order.upsellsAccepted = [];
      }

      order.upsellsAccepted.push({
        upsellId: upsellId,
        name: upsellName,
        quantity: qty,
        price: unitPrice,
        total,
        chargedAt: new Date().toISOString(),
        stripePaymentIntentId: paymentIntentId,
        source: source || "success_page",
      });

      // Update order total
      order.total = (order.total || 0) + total;
      order.updatedAt = new Date().toISOString();

      // Add activity log
      if (!order.activityLog) {
        order.activityLog = [];
      }
      order.activityLog.push({
        timestamp: new Date().toISOString(),
        action: "Success Page Upsell Added",
        details: `${qty}x ${upsellName} - ${total.toFixed(2)} charged`,
        user: "Customer",
        stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntentId}`,
      });

      await kv.set(`order:${orderId}`, order);
      
      console.log(`‚úÖ Upsell confirmed and added to order: ${upsellName}`);

      // Send confirmation email for regular upsells
      try {
        const resendApiKey = Deno.env.get("RESEND_API_KEY");
        if (resendApiKey && order.customerInfo?.email) {
          const emailHtml = `
            <!DOCTYPE html>
            <html>
            <head>
              <meta charset="utf-8">
              <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
            </head>
            <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
              <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <div style="background: linear-gradient(135deg, #dc2626 0%, #059669 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                  <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üéÅ Item Added to Your Order!</h1>
                </div>
                <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                  <p>Hi ${order.customerInfo.name || "there"},</p>
                  
                  <p style="font-size: 18px; color: #059669;"><strong>‚úÖ Great choice! Your order has been updated.</strong></p>
                  
                  <div style="background: #dcfce7; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #16a34a;">
                    <p style="margin: 0 0 10px 0;"><strong>Item Added:</strong></p>
                    <p style="font-size: 20px; margin: 0; color: #16a34a;"><strong>${qty}x ${upsellName}</strong></p>
                    <p style="margin: 10px 0 0 0; font-size: 24px; color: #16a34a;"><strong>${total.toFixed(2)}</strong></p>
                  </div>
                  
                  <p style="margin-top: 30px;">This item has been added to Order #${order.orderId} and will be included with your original order.</p>
                  
                  <p style="margin-top: 30px;">Questions? Reply to this email and we'll help!</p>
                  
                  <p>With Christmas cheer,<br>The Santa's Letters Team üéÑ</p>
                </div>
              </div>
            </body>
            </html>
          `;

          await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${resendApiKey}`,
            },
            body: JSON.stringify({
              from: EMAIL_FROM,
              to: [order.customerInfo.email],
              subject: `üéÅ ${upsellName} Added to Your Order!`,
              html: emailHtml,
            }),
          });

          console.log("üìß Upsell confirmation email sent");
        }
      } catch (emailError) {
        console.error("‚ùå Failed to send confirmation email:", emailError);
        // Don't fail the request if email fails
      }

      return c.json({
        success: true,
        isSubscription: false,
        upsellName,
        quantity: qty,
        total,
      });
    }
  } catch (error: any) {
    console.error("‚ùå Error confirming upsell:", error);
    return c.json({ error: error.message }, 500);
  }
});

// ========== ADMIN SUBSCRIPTION MANAGEMENT ENDPOINTS ==========

// Update subscription letters
app.post("/make-server-cf244566/admin/update-subscription-letters", async (c) => {
  try {
    const { orderId, subscriptionLetters } = await c.req.json();

    // Get order
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    // Update subscription letters
    order.subscriptionLetters = subscriptionLetters;
    order.updatedAt = new Date().toISOString();

    // Add activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: "Subscription Letters Updated",
      details: `Subscription letter data updated by admin. Total letters: ${subscriptionLetters.length}`,
      user: "Admin",
    });

    await kv.set(`order:${orderId}`, order);

    console.log(`‚úÖ Updated subscription letters for ${orderId}`);
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error updating subscription letters:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Update subscription quantity and sync with Stripe
app.post("/make-server-cf244566/admin/update-subscription-quantity", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }

  try {
    const { orderId, newQuantity, subscriptionLetters, subscriptionId } = await c.req.json();

    // Get order
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    const oldQuantity = order.subscriptionQuantity || 0;
    const oldPrice = order.subscriptionPrice || 12.00;

    // Calculate new price based on quantity ($12 per letter)
    const newPrice = newQuantity * 12.00;

    // Update order
    order.subscriptionQuantity = newQuantity;
    order.subscriptionLetters = subscriptionLetters;
    order.subscriptionPrice = newPrice;
    order.updatedAt = new Date().toISOString();

    // Update Stripe subscription quantity
    if (subscriptionId && stripe) {
      try {
        const subscription = await stripe.subscriptions.retrieve(subscriptionId);
        
        if (subscription.items.data.length > 0) {
          const subscriptionItemId = subscription.items.data[0].id;
          
          await stripe.subscriptionItems.update(subscriptionItemId, {
            quantity: newQuantity,
          });

          console.log(`‚úÖ Updated Stripe subscription quantity from ${oldQuantity} to ${newQuantity} (Price: ${oldPrice.toFixed(2)} ‚Üí ${newPrice.toFixed(2)})`);
        }
      } catch (stripeError) {
        console.error("‚ùå Error updating Stripe subscription:", stripeError);
        throw new Error("Failed to update Stripe subscription quantity");
      }
    }

    // Add activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: "Subscription Quantity Adjusted",
      details: `Subscription quantity changed from ${oldQuantity} to ${newQuantity} letters by admin. Monthly price updated from ${oldPrice.toFixed(2)} to ${newPrice.toFixed(2)}. Stripe subscription updated.`,
      user: "Admin",
      stripeUrl: subscriptionId ? `https://dashboard.stripe.com/subscriptions/${subscriptionId}` : undefined,
    });

    await kv.set(`order:${orderId}`, order);

    console.log(`‚úÖ Updated subscription quantity for ${orderId}: ${oldQuantity} ‚Üí ${newQuantity} (Price: ${oldPrice.toFixed(2)} ‚Üí ${newPrice.toFixed(2)})`);
    return c.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error updating subscription quantity:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Charge subscription immediately
app.post("/make-server-cf244566/admin/charge-subscription-now", async (c) => {
  if (!stripe) {
    return c.json({ error: "Stripe not configured" }, 503);
  }

  try {
    const { orderId, amount, quantity, customerId, paymentMethodId } = await c.req.json();

    // Get order
    const order: any = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: "Order not found" }, 404);
    }

    // Create a payment intent to charge the customer
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(amount * 100), // Convert to cents
      currency: "usd",
      customer: customerId,
      payment_method: paymentMethodId,
      confirm: true,
      off_session: true,
      description: `Santa's Magical Journey - Manual charge for ${quantity} ${quantity === 1 ? 'letter' : 'letters'}`,
      metadata: {
        orderId: orderId,
        subscriptionCharge: "true",
        quantity: quantity.toString(),
      },
    });

    if (paymentIntent.status !== "succeeded") {
      throw new Error(`Payment failed: ${paymentIntent.status}`);
    }

    console.log(`‚úÖ Successfully charged ${amount} for subscription ${orderId}`);

    // Increment successful charges counter
    order.successfulCharges = (order.successfulCharges || 0) + 1;
    order.subscriptionMonthsActive = order.successfulCharges;
    
    // Add activity log
    if (!order.activityLog) {
      order.activityLog = [];
    }
    order.activityLog.push({
      timestamp: new Date().toISOString(),
      action: "Manual Subscription Charge",
      details: `Admin manually charged ${amount.toFixed(2)} for ${quantity} ${quantity === 1 ? 'letter' : 'letters'}. Month ${order.successfulCharges}.`,
      user: "Admin",
      stripeUrl: `https://dashboard.stripe.com/payments/${paymentIntent.id}`,
    });

    order.updatedAt = new Date().toISOString();
    await kv.set(`order:${orderId}`, order);

    // Create a new order for this charge (for fulfillment)
    console.log(`üì¶ [Custom Charge] Creating fulfillment order. Subscription letters count: ${(order.subscriptionLetters || []).length}`);
    console.log(`üì¶ [Custom Charge] Subscription letters data:`, JSON.stringify(order.subscriptionLetters));
    
    const allOrderIds = (await kv.get("orders:all")) || [];
    const newOrderId = `ord_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    const newOrder = {
      orderId: newOrderId,
      parentOrderId: order.orderId,
      subscriptionId: order.subscriptionId,
      sessionId: paymentIntent.id,
      stripePaymentId: paymentIntent.id,
      stripeCheckoutUrl: `https://dashboard.stripe.com/payments/${paymentIntent.id}`,
      orderDate: new Date().toISOString(),
      status: "pending",
      total: amount,
      customerInfo: order.customerInfo,
      letterPackages: order.letterPackages,
      numberOfPackages: order.numberOfPackages,
      letters: order.subscriptionLetters || [], // Copy subscription letter data for fulfillment
      shippingDate: "",
      monthlySubscription: false,
      subscriptionRecurringOrder: true,
      subscriptionMonth: order.successfulCharges,
      subscriptionProductName: order.subscriptionProductName || "Santa's Magical Journey",
      affiliateId: order.affiliateId,
      affiliateName: order.affiliateName,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      activityLog: [{
        timestamp: new Date().toISOString(),
        action: 'Order Created',
        details: `Recurring subscription order - Manual charge. Copied ${(order.subscriptionLetters || []).length} letter(s) from subscription.`,
        user: 'Admin'
      }]
    };
    
    await kv.set(`order:${newOrderId}`, newOrder);
    allOrderIds.push(newOrderId);
    await kv.set("orders:all", allOrderIds);
    
    console.log(`‚úÖ Created new order ${newOrderId} for manual charge`);

    // Send email notification
    try {
      const resendApiKey = Deno.env.get("RESEND_API_KEY");
      if (resendApiKey && order.customerInfo?.email) {
        const emailHtml = `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
          </head>
          <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <div style="background: linear-gradient(135deg, #7c3aed 0%, #db2777 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
                <h1 style="margin: 0; font-family: 'Pacifico', cursive; font-size: 32px;">üí≥ Payment Processed</h1>
              </div>
              <div style="background: #ffffff; padding: 30px; border: 2px solid #e5e7eb; border-top: none;">
                <p>Hi ${order.customerInfo.name || "there"},</p>
                
                <p style="font-size: 18px; color: #7c3aed;"><strong>Your subscription payment has been processed successfully.</strong></p>
                
                <div style="background: #f3e8ff; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #7c3aed;">
                  <p style="margin: 0 0 10px 0;"><strong>Santa's Magical Journey</strong></p>
                  <p style="font-size: 20px; margin: 0; color: #7c3aed;"><strong>${quantity} ${quantity === 1 ? 'Letter' : 'Letters'}</strong></p>
                  <p style="margin: 10px 0 0 0; font-size: 24px; color: #7c3aed;"><strong>${amount.toFixed(2)}</strong></p>
                </div>
                
                <p style="margin-top: 30px;">Your personalized letters from Santa will continue to arrive monthly, bringing joy and magic to your child throughout the year!</p>
                
                <p style="margin-top: 30px;">Questions? Reply to this email and we'll help!</p>
                
                <p>With Christmas cheer,<br>The Santa's Letters Team üéÑ</p>
              </div>
            </div>
          </body>
          </html>
        `;

        const emailResponse = await fetch("https://api.resend.com/emails", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${resendApiKey}`,
          },
          body: JSON.stringify({
            from: EMAIL_FROM,
            to: [order.customerInfo.email],
            subject: `üí≥ Subscription Payment Processed - ${amount.toFixed(2)}`,
            html: emailHtml,
          }),
        });

        if (emailResponse.ok) {
          const emailData = await emailResponse.json();
          console.log(`‚úÖ Payment confirmation email sent to ${order.customerInfo.email}`);

          // Log email in activity log
          await logEmailActivity(
            orderId,
            "subscription_charge_email",
            order.customerInfo.email,
            `üí≥ Subscription Payment Processed - ${amount.toFixed(2)}`,
            emailData.id
          );
        } else {
          const errorText = await emailResponse.text();
          console.error("‚ùå Failed to send payment confirmation email:", errorText);
        }
      }
    } catch (emailError) {
      console.error("‚ùå Error sending payment email:", emailError);
      // Don't fail the charge if email fails
    }

    return c.json({
      success: true,
      paymentIntentId: paymentIntent.id,
      amount,
    });
  } catch (error: any) {
    console.error("‚ùå Error charging subscription:", error);
    return c.json({ error: error.message }, 500);
  }
});

// ========== GLOBAL SETTINGS ENDPOINTS ==========

// Get global settings (default prices, etc.)
app.get("/make-server-cf244566/settings", async (c) => {
  try {
    const settings: any = await kv.get("global:settings") || {
      defaultLetterPrice: 17.95,
      updatedAt: new Date().toISOString(),
    };

    // Ensure default values exist
    if (!settings.defaultLetterPrice) {
      settings.defaultLetterPrice = 17.95;
    }

    return c.json(settings);
  } catch (error: any) {
    console.error("‚ùå Error fetching settings:", error);
    return c.json({ error: error.message }, 500);
  }
});

// Update global settings (admin only)
app.post("/make-server-cf244566/admin/update-settings", async (c) => {
  try {
    const { defaultLetterPrice } = await c.req.json();

    if (typeof defaultLetterPrice !== 'number' || defaultLetterPrice <= 0) {
      return c.json({ error: "Invalid price value" }, 400);
    }

    const settings = {
      defaultLetterPrice,
      updatedAt: new Date().toISOString(),
    };

    await kv.set("global:settings", settings);

    console.log(`‚úÖ Updated global settings: defaultLetterPrice = ${defaultLetterPrice}`);
    return c.json({ success: true, settings });
  } catch (error: any) {
    console.error("‚ùå Error updating settings:", error);
    return c.json({ error: error.message }, 500);
  }
});
*/